[["10-Purge_duplicates.html", "Chapter 10 Purging duplications", " Chapter 10 Purging duplications If you are assembling a diploid genome, then the small allelic variations between the two copies of a genome can cause several alternate duplicated contigs to be assembled. Hifiasm tries to account for this by generating alternate haplotig assembly files. However, sometimes hifiasm isn't able to clearly distinguish two contigs as being alternate haplotigs of the same genomic region. This is where purge_dups comes in. It is a piece of software that maps the original reads back to the assembly and tries to figure out which bits are alternate haplotigs and which bits are genuine haploid genome representations. The GenomeScope plot for our workshop example species Oscheius onirici didn't indicate much heterozygosity, so it is very likely that purge_dups will not find many extra contigs to remove. For this part of the workshop, we will use only the eukarya part of the genome assembly as identified by Tiara. First make a sub-folder for purge_dups and change into it: mkdir -p ~/eukaryote_assembly/3-assessment/purge_dups cd ~/eukaryote_assembly/3-assessment/purge_dups Now make a symlink to the eukarya_ part of the assembly, and to the reads from the assembly directory: ln -s ~/eukaryote_assembly/3-assessment/eukarya_ERR7979900_hifiasm.bp.p_ctg.fa ln -s ~/eukaryote_assembly/1-preassembly/ERR7979900.fastq From now on, we're going to use bash variables extensively, so that you just have to change the names of the files in the variables at the start, and then you can reuse the commands that follow on your own data in future: READS=ERR7979900.fastq CONTIGS=eukarya_ERR7979900_hifiasm.bp.p_ctg.fa CPU=16 Mapping Map the reads to the assembly (this step will take the longest, ~2 minutes) minimap2 -t $CPU -x map-hifi $CONTIGS $READS | \\ gzip -c - &gt; ${CONTIGS}.paf.gz Calculate read depth and cutoffs The first step below (pbcstat) calculates the read depth statistics. The second step uses the read depth information to decide cutoffs. If the majority of the contigs are around 20-25 read depth, then a contig with read depth between 10-12 might be a duplicated contig representing the alternate heterozygous part of the assembly. pbcstat ${CONTIGS}.paf.gz calcuts PB.stat &gt; ${CONTIGS}_cutoffs 2&gt; \\ ${CONTIGS}_calcults.log Split assembly &amp; self alignment This step is necessary to see which contigs are almost identical to other contigs. split_fa $CONTIGS &gt; ${CONTIGS}.split minimap2 -t $CPU -xasm5 \\ -DP ${CONTIGS}.split \\ ${CONTIGS}.split | \\ gzip -c - &gt; ${CONTIGS}.split.self.paf.gz Purge haplotigs A haplotig is a contig that comes from the same haplotype. This is the final step where purge_dups uses three pieces of information: the cutoffs file, the coverage (or read depth file), and the information about which contigs are almost identical to others. If a contig is lower than the cutoff, and is almost identical to another contig, then it is marked as a haplotig. The output of this step is hap.fa - the file with alternate haplotigs, and purged.fa - the file with haplotigs removed (i.e., purged). purge_dups -2 -T ${CONTIGS}_cutoffs \\ -c PB.base.cov \\ ${CONTIGS}.split.self.paf.gz &gt;${CONTIGS}_dups.bed \\ 2&gt; ${CONTIGS}_purge_dups.log get_seqs -e ${CONTIGS}_dups.bed $CONTIGS mv purged.fa ${CONTIGS}_purged.fa mv hap.fa ${CONTIGS}_hap.fa Output Let's take a look at the stats of the two files created: seqkit stats ${CONTIGS} \\ ${CONTIGS}_purged.fa \\ ${CONTIGS}_hap.fa The output should look something like this: As we suspected, only a small span (226,413 bp) was removed from the assembly, indicating this was a mostly homozygous assembly with almost no alternate haplotigs. "]]
