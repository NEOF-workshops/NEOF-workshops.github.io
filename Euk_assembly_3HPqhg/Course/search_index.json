[["01-Eukaryote_genome_assembly.html", "Eukaryote genome assembly Chapter 1 Introduction", " Eukaryote genome assembly Sujai Kumar &amp; Helen Hipperson 2023-04-20 Chapter 1 Introduction This practical session will run you through an example of eukaryote genome assembly using PacBio HiFi data. The topics covered are: Introduction to the cluster Setup Overview Genome pre-assembly Genome assembly Assembly assessment Mitochondrial assembly Scaffolding using HiC Optional exercises Conclusion The aim of this practical is to produce a genome assembly of the nematode (roundworm) Oscheius onirici, scaffold it, and produce a report with the assembly's stats. Read QC will be skipped as this has been covered in a previous NEOF workshop. We are using data from a species of nematode as an example to work through as the genome is small and the assembly steps will work quickly enough for you to perform them in this workshop. However, the workflow we are using can be applied to any eukaryotic organism. Commands are in the following font, colour, and box.They should be run in the command line. echo &quot;This is a command example&quot; This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-Cluster_Introduction.html", "Chapter 2 Cluster Introduction 2.1 Logon instructions 2.2 The Terminal Window", " Chapter 2 Cluster Introduction 2.1 Logon instructions For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent. You will now be in a logged-in Linux VNC desktop. You will see something as below (there may be only one terminal which is fine). If you do not see something similar please ask for assistance. If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. Ensure you can see one whole terminal. These instructions will not work outside of this workshop. If you would like to install your own Linux OS on your desktop or laptop we would recommend Ubuntu. The following link is a guide to install Ubuntu: https://www.ubuntu.com/download/desktop/install-ubuntu-desktop. If you use a USB you need to create a bootable USB stick. The following link will assist: https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows 2.2 The Terminal Window In our case the terminal window looks like the picture below. We are using the terminal window as our shell to interpret our commands to the kernel. Depending on your system and preferences it may look different. Already there is useful information for us on the terminal window. nsc202: This is the login name, also known as the username. In this case nsc202 is a demonstrator's account. Your screen should show a different account name which will be your username for the Linux machine/cluster you are logged into. ada02: This is the machine name the user is logged into. ~: This represents the current directory of the user, or the directory a command was run in. In the Linux OS and others '~' is a shortcut to the user's home directory. Everything after the '$' is where commands are typed into the terminal. This is also referred to as the command line. To open a new terminal window, right click on the main screen and choose Terminal "],["03-Start.html", "Chapter 3 Setup 3.1 Workshop directory &amp; data 3.2 Conda environments", " Chapter 3 Setup 3.1 Workshop directory &amp; data Prior to starting analysis we will create a working directory. The directory ~/eukaryote_assembly will contain all the inputs and outputs of our analyses. #Make directory mkdir ~/eukaryote_assembly #Move into it cd ~/eukaryote_assembly During the workflow we will keep a tidy directory structure outputting the results form different tools into their respective directories. 3.2 Conda environments Conda is a very useful tool for bioinformaticians. It allows for the creation of virtual environments so you can install different programs. This is generally easier than manually installing programs for 2 main reasons: Normally Conda will install all the dependencies a program needs. Prior to Conda it could take more than a day to install a program and all its dependencies plus the dependencies of the dependencies etc. Different programs may need different versions of the same program as a dependency (e.g. One program may need Python2 whilst another needs Python3). Therefore installing one can break the other. Having separate Conda environments (virtual environments) can isolate clashing programs. Analogy: You can think of programs as food and environments as food storage units. You could try to shove all your food into one giant cold room but most of your food will either be too cold or too warm. Instead it would be better to have different types of food in different environments as outlined in the below table. Storage environment Food examples Fridge Fresh vegetables, fresh meat, etc. Freezer Frozen meat, ice, etc. Pantry Canned food, jarred food, etc. Cellar Wine. Fruit bowl Fruit. As we will be using many different programs we will be using different Conda environments. To activate these environments you will be using use scripts that will activate the relevant Conda environment belonging to user nsc206 (Matthew Gemmell). Preferably during the course of this workflow you will have a terminal open for each Conda environment. It is important to make sure you are in the correct terminal/environment for each chapter. To load the first conda environment we will be using, run the following command (ensure this starts with a full stop and a space .): . useassembly The use scripts in this workshop are custom scripts that set up conda environments. You can look at the above scripts with less /usr/local/bin/useassembly if you are interested in its contents. You can see what environment a terminal currently has activated by looking at the command prompt. In the below picture we can see the command prompt says we are in the environment called assembly. The name of the currently activated Conda environment will always be in () before the login/user name across all systems when using Conda. For your own future analyses you would use your own Conda. "],["04-Overview.html", "Chapter 4 Overview", " Chapter 4 Overview In this bookdown we will be running a standard workflow for genome assembly with PacBio HiFi long read data and scaffolding the assembly with Illumina Hi-C data. The assembler and scaffolding softwares are specific to these types of data. However, the pre-assembly and assessment steps can be applied to genome assemblies with other data types such as ONT. Below is a diagram of the workflow. This workflow will not always be effective and may require the use of other assemblers or other processes. "],["05-Pre_assembly.html", "Chapter 5 Genome pre-assembly 5.1 Introduction 5.2 Obtaining the read data 5.3 Counting reads and bases 5.4 Counting and analysing k-mers 5.5 Summary", " Chapter 5 Genome pre-assembly 5.1 Introduction Assembling a eukaryotic genome using short reads used to be a time consuming process. One had to do a lot of QC checks to see if the reads had any quality issues or remaining adapters. With PacBio Hifi reads, the quality and length and adapters are not usually an issue as the PacBio HiFi platform has already done the circular consensus step so what you get is high quality long read data. However, it's good to have a sense of whether your read coverage is adequate, and whether your genome is haploid, diploid, or polyploid. To do this we analyse the k-mers present in the HiFi reads. The broad steps are to first run a k-mer counter, and then run the resulting histograms through a tool like Genomescope. 5.2 Obtaining the read data We are going to assemble the genome of a nematode Oscheius onirici which we expect to be 60-100 million bases or Megabases (Mb) in size because other Oscheius species are approximately that size. First, we need to create a directory to put the data in and then change directory to it. mkdir -p ~/eukaryote_assembly/1-preassembly cd ~/eukaryote_assembly/1-preassembly Now we can generate a symbolic link (i.e. shortcut) to the raw sequence data file, which will appear in the current directory: ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR7979900.fastq If you would like to know more about the ln command please check out this guide. Now, check the symbolic link is in your current directory: ls The file name should appear in blue. If it appears in red with a black background this indicates that the file has not been found. If you see this check the file path and name carefully for typos and try again. The file has one run of PacBio HiFi data for Oscheius onirici. 5.3 Counting reads and bases A simple QC step is to count how many reads and bases are in the raw data. To get an estimate of how much data is in this file we will use seqkit: seqkit stats ERR7979900.fastq The output shows that there are almost 1 million sequences (num_seqs = 976,950) totalling 10,800 Mb of raw sequence data (sum_len = 10,801,040,319). This means that for a genome of size 60-100 Mb, we have at least 10,800 / 100 = 108X depth. The \"X\" can be read as \"times\" - i.e. the number of times we expect each base in the genome assembly to be covered by a raw sequence read. Some people also refer to sequencing depth as sequencing coverage. A good rule of thumb for PacBio HiFi sequencing is that we should have at least 30X sequencing depth for a good assembly, so a minimum of 108X depth is more than fine for our needs and we can proceed. 5.4 Counting and analysing k-mers Another QC step that can be run very fast is k-mer analysis. K-mers are short, overlapping sub-sequences of length k from a longer sequence. For example, here are all the 3-mers (i.e. k=3) from the read ATGAATC: ATG TGA GAA AAT ATC There are many great reviews and tutorials on why k-mers work and how you can use them to analyse read sets and assemblies. But for now, we're going to use them in a simple way to estimate the size of the genome and it's heterozygosity. We will use the software kmc to do this: kmc -cs2000 -k21 ERR7979900.fastq ERR7979900k21 . -cs&lt;value&gt; - maximal value of a counter (default: 255). When you have ~108X depth (from just counting reads and bases), it is a good idea to bump this up to 2,000 or even 10,000 -k&lt;len&gt; - k-mer length (k from 1 to 256; default: 25). We picked k21 to match the default for GenomeScope which we will use in the next step. You can try different values like k25 or k31. Just remember to change the value in the GenomeScope input form as well. The end result should be roughly the same ERR7979900k21 is the prefix of the output files . Use the current directory for storing temporary files This step should take about 2-3 minutes to count all the k-mers and store them in kmc's own binary file formats with the .kmc_suf and .kmc_pre extensions. Now use the kmc's transform tool to extract a k-mer frequency histogram: kmc_tools transform ERR7979900k21 histogram ERR7979900k21.histo transform is the kmc_tools function ERR7979900k21 is the prefix of the input files histogram is the command to kmc_tools to create that kind of output ERR7979900k21.histo is the output histogram file name The output file ERR7979900k21.histo is a simple text file with two columns: Column 1 has the number of copies of a k-mer of size k (21 in this case), and column 2 has the frequency, i.e. how many different k-mers have that copy number. The next step is to view the histogram. But first we will talk about background and foreground processes. Normally when you run a command it will run the process in the foreground. This means your command line will be locked whilst the process is running. You will only be able to type a new command in the terminal once the foreground process is finished. This is normally wanted but not always, for example when you run a process like firefox. To run a process in the background, so you can type and run new commands, you can add the symbol &amp; to the end of a command. Using firefox open the GenomeScope web page and upload the .histo file: firefox http://qb.cshl.edu/genomescope/genomescope2.0/ &amp; To upload this file click in the box where it says \"Click or drop .histo file here to upload\", double-click on your \"1-preassembly\" directory and choose the ERR7979900k21.hist file. You can leave the rest of the fields as they are and then click Submit, the Continue. After a minute or two of processing the plots will appear in the browser. The first plot in the output should look like this: According to this plot, the length of the genome estimated from k-mers is len:258,425bp - which is way too small for a nematode genome that we expect to be around 60-100 Mb. Something has clearly gone wrong! The problem is that because there is so much data in our raw sequence file, the k-mer coverage on the x-axis goes all the way up to 3000, and GenomeScope automatically decided that the little peak near 2000X coverage (on the x axis) was the right peak for the genome assembly. The area under that peak was only ~258 kb so GenomeScope reported that, and it counted the real peak of the data around 100X on the x axis as low-frequency errors, shown in the orange curve. This may happen when you are analysing your own data as well. If this happens, we can force GenomeScope to disregard the high coverage k-mers (which are likely to be mitochondria or ribosomal RNA repeats) by setting Max k-mer coverage: 1000 in this case. Open a NEW browser tab, type http://qb.cshl.edu/genomescope/genomescope2.0/ into the address bar and upload the ERR7979900k21.histo file again. This time, set the Max k-mer coverage to 1000 and then click Submit and Continue. After a minute or two you should see a set of plots, and the first plot should look like this: This time the genome length estimate of len:95,828,752bp seems more in line with what we expect. GenomeScope also reports aa:99.6% i.e 99.6% of this dataset is homozygous and the plot itself is a single peak, which means that the two copies of each diploid chromosome are almost identical. If GenomeScope had reported a homozygosity % like aa:97% and shown two peaks, that would have meant a higher level of heterozygosity. Low heterozygosity in diploid or polyploid samples can aid the assembly process and so inbred lines or strains are often used when this is practical to do so. For most taxa, however, this is not possible and a higher level of heterozygosity would be expected. For more details, see GenomeScope 2.0 and Smudgeplot for reference-free profiling of polyploid genomes 5.5 Summary Counting reads and bases and k-mers in a set of read files can give you a good sense of whether your genome assembly is going to work, and whether you need to worry about low coverage, or highly erroneous k-mers, etc. The length of the genome assembly should be roughly what you expect the genome size to be. It may not be the exact size of your species of interest if the sample also includes DNA from other co-bionts such as contaminants or parasites or endosymbionts. "],["06-Assembly.html", "Chapter 6 Genome assembly 6.1 Overview 6.2 Downsample raw data 6.3 Run the Hifiasm assembler 6.4 Summary", " Chapter 6 Genome assembly 6.1 Overview In this section we're going to assemble a eukaryotic genome from long and highly accurate (&gt;Q30) PacBio HiFi reads. The following workflow is courtesy Lewis Stevens who uses it to assemble nematode genomes (which range in size from 50-700 Mbp). Broadly, the same steps are also used by the Darwin Tree of Life Project, which is sequencing 70,000 eukaryotic species, ranging in size from 15 Mbp fungal genomes, to 100 Gbp plants genomes. 6.2 Downsample raw data First, we need to create a directory to put the data in and then change directory to it. mkdir -p ~/eukaryote_assembly/2-assembly cd ~/eukaryote_assembly/2-assembly Assembling the whole raw read file takes about 3 hours on our computers. So we are going to downsample the raw reads file so that it runs in a few minutes for this tutorial. If you were doing a real genome assembly project, you would give the whole file as an input. The original file had 10,800 Mb, whereas the expected genome size is &lt;100 Mb, or ~108X sequencing depth. For this exercise we will sample only 6% of the input data using a popular tool called seqtk. 6% of the data is roughly equal to 6X sequencing depth/coverage. A good pacbio hifi assembly usually needs at least 30X depth. Even if you are doing a real genome assembly project and not a tutorial/workshop like this one, it can be helpful to work with downsampled data that runs fast to check that the software tools are all installed correctly. Note: The below command can be run over one line excluding the \\ Alternatively, you can type \\ during a command and then press the enter key. The next line on the command line will start with &gt;. This will allow you to continue typing the command on the line. This can be used to type one command over multiple lines. We often present the command lines like this in the workbook to help make them easier to read. To downsample the data to only 6% of the original size: seqtk sample ~/eukaryote_assembly/1-preassembly/ERR7979900.fastq 0.06 | \\ gzip -c &gt; ERR7979900.6pct.fastq.gz The seqtk sample command takes two arguments input_file and percentage_to_sample so we gave it the original raw read file from the previous directory, and 0.06 or 6%. The | gzip -c &gt; part pipes the output of the first command through the gzip programme and stores the result in ERR7979900.6pct.fastq.gz 6.3 Run the Hifiasm assembler We are now ready to use hifiasm to assemble the 6% downsampled data. hifiasm is a very fast genome assembler for PacBio HiFi data: hifiasm -l 0 -t 16 -o ERR7979900_hifiasm6l0 ERR7979900.6pct.fastq.gz This command should take ~8 minutes, during which time information about the progress of the assembly is printed to the terminal. Further information and discussion on this can be found here. Explanation of the parameters: -l (lower case letter l) Level of purge duplication. 0 to disable, 1 to only purge contained haplotigs, 2 to purge all types of haplotigs, 3 to purge all types of haplotigs in the most aggressive way. Default 3. We changed it to 0 as the GenomeScope plot only had one clear peak indicating a highly homozygous assembly. -o (lower case letter o) Output prefix. We used the input read file name followed by *_hifiasm6* to indicate that it is a hifiasm assembly on only 6% of the reads, followed by l0 to indicate the level of duplicate purging applied -t Number of CPU threads Hifiasm returns several .gfa files which have the graph structure of the assembled fasta contigs. We need the file with the suffix .bp.p_ctg.gfa as that has the primary assembled contigs. To convert it to fasta, we use an awk command that prints out the sequence headers and the sequence in fasta format: awk &#39;/^S/{print &quot;&gt;&quot;$2;print $3}&#39; ERR7979900_hifiasm6l0.bp.p_ctg.gfa &gt; ERR7979900_hifiasm6l0.bp.p_ctg.fa If you run the UNIX command ls -lh to see the size of the files, you should see it is about 80 Megabytes in size: ls -lh ERR7979900_hifiasm6l0.bp.p_ctg.fa 6.4 Summary In this exercise, you have successfully downsampled the raw read sequence data and run the hifiasm assembler. In a real genome assembly project, you would not downsample the data. However, sometimes you may have more than 500X or 1000X sequencing depth if you are assembling a species with a small genome size. In those cases, you may want to downsample the raw data to about 50X using the method shown here, because otherwise the assembly will take very long, and might give you too many alternate contigs. In the next section you will look at tools and approaches to assess what you have asssembled. "],["07-Genome_assessment.html", "Chapter 7 Genome assembly assessment 7.1 Obtaining the full assembly 7.2 Basic assembly statistics 7.3 Check for contamination 7.4 BUSCO 7.5 Purging duplications using purge_dups 7.6 Assessment recap", " Chapter 7 Genome assembly assessment After carrying out a genome assembly, you should always do some basic checks on it to make sure it has the expected size, and that it matches the species that you sampled. In this section we will use a few different tools to check the quality of the assembly: seqkit - which you used to check the raw read files as well tiara - a very fast bacterial and prokaryote DNA classifier busco - for finding universal single copy orthologues for that clade We will also learn about purge_dups, a tool for removing duplicate contigs so that you are left with only a haploid genome assembly. In the previous section you saw how to run the hifiasm assembler on a smaller downsampled subset of reads. In this section we will be using the full genome assembly (which took about 3 hours to complete). 7.1 Obtaining the full assembly We need to create a directory to put the assembly in and then change directory to it. mkdir -p ~/eukaryote_assembly/3-assessment cd ~/eukaryote_assembly/3-assessment Create a symbolic link (i.e. shortcut) to the fasta file with the full assembly ln -s /pub14/tea/nsc202/ERR7979900_hifiasm.bp.p_ctg.fa 7.2 Basic assembly statistics Run seqkit stats to find some basic statistics about the genome assembly: seqkit stats -a ERR7979900_hifiasm.bp.p_ctg.fa -a specifies all stats, including n50 You should see an output like this: file format type num_seqs sum_len min_len avg_len max_len Q1 Q2 Q3 sum_gap N50 Q20(%) Q30(%) GC(%) ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 548 122,586,855 6,222 223,698.7 13,381,880 21,636.5 27,578 40,509.5 0 5,147,866 0 0 51.9 Statistics such as num_seqs, sum_len, min_len, avg_len, max_len etc are self explanatory, but you can get a full reference here. The Q20, Q30 values are only for FastQ files which have quality scores as well. Hifiasm creates a contig assembly, i.e. it creates contiguous sequences with no gaps, therefore sum_gap = 0. You may not be aware of the N50 metric, which is calculated using the following method: Order the contigs from largest to smallest. Find the point that is 50% the length of the assembly starting from the start of the largest contig going toward the smallest contig. Determine which contig this point belongs to. The N50 is equal to the length of that contig. In this assembly, 122 Mb of total sequence is assembled in only 548 sequences. The contig N50 is &gt; 5Mb which is good as anything above 1Mb is generally considered to be high quality. Some things you will want to look out for in future projects: High number of contigs, with small N50: This may indicate the genome assembly is very uncontiguous and so the assembler had issues with assembly. It is possible the genome is a particularly difficult one to resolve. The input data could be poor. Examples include: Low quality. Low coverage. Average coverage could be good but it is possible that there are areas of the genome that have low coverage, so these areas might not be assembled well. Length is not correct: Could be caused by several reasons: Parts of the genome are duplicated in the assembly causing the assembly to be too long. This can happen when a consensus could not be reached effectively for part of the genome. A short assembly can indicate that parts of the genome are missing. A drastically increased length can indicate the presence of contamination from another organism. The GC(%) can give a clue if this may be the case if it is different from what you might expect for your study species. Further assessment can elucidate if there are any issues and what they may be. 7.3 Check for contamination When assembling the genome of a eukaryote, it is very common to accidentally also sequence bacteria or other microorganisms that live alongside, on the surface of, or inside the target organism. There might also be endosymbionts (bacteria that live inside the cell of the eukaryote, eg Wolbachia), symbionts (eg Cyanobacteria when sequencing lichen), parasites (eg apicomplexan parasites inside some insects), or even the host organism if the target organism is a parasite (eg a host plant if you are sequencing a parasitoid gall wasp). In general, a non-target organism in your sample can be called a co-biont, i.e. an organism present alongside your organism of interest in a given sample. A full discussion of methods for separating these cobionts is beyond the scope of this course. However, when doing a eukaryote genome assembly, it is always a good idea to do a quick check for bacteria and other prokaryotes using Tiara. Tiara is a very fast deep-learning based tool for identifying archaea, bacteria, prokarya, eukarya, and organelle (mitochondria and plastids) sequences. First we need to open a new terminal window (right click -&gt; click terminal), load the tiara environment and then navigate to your 3-assessment directory. . usetiara cd ~/eukaryote_assembly/3-assessment In this example, we have used a bash environment variable called ASSEMBLY, so that if you want to run it again, you just have to change the value of this variable in the first line. ASSEMBLY=ERR7979900_hifiasm.bp.p_ctg.fa tiara -i $ASSEMBLY -o $ASSEMBLY.tiara -t 16 --pr --tf all -i is the input sequence fasta file -o is the name of the main output file -t is the number of CPU threads to use --pr outputs probabilities for each class (bacteria, eukarya, etc) for each sequence --tf all splits the input fasta files into separate fasta files for each high probability assignment. Take a look inside the main output file ERR7979900_hifiasm.bp.p_ctg.fa.tiara. The first few lines should look like this: sequence_id class_fst_stage class_snd_stage org bac arc euk unk1 pla unk2 mit ptg000001l eukarya n/a 0.001638 0.001968 0.000518 0.995876 0.000000 n/a n/a n/a ptg000002l eukarya n/a 0.000000 0.000059 0.000574 0.999367 0.000000 n/a n/a n/a ptg000003l eukarya n/a 0.000011 0.001375 0.001749 0.996865 0.000000 n/a n/a n/a ptg000004l eukarya n/a 0.000000 0.001148 0.000726 0.998127 0.000000 n/a n/a n/a ptg000005c bacteria n/a 0.000000 0.999976 0.000024 0.000000 0.000000 n/a n/a n/a ptg000006l bacteria n/a 0.000000 0.999999 0.000001 0.000000 0.000000 n/a n/a n/a ptg000007l eukarya n/a 0.000019 0.001668 0.004887 0.993426 0.000000 n/a n/a n/a ptg000008l eukarya n/a 0.000001 0.000232 0.000022 0.999745 0.000000 n/a n/a n/a ptg000009c bacteria n/a 0.000000 0.999979 0.000001 0.000020 0.000000 n/a n/a n/a Columns 2 and 3 show you that Tiara runs in two stages: the first stage identifies organelles, bacteria, archaea, eukarya, and unknown (unk1) the second stage further identifies organelle sequences as plastid, mitochondria, and unknown (unk2) The final set of probabilities for each sequence is in the remaining columns. If the probability for a particular class (eg eukarya) is above a certain threshold, it will put the fasta sequence for that class in a separate CLASS_$ASSEMBLY file, (eg eukarya_ERR7979900_hifiasm.bp.p_ctg.fa). You can see the default thresholds by just typing the tiara command on its own. Let's see how many sequences got assigned to each category. We can use the seqkit stats that we used earlier and give all the files created. First go back to your terminal window with the assembly environment loaded (hint: the command prompt will start with (assembly)). First you'll need to specify the $ASSEMBLY variable again for this terminal, tnen run seqkit: ASSEMBLY=ERR7979900_hifiasm.bp.p_ctg.fa seqkit stats *$ASSEMBLY *$ASSEMBLY will list all files that begin with the wildcard * (0 or more characters) and end with $ASSEMBLY, in this case all files that end with ERR7979900_hifiasm.bp.p_ctg.fa: The output should look like this: file format type num_seqs sum_len min_len avg_len max_len ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 548 122,586,855 6,222 223,698.7 13,381,880 bacteria_ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 493 56,346,101 6,222 114,292.3 5,147,866 eukarya_ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 38 65,597,190 10,925 1,726,241.8 13,381,880 plastid_ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 1 16,568 16,568 16,568 16,568 unknown_ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 16 627,026 23,742 39,189.1 77,760 Based on this table, most of the assembly by number (493 out of 548 sequences), and almost half by span (56 Mb out of 122 Mb) is actually bacterial in origin. The default threshold for assigning a sequence to one of the above classes is 0.65. If you change that to 0.9 (Hint: use the -p option in tiara), what is the span of eukaryotic sequences? 55 Mb 65 Mb 75 Mb 85 Mb In this case, Tiara has done a very good job of separating the eukaryotic nematode sequences from the rest, because we know that the Oscheius onirici genome is 65 Mb in size. However, the 16 kb sequence labelled plastid is odd as only plants should have plastids. We can check this sequence by Blasting it. Using firefox, load the BLAST webpage and upload the plastid fasta file. firefox https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn &amp; Click on Nucleotide BLAST &gt; Browse next to where it says 'upload file' and choose the plastid assembly file. Under 'Organism' enter 'Oscheius (taxid:42476)' and run a megablast search. After a few minutes the results will appear, and you can see that this is in fact the mitochondrial genome. A few things to remember: Tiara sometimes labels mitochondrial sequences as plastids Tiara is not perfect. It is a lightweight and fast way to get a sense of what is going on in your assembly. A very good tool that requires more resources but is also fast is the NCBI Foreign Contamination Screen 7.4 BUSCO BUSCO stands for Benchmarking Universal Single-Copy Orthologs. The tool is used to estimate the completeness of genome assemblies by determining how many BUSCOs are present. BUSCOs are genes that are: Universal: The genes are present in all organisms of a specific lineage. Single-Copy: The genes are only found as one copy. 7.4.1 BUSCO lineages BUSCO has many different lineage datasets. These are datasets of the different groups of BUSCOs found in various different lineages. Carry out the below command to see all these different datasets. First make sure that you are make in the . useassembly terminal window. busco --list-datasets | less -S You will notice that the lineage datasets are at various taxonomic levels going from high-level kingdoms (bacteria, archaea, &amp; eukaryota) down to lower-level taxon lineages (primates, insecta, saccharomycetes etc). It is always good to be as specific as you can to your organism's lineage. A more specific lineage will have more BUSCOs than a more generic one. Note: All datasets end with _odb10 which stands for OrthoDB version 10. Looking through the choices (and using the NCBI taxonomy website) what lineage dataset would you use for the following genera? Heliconius (Taxonomy ID: 33416) lepidoptera_odb10 diptera_odb10 arthropoda_odb10 eukaryota_odb10 Saccharomyces (Taxonomy ID: 4930) eukaryota_odb10 saccharomycetes_odb10 bacteria_odb10 fungi_odb10 Oscheius (Taxonomy ID: 42476) insecta_odb10 metazoa_odb10 nematoda_odb10 eukaryota_odb10 Neoparamoeba (Taxonomy ID: 1641714) alveolata_odb10 coccidia_odb10 plasmodium_odb10 eukaryota_odb10 Click to reveal links to NCBI taxonomies Heliconius (Taxonomy ID: 33416) Saccharomyces (Taxonomy ID: 4930) Oscheius (Taxonomy ID: 42476) Neoparamoeba (Taxonomy ID: 1641714) 7.4.2 Run BUSCO For our Oscheius onerici example, we will choose the nematoda_odb10 as our lineage dataset. With that we can run BUSCO on our genome assembly. Note: The parameters -i, -l, -m, &amp; -o are all letters. busco \\ -i $ASSEMBLY \\ -l nematoda_odb10 \\ -m geno \\ -o $ASSEMBLY\\_nematoda_odb10 \\ --cpu 16 Parameter choice -i : The input genome assembly in fasta format. -l : The lineage dataset to be used. This has to end with the _odb10 part. This will download the dataset (if it does not exist) into a directory called busco_downloads in the current directory. The directory will be created if it doesn't exist. -m : The assessment mode. geno = genome assemblies (DNA) tran = transcriptome assemblies (DNA) prot = annotated gene sets (protein) -o : The run name. Output folders and files will be labelled with this name. --cpu : The number of cpu threads to use This command should take ~10 minutes to run. 7.4.3 BUSCO output There are many output files in the directory ERR7979900_hifiasm.bp.p_ctg.fa_nematoda_odb10. A full list of the output can be found in the following link: https://busco.ezlab.org/busco_userguide.html#outputs I ignore the majority of the output files most of the time, instead only looking at the short summary file. less ERR7979900_hifiasm.bp.p_ctg.fa_nematoda_odb10/short_summary.specific.nematoda_odb10.ERR7979900_hifiasm.bp.p_ctg.fa_nematoda_odb10.txt This provides us with 6 values. These values are presented in terms of percentage (along the top line of the Results) and total numbers (the next 6 lines). The values represent: Complete BUSCOs : The number of complete BUSCOs discovered. The closer this value is to 100% the better. This number is the sum of the next two values. Complete and single-copy BUSCOs: The number of BUSCOs found as complete and single-copy. The closer this number is to 100% the better. A good assembly will generally be &gt;90%. Complete and duplicated BUSCOs: Complete BUSCOs that have been found two or more times within the assembly. This indicates there are duplicated areas of the genome. Preferably we would like this number to be low. Fragmented BUSCOs: This could indicate that there are genes that are only partially present within the genome. This could be due to misassmebly. Missing BUSCOs: These are BUSCOs that could not be found in the genome assembly. This could indicate that parts of the genome are missing in the assembly. Total BUSCO groups searched: This represents the total number of BUSCOs within the lineage dataset used for analysis. For more info on interpreting the results please see the following link: https://busco.ezlab.org/busco_userguide.html#interpreting-the-results 7.4.4 BUSCO questions Answer the below MCQs based on the results in your short summary file. Ignoring \"total BUSCO groups searched\", which value is the highest? Complete BUSCOs (C) Fragmented BUSCOs (F) Missing BUSCOs (M) What is the sum of fragmented and missing BUSCOs? 1 151 616 Which value would you want to be highest for a complete non duplicated assembly? Complete and single-copy BUSCOs (S) Complete and duplicated BUSCOs (D) Fragmented BUSCOs (F) Missing BUSCOs (M) 7.4.5 BUSCO summary The BUSCO stats are OK for this assembly. There are more fragmented and missing BUSCOs than we would like. We'll try to improve this with scaffolding. Even though the BUSCO gene sets are meant to be universal (i.e. applicable to all species within a busco lineage), we have found that some clades are never more than 80-85% complete even when the full chromosomal level genome assembly is available. 7.5 Purging duplications using purge_dups If you are assembling a diploid genome, then the small allelic variations between the two copies of a genome can cause several alternate duplicated contigs to be assembled. Hifiasm tries to account for this by generating alternate haplotig assembly files. However, sometimes hifiasm isn't able to clearly distinguish two contigs as being alternate haplotigs of the same genomic region. This is where purge_dups comes in. It is a piece of software that maps the original reads back to the assembly and tries to figure out which bits are alternate haplotigs and which bits are genuine haploid genome representations. The genomescope plot for our workshop example species Oscheius onirici didn't indicate much heterozygosity, so it is very likely that purge_dups will not find many extra contigs to remove. For this part of the workshop, we will use only the eukarya part of the genome assembly as identified by Tiara. First make a sub-folder for purge_dups and change into it: mkdir -p ~/eukaryote_assembly/3-assessment/purge_dups cd ~/eukaryote_assembly/3-assessment/purge_dups Now make a symlink to the eukarya_ part of the assembly, and to the reads from the assembly directory: ln -s ~/eukaryote_assembly/3-assessment/eukarya_ERR7979900_hifiasm.bp.p_ctg.fa ln -s ~/eukaryote_assembly/1-preassembly/ERR7979900.fastq From now on, we're going to use bash variables extensively, so that you just have to change the names of the files in the variables at the start, and then you can reuse the commands that follow on your own data in future: READS=ERR7979900.fastq CONTIGS=eukarya_ERR7979900_hifiasm.bp.p_ctg.fa CPU=16 Map the reads to the assembly (this step will take the longest, ~2 minutes) minimap2 -t $CPU -x map-hifi $CONTIGS $READS | \\ gzip -c - &gt;${CONTIGS}.paf.gz Calculate read depth and cutoffs: pbcstat ${CONTIGS}.paf.gz calcuts PB.stat &gt; ${CONTIGS}_cutoffs 2&gt; \\ ${CONTIGS}_calcults.log The first step above gets read depth statistics. The second step uses that information to decide cutoffs, e.g., if the majority of the contigs are around 20-25 read depth, then a contig with read depth between 10-12 might be a duplicated contig representing the alternate heterozygous part of the assembly. Split assembly and do self alignment: split_fa $CONTIGS &gt;${CONTIGS}.split minimap2 -t $CPU -xasm5 \\ -DP ${CONTIGS}.split \\ ${CONTIGS}.split | \\ gzip -c - &gt;${CONTIGS}.split.self.paf.gz This step is necessary to see which contigs are almost identical to other contigs. Purge haplotigs: purge_dups -2 -T ${CONTIGS}_cutoffs \\ -c PB.base.cov \\ ${CONTIGS}.split.self.paf.gz &gt;${CONTIGS}_dups.bed \\ 2&gt;${CONTIGS}_purge_dups.log get_seqs -e ${CONTIGS}_dups.bed $CONTIGS mv purged.fa ${CONTIGS}_purged.fa mv hap.fa ${CONTIGS}_hap.fa A haplotig is a contig that comes from the same haplotype. This is the final step where purge_dups uses three pieces of information: the cutoffs file, the coverage (or read depth file), and the information about which contigs are almost identical to others. If a contig is lower than the cutoff, and is almost identical to another contig, then it is marked as a haplotig. The output of this step is hap.fa - the file with alternate haplotigs, and purged.fa - the file with haplotigs removed (i.e. purged). Let's take a look at the stats of the two files created: seqkit stats ${CONTIGS} \\ ${CONTIGS}_purged.fa \\ ${CONTIGS}_hap.fa The output should look something like this: file format type num_seqs sum_len min_len avg_len max_len eukarya_ERR7979900_hifiasm.bp.p_ctg.fa FASTA DNA 38 65,597,190 10,925 1,726,241.8 13,381,880 eukarya_ERR7979900_hifiasm.bp.p_ctg.fa_purged.fa FASTA DNA 12 64,693,209 19,183 5,391,100.8 13,381,880 eukarya_ERR7979900_hifiasm.bp.p_ctg.fa_hap.fa FASTA DNA 27 903,981 10,925 33,480.8 64,403 As we suspected, only a small span (903,981 bp) was removed from the assembly, indicating this was a mostly homozygous assembly with almost no alternate haplotigs. 7.6 Assessment recap We used the following tools to assess our assembly: seqkit stats to get assembly metrics tiara to see how much bacterial/archaeal sequence was in the assembly busco to see how complete the eukaryote part of the assembly was purge_dups to get rid of any duplicated sequences as a result of heterozygosity "],["08-Mitochondrial_assembly.html", "Chapter 8 Mitochondrial assembly 8.1 Introduction 8.2 Set up 8.3 Run MitoHiFi 8.4 Run MitoHifi on the organelle reference 8.5 Summary", " Chapter 8 Mitochondrial assembly 8.1 Introduction In this section we will assembly and annotate the mitochondrial genome 8.2 Set up Open a new terminal and load the MitoHiFi environment: . usemitohifi Create a new directory, change into it, and link to the files we need: mkdir -p ~/eukaryote_assembly/4-mito cd ~/eukaryote_assembly/4-mito Link to the full assembly: ln -s /pub14/tea/nsc202/ERR7979900_hifiasm.bp.p_ctg.fa 8.3 Run MitoHiFi We will use MitoHifi, which has been developed by the Darwin Tree of Life team to assemble mitochondrial genomes from PacBio HiFi sequencing data. The pipeline requires an existing mitochondrial genome reference from a closely related species. The software includes a script that can be used to find and download this from NCBI. We will specify the name of our study species and a minimum sequence length of 16 kb: python /pub14/tea/nsc206/git_installs/MitoHiFi/findMitoReference.py \\ --species &quot;Oscheius onirici&quot; \\ --outfolder ./ \\ --min_length 16000 This will take a few minutes to run, and when finished will have downloaded a fasta and genbank file for a mitochondrial genome of a closely related species. ls You should see two files with the prefix 'NC_029233.1'. MitoHifi can either assemble the mitochondrial genome using raw HiFi reads, or using an assembly. Here we'll use our existing assembly, as this runs faster. python /pub14/tea/nsc206/git_installs/MitoHiFi/mitohifi.py \\ -c ERR7979900_hifiasm.bp.p_ctg.fa \\ -f NC_029233.1.fasta -g NC_029233.1.gb \\ -t 1 -o 5 This should take about 5 minutes to run. The parameter options we have specified are: -c the assembled contigs fasta file -f the mitogenome fasta from a closely related species -g the genbank format file from a closely related species -t the number of threads to use -o the organism's mitochondrial genetic code. Here we use 5 for the Invertebrate Mitochondrial Code. For other taxa you can check what this parameter should be by looking it up on the NCBI taxonomy page under 'Mitochondrial genetic code' The output files include the following: final_mitogenome.fasta the final mitochondrial genome circularized and rotated to start at tRNA-Phe. final_mitogenome.gb the final mitochondrial genome annotated in GenBank format. final_mitogenome.annotation.png the predicted genes throughout the final mitogenome. contigs_stats.tsv the statistics of your assembled mitochondrial genome including the number of genes and the total size. We can view the image of the predicted genes: feh final_mitogenome.annotation.png Close the image to return to the terminal. View the contigs_stats.tsv file. What is the total length of the assembled mitogenome? 16005 16568 16569 What is the number of genes on the assembled mitogenome? 36 37 38 8.4 Run MitoHifi on the organelle reference Of course when we ran Tiara in Chapter 7 it also identified the contig with the mitochondrial genome, but did not give us the annotation. We could instead run MitoHiFi using the same command but with the identified contig as the reference assembly. Make a new directory and enter it: mkdir mito_tiara cd mito_tiara Copy across the mitochondrial contig identified in Chapter 7: cp ~/eukaryote_assembly/3-assessment/plastid_ERR7979900_hifiasm.bp.p_ctg.fa . Run MitoHifi: python /pub14/tea/nsc206/git_installs/MitoHiFi/mitohifi.py \\ -c plastid_ERR7979900_hifiasm.bp.p_ctg.fa \\ -f ../NC_029233.1.fasta -g ../NC_029233.1.gb \\ -t 1 -o 5 Let's compare this to our original mitogenome. What is the total length of the assembled mitogenome? 16005 16568 16569 What is the number of genes on the assembled mitogenome? 36 37 38 8.5 Summary The two approaches give us almost identical annotated mitogenomes. Therefore, if using tiara and it identifies a mitochondrial contig this is a good starting point to generate an annotated, circular mitochondrial reference. "],["09-Scaffolding.html", "Chapter 9 Scaffolding using HiC 9.1 Introduction 9.2 Set up 9.3 Map the Hi-C reads to the genome assembly 9.4 Visualise the scaffolding data in Juicer 9.5 Summary", " Chapter 9 Scaffolding using HiC 9.1 Introduction In the section on genome assessment, we separated the high-probability bacteria contigs from the eukarya contigs, and then ran purge_dups on the eukarya contigs. We were left with a very high contiguity nematode genome assembly. In this exercise we will use our best assembly from the previous step and paired Illumina Hi-C reads to scaffold the already very good assembly into chromosome sized scaffolds. 9.2 Set up Open a new terminal and load the Hi-C environment: . usehic Create a new directory, change into it, and link to the files we need: mkdir -p ~/eukaryote_assembly/5-scaffolding cd ~/eukaryote_assembly/5-scaffolding Link to the purged eukaryote-only contigs: ln -s ~/eukaryote_assembly/3-assessment/purge_dups/eukarya_ERR7979900_hifiasm.bp.p_ctg.fa_purged.fa Link to the paired Hi-C reads. The original files were downloaded from https://www.ebi.ac.uk/ena/browser/view/ERR5967937 but were very large and would have taken too long for this exercise, so we sampled the first 10 million reads: ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/test10m1.fq.gz ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/test10m2.fq.gz 9.3 Map the Hi-C reads to the genome assembly As in the previous steps, we're going to use BASH variables so that in future you can just copy the commands: REF=eukarya_ERR7979900_hifiasm.bp.p_ctg.fa_purged.fa FASTQ1=test10m1.fq.gz FASTQ2=test10m2.fq.gz PREFIX=purged10m CPU=16 MEM=100G Index the reference and map the reads. The bwa index command will take a minute or so to run. Make sure to wait for it to finish before entering the second and third commands: bwa index $REF samtools faidx $REF bwa mem -t $CPU $REF $FASTQ1 $FASTQ2 | \\ samtools view -b - &gt; $PREFIX.bam This will take a few minutes to run. When it's finished run the actual scaffolding step using YAHS (Yet Another Hi-C Scaffolder) yahs $REF $PREFIX.bam -o $PREFIX 9.4 Visualise the scaffolding data in Juicer Juicer and Juicebox are tools that allow you to visualise scaffolds and manipulate them. These yahs scripts create a file ready for juicer: juicer pre ${PREFIX}.bin ${PREFIX}_scaffolds_final.agp $REF.fai | \\ sort -k2,2d -k6,6d --parallel=$CPU -S$MEM | \\ awk &#39;NF&#39; &gt; \\ ${PREFIX}_alignments_sorted.txt samtools faidx ${PREFIX}_scaffolds_final.fa | cut -f1,2 &gt; \\ ${PREFIX}_scaffolds_final.fa_chromosome_sizes.txt Now run juicer_tools to create a file that can be seen in Juicebox: java -jar -Xmx$MEM /pub14/tea/nsc206/jars/juicebox/juicer_tools_2.15.08.jar \\ pre --threads $CPU \\ ${PREFIX}_alignments_sorted.txt \\ ${PREFIX}.hic \\ ${PREFIX}_scaffolds_final.fa_chromosome_sizes.txt This step takes ~10 minutes to run. When it's finished launch juicebox: java -jar /pub14/tea/nsc206/jars/juicebox/juicebox_2.15.08.jar Go to the top menu File -&gt; Open, click on 'Local', navigate to the your ~/eukaryote_assembly/5-scaffolding directory and load purged10m.hic You should see something that looks like this: This figure clearly shows that there are 6 major scaffolds, and we know that Oscheius onirici has 6 chromosomes. 9.5 Summary Not all examples will work as well as this. But with high quality PacBio Hifi data, and high quality Illumina Hi-C data - and tools like Hifiasm and YAHS, we can often get a reference quality chromosomal level assembly. "],["10-Optional_exercises.html", "Chapter 10 Optional Exercises 10.1 Introduction 10.2 Preassembly 10.3 Assembly 10.4 Assessment 10.5 Mitochondrial Assembly 10.6 Scaffolding", " Chapter 10 Optional Exercises 10.1 Introduction Here is another PacBio Hifi + Illumina Hi-C dataset for you to practice on. This is a fungus, a type of budding yeast called Metschnikowia zobellii Follow all the steps from pre-assembly through to scaffolding and see if the same steps work here or if you need to do anything different. Hint: We recommend subsampling the Pacbio Hifi read set to 10 percent of the raw data, and we have already subsampled the Illumina data to 1M read pairs so that this exercise will run in a reasonable amount of time in this course. In reality you would run the whole dataset. 10.2 Preassembly Make sure you are in the . useassembly terminal window. READACC=ERR9588941 mkdir -p ~/$READACC/1-preassembly cd ~/$READACC/1-preassembly # link to the raw data files: ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR9588941.fastq.gz ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR9503460.1m.1.fq.gz ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR9503460.1m.2.fq.gz seqkit stats $READACC.fastq.gz kmc -cs2000 -k21 ${READACC}.fastq.gz ${READACC}k21 . kmc_tools transform ${READACC}k21 histogram ${READACC}k21.histo # upload the .histo file in http://qb.cshl.edu/genomescope/genomescope2.0/ How many reads are in the ERR9588941.fastq.gz file? 61 121,002 1,411,251,333 What is the average length of the reads are in the ERR9588941.fastq.gz file? 61 11,663 29,884 What is the estimated genome size in GenomeScope? 21 Mb 14.35 Mb 13.18 Mb How does this compare to the known size of the assembly for Metschnikowia zobellii? (You can look this up on NCBI!) 10.3 Assembly mkdir -p ~/$READACC/2-assembly cd ~/$READACC/2-assembly seqtk sample ../1-preassembly/${READACC}.fastq.gz 0.10 | gzip -c &gt; ${READACC}.10p.fastq.gz hifiasm -l 0 -t 16 -o ${READACC}_hifiasm10pl0 ${READACC}.10p.fastq.gz # should take ~2 min # you can also try -l 3 and see the difference, remember to change the -o as well # take care with the file names. Here we have added the suffix `hifiasm` for the assembler, `10p` to indicate that we have used 10% of the data and `l0` to indicate we have set the `l` (lower case letter l) paramter to `0`. awk &#39;/^S/{print &quot;&gt;&quot;$2;print $3}&#39; ${READACC}_hifiasm10pl0.bp.p_ctg.gfa &gt; ${READACC}_hifiasm10pl0.bp.p_ctg.fa 10.4 Assessment mkdir -p ~/$READACC/3-assessment cd ~/$READACC/3-assessment ln -s ../2-assembly/${READACC}_hifiasm10pl0.bp.p_ctg.fa seqkit stats -a *.fa Move into your . usetiara terminal window. READACC=ERR9588941 cd ~/$READACC/3-assessment ASSEMBLY=${READACC}_hifiasm10pl0.bp.p_ctg.fa tiara -i $ASSEMBLY -o $ASSEMBLY.tiara -t 16 --pr --tf all Move back into your . useassembly window. ASSEMBLY=${READACC}_hifiasm10pl0.bp.p_ctg.fa seqkit stats -a *$ASSEMBLY # note large number of contigs busco \\ -i ${ASSEMBLY} \\ -l saccharomycetes_odb10 \\ -m geno \\ -o ${ASSEMBLY}_saccharomycetes_odb10 \\ --cpu 16 How many contigs are in the ERR9588941_hifiasml0pl0.bp.p_ctg.fa assembly? 1 236 238 What is the N50 of the ERR9588941_hifiasml0pl0.bp.p_ctg.fa assembly? 149 Kb 104 Kb 14 Kb What is the percentage of complete and single-copy BUSCOs found? 96.6% 32.8% 63.8% # purge_dups # no bacteria to remove, so keep them all ln -s ../1-preassembly/${READACC}.fastq.gz READS=${READACC}.fastq.gz CONTIGS=$ASSEMBLY CPU=16 minimap2 -t $CPU -x map-hifi $CONTIGS $READS | gzip -c - &gt;${CONTIGS}.paf.gz pbcstat ${CONTIGS}.paf.gz calcuts PB.stat &gt; ${CONTIGS}_cutoffs 2&gt; ${CONTIGS}_calcults.log split_fa $CONTIGS &gt;${CONTIGS}.split minimap2 -t $CPU -xasm5 -DP ${CONTIGS}.split ${CONTIGS}.split | gzip -c - &gt;${CONTIGS}.split.self.paf.gz purge_dups -2 -T ${CONTIGS}_cutoffs -c PB.base.cov ${CONTIGS}.split.self.paf.gz &gt;${CONTIGS}_dups.bed 2&gt;${CONTIGS}_purge_dups.log get_seqs -e ${CONTIGS}_dups.bed $CONTIGS mv purged.fa ${CONTIGS}_purged.fa mv hap.fa ${CONTIGS}_hap.fa seqkit stats ${CONTIGS} ${CONTIGS}_purged.fa ${CONTIGS}_hap.fa # this time a lot more sequence got purged, as this was a more heterozygous assembly, as we saw in genomescope How many contigs are in the ERR9588941_hifiasml0pl0.bp.p_ctg.fa_purged.fa assembly? 103 175 238 What is the size of the ERR9588941_hifiasml0pl0.bp.p_ctg.fa_purged.fa assembly? 23.9 Mb 13.6 Mb 10.3 Mb 10.5 Mitochondrial Assembly Use the identified mitochondrial contig from the tiara assessment. First move into your . usemitohifi terminal window. READACC=ERR9588941 mkdir -p ~/$READACC/4-mito cd ~/$READACC/4-mito cp ~/$READACC/3-assessment/mitochondrion_ERR9588941_hifiasm10pl0.bp.p_ctg.fa . # Find closely related mitogenome python /pub14/tea/nsc206/git_installs/MitoHiFi/findMitoReference.py \\ --species &quot;Metschnikowia zobellii&quot; \\ --outfolder ./ \\ --min_length 16000 # Run MitoHiFi python /pub14/tea/nsc206/git_installs/MitoHiFi/mitohifi.py \\ -c mitochondrion_ERR9588941_hifiasm10pl0.bp.p_ctg.fa \\ -f NC_057617.1.fasta -g NC_057617.1.gb \\ -t 1 -o 3 # Note we have used a different mitochondrial genetic code - check this on the NCBI taxonomy page for the study species. feh final_mitogenome.annotation.png What is the size of the final mitogenome? 16 Kb 51 Kb 97 Kb How many genes are there? 39 40 41 Yeast can have mitochondrial genomes up to 100 Kb. 10.6 Scaffolding Move into your . usehic terminal window. READACC=ERR9588941 mkdir -p ~/$READACC/5-scaffolding cd ~/$READACC/5-scaffolding ln -s ../3-assessment/${READACC}_hifiasm10pl0.bp.p_ctg.fa_purged.fa ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR9503460.1m.1.fq.gz ln -s /pub14/tea/nsc206/NEOF/Euk_assembly/data/ERR9503460.1m.2.fq.gz REF=${READACC}_hifiasm10pl0.bp.p_ctg.fa_purged.fa FASTQ1=ERR9503460.1m.1.fq.gz FASTQ2=ERR9503460.1m.2.fq.gz PREFIX=purged1m CPU=16 MEM=100G bwa index $REF samtools faidx $REF bwa mem -t $CPU $REF $FASTQ1 $FASTQ2 | samtools view -b - &gt; $PREFIX.bam yahs $REF $PREFIX.bam -o $PREFIX juicer pre ${PREFIX}.bin ${PREFIX}_scaffolds_final.agp $REF.fai \\ | sort -k2,2d -k6,6d --parallel=$CPU -S$MEM \\ | awk &#39;NF&#39; \\ &gt; ${PREFIX}_alignments_sorted.txt samtools faidx ${PREFIX}_scaffolds_final.fa | cut -f1,2 &gt; \\ ${PREFIX}_scaffolds_final.fa_chromosome_sizes.txt java -jar -Xmx$MEM /pub14/tea/nsc206/jars/juicebox/juicer_tools_2.15.08.jar pre --threads $CPU ${PREFIX}_alignments_sorted.txt ${PREFIX}.hic ${PREFIX}_scaffolds_final.fa_chromosome_sizes.txt java -jar /pub14/tea/nsc206/jars/juicebox/juicebox_2.15.08.jar You should see something that looks like this: "],["11-Conclusion.html", "Chapter 11 Conclusion", " Chapter 11 Conclusion We have produced a chromosome-level genome assembly for the nematode Oscheius onirici from raw PacBio HiFi and Illumina Hi-C sequencing reads, and also an annotated mitochondrial genome which we were able to identify and extract from the assembly. This example data showed high levels of homozygosity which led to the primary assembly contigs matching closely the expected genome size, a high BUSCO score with few duplications and it not being necessary to purge duplicate contigs. In contrast, the yeast Metschnikowia zobellii data was more heterozygous, as observed with the double peak in the GenomeScope k-mer plot. In this case the assembly was larger than the expected genome size and a high proportion of BUSCOs were duplicated, but running purge_dups rectified this. In conclusion, it is important to assess your data and results both pre- and post-assembly to ensure that you follow the correct path for the characteristics of the genome of your study species. "]]
