[["01-Supplemental.html", "RNA-seq gene expression and pathway analysis - supplemental material Chapter 1 Introduction Table of contents", " RNA-seq gene expression and pathway analysis - supplemental material Katy Maher, Helen Hipperson, Steve Paterson, Bert Overduin, Matthew Gemmell, Xuan Liu 2024-06-27 Chapter 1 Introduction This bookdown is supplemental to the main one. It contains some additional code and examples of tools that may prove useful in addition to the core RNA-Seq pipeline. Ensure you have the rnaseq environment activated for using all of these materials. As a reminder, the command to do this is: . usernaseq Table of contents Making a count table from HTSeq output Further analysis with DESeq2 Processing multiple samples using loops Gene Co-expression Network Analysis with WGCNA This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-Count_table.html", "Chapter 2 Making a count table from HTSeq output files", " Chapter 2 Making a count table from HTSeq output files Many of the software packages used for the analysis of RNA-Seq datasets will accept a table of count data. We can make such a table from our individual htseq-count outputs with a few lines of simple code in R. Open a new Jupyter notebook and name it \"Suppl02-Count_table\". We will first set the working directory to the location where the htseq files are located. setwd(&quot;~/rnaseq/Practical_one/htseq&quot;) Next we will create a list of htseq file names from the files located in this directory by using the list.files function to list files with the extension .htseq. files &lt;- list.files(pattern=&quot;*genecount.htseq&quot;) To create the count table we will first create a blank object in R we will call counts. This will be used to store the data from the htseq data we will read in. After this we can use a loop which will read in the first htseq file from the list we made. It will then add the second column of this file (which contains the count data) to the counts object and then rename the row names using the gene names found in the htseq file in first column. The loop will then restart, this time using the second file in the list and add the data from this file, and so on. counts &lt;- c() # create blank object called counts for( i in 1:length(files)){ # loop through the &#39;files&#39; list x &lt;- read.table(file=files[i], sep=&quot;\\t&quot;, header=F) # read in the htseq file counts &lt;- cbind(counts, x[,2]) # add second column of htseq file to &#39;counts&#39; rownames(counts) &lt;- x[,1] # name the row names as gene names taken from the first htseq column } To look at the start of the data frame we have created type head(counts) As you can see we now have a data frame where the row names are labelled with the Gene IDs and each column has the count data from a sample. However, we are missing the sample names for each column. We will add them using the following command, which will set the column names based on the input file names but removing the end of the file name (so we only keep the sample name). colnames(counts) &lt;- sub(&quot;_genecount.htseq&quot;,&quot;&quot;,files) head(counts) Everything is now looking as we expect. However, HTSeq-Count adds extra information to the end of the output files which we do not want to include in our final table. tail(counts) We will remove the last 5 rows from our data frame. counts&lt;-head(counts, -5) tail(counts) We can now write this to a csv file by typing write.csv(counts, &quot;htseq_table_of_gene_counts.csv&quot;) You can now close and halt your notebook. "],["03-Further_DESeq2.html", "Chapter 3 Further analysis with DESeq2 3.1 Control for sex of fly 3.2 Fit with multiple groups", " Chapter 3 Further analysis with DESeq2 3.1 Control for sex of fly Here we will briefly cover a couple of slightly more complex models and how you would code them and extract the results. In our first model we looked at a single term (sex). For the second model, we may be primarily interested in the selection regime of the lines of flies. But, given that there are big differences due to sex of fly, we might want to control for this. We can fit a model of the form expression = sex + regime. Make sure you are in the 'Practical_two' directory, have the 'usernaseq' environment activated, open a new Jupyter notebook called \"Suppl03-Further_DESeq2\" and read in the count data and the meta data for the experiment into a new code cell. library(&quot;DESeq2&quot;) counts&lt;-read.table(&quot;genecount.set1.tsv&quot;, header=T, row.names = 1) coldata&lt;-read.table(&quot;design.set1.tsv&quot;, header=T, row.names = 1) # Make sure the metadata columns sex and regime are read as factors coldata$sex &lt;- factor(coldata$sex) coldata$regime &lt;- factor(coldata$regime) We can now create the DESeq data set for the additive model. As the variable of interest in this case is the \"regime\", we put it at the end of the formula and control for the factor \"sex\". dds2 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ sex + regime) As before remove lowly expressed genes and run the differential expression analysis. keep &lt;- rowSums(counts(dds2)) &gt;= 10 dds2&lt;- dds2[keep,] dds2 &lt;- DESeq(dds2) We are now ready to extract our results from the analysis we have run. First we will compare the evolved (monogamous) regime against the baseline population (the order that we specify the contrast here is important, with B being the reference). resEB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;E&quot;, &quot;B&quot;)) head(resEB) summary(resEB) Positive fold changes in gene expression in our results mean that expression was higher for these genes in the evolved line compared to the baseline. We can do the same again but compare the multiply mated regime against the baseline: resMB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;M&quot;,&quot;B&quot;)) head(resMB) summary(resMB) 3.2 Fit with multiple groups The last model we will show is how to fit a model with multiple groups. In the fly example here, it might be the case that a gene is differentially expressed between regimes M and E, but only in one sex of fly. This is an experiment on sexual selection, so it's reasonable that selection might act on different genes in the males and the females. Interaction terms can be added to the design formula, but it can be much simpler to combine the factors of interest into a single factor with all combinations of the original factors. We can then change the design formula to include just this factor. We have done this for the \"group\" factor in our metadata. For example, BFCH is a female fly from regime B and we can compare the other all other groups (e.g. male-B, female-E, male-E, female-M &amp; male-M) against each other. # Make sure the metadata column group is set up as a factor coldata$group &lt;- factor(coldata$group) # Set the new model dds3 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ group) Filter and run the analysis as before. keep &lt;- rowSums(counts(dds3)) &gt;= 10 dds3&lt;- dds3[keep,] dds3 &lt;- DESeq(dds3) We can now extract the results of interest as we did in the previous example. Let's look at the regime M vs E contrast, first in females: resMFvsEF&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MFCH&quot;, &quot;EFCH&quot;)) head(resMFvsEF) summary(resMFvsEF) In this case positive expression changes mean that gene expression was higher in multiply mated females compared to evolved (monogamous) females. And then in males: resMMvsEM&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MMCH&quot;, &quot;EMCH&quot;)) head(resMMvsEM) summary(resMMvsEM) For more information on model design and set up see the DESeq2 vignette. "],["04-Multiple_samples_loops.html", "Chapter 4 Using loops to process multiple samples 4.1 Simple loop example 4.2 Trimmomatic loop example", " Chapter 4 Using loops to process multiple samples In our main workflow we learnt how to run through our RNA-seq analysis pipeline with a single sample up until the differential gene expression step, where we provided you with an example data set containing multiple samples. You may be wondering how you would run these initial steps when you have many samples. Ideally you don't want to have to run the same command multiple times - this is a recipe for typos and errors creeping into your code as well as being tedious and time consuming. One approach to get around this is to run a loop which will cycle through each of your samples running the task you specify. Put simply the syntax for a for loop is as follows: for &lt;variable name&gt; in &lt;a list of items&gt;; do &lt;run a command&gt; $&lt;variable name&gt;; done The &lt;variable name&gt; is the name of the variable you will use in the do part of your loop. It contains the item in your list the loop is currently using at that point. I.e. in the simple loop example (below) we call this variable f but you could use any name as long as you use it consistently in your do section. The &lt;a list of items&gt; is anything that returns a list of items, e.g. a list of files in our case. 4.1 Simple loop example Below is an example of a loop, which can be adjusted for your samples and the software you are running. This simplified loop will clearly demonstrate what the first part of the code is doing. Make sure you are in the directory rnaseq/Practical_one and in a terminal window (not in Jupyter). #The following will loop through all files ending _R1.fq.gz for f in *_R1.fq.gz; #assign the file name &#39;${f}&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; do BASE=${f%_R1.fq.gz} #print ${f} to screen echo ${f} #print ${BASE} to screen echo ${BASE}; done By using echo to print the following variables to the console we can see: echo ${f}: prints the full filename. echo ${BASE}: prints just the start of the filename (minus the _R1.fq.gz extension as we specified in our code) The loop then repeats the commands on the next file in the list and will keep going until it has run through all files ending with _R1.fq.gz in the given directory. done specifies the end of the commands in the loop. All commands between do and done in your loop will be executed. In this case we only have two files but this would work with any number of files. This is a useful bit of code as it means we can keep the filename but change the ending/extension of the file in our loops. 4.2 Trimmomatic loop example Now we can write a loop to run trimmomatic starting with the code we used above as a base. #the following will loop through all files ending _R1.fq.gz for f in *_R1.fq.gz; #assign the file name &#39;$f&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; do BASE=${f%_R1.fq.gz} #call trimmomatic and specify parameters trimmomatic PE -threads 4 -phred33 \\ #specify input R1 extension ${BASE}_R1.fq.gz \\ #specify input R2 extension ${BASE}_R2.fq.gz \\ #specify directory and filename for output of paired R1 read trimmed/${BASE}_R1_out_paired.fastq \\ #specify directory and filename for output of unpaired R1 read trimmed/${BASE}_R1_out_unpaired.fastq \\ #specify directory and filename for output of paired R2 read trimmed/${BASE}_R2_out_paired.fastq \\ #specify directory and filename for output of unpaired R2 read trimmed/${BASE}_R2_out_unpaired.fastq \\ #further paramenters for trimmomatic ILLUMINACLIP:TruSeq3-PE.fa:2:30:12 SLIDINGWINDOW:4:30 MINLEN:80; #end of commands done You can then edit this code to run other software in a loop. For a nice basic intro to Linux loops please click here. "],["05-WGCNA.html", "Chapter 5 Gene Co-expression Network Analysis with WGCNA 5.1 Introduction to WGCNA 5.2 Set up 5.3 Checking hierarchical clustering 5.4 Network construction 5.5 Module detection 5.6 Module-treatment correlation 5.7 Network plots and hub genes", " Chapter 5 Gene Co-expression Network Analysis with WGCNA 5.1 Introduction to WGCNA Weighted Gene Co-Expression Network Analysis (WGCNA) is a statistical method for identifying groups (modules) of genes with correlated expression (co-expression) in microarray and RNA-seq data. Modular gene expression is summarised using the cocept of module eigengenes, and these values can be correlated with phenotypic traits or experimental treatments. Looking within modules can also reveal 'hub' genes that have a high number of intra-modular connections. The analysis in this chapter takes transformed count data from a DESeq2 dds object and uses the WGCNA R package to analyse similarity of gene expression among genes, group them into modules, and correlate them with phenotypic traits or experimental treatments. Detection of co-expression modules is aided by the flashClust package and the interactions of genes within modules is visualised by plotting network graphs with the igraph package. This tutorial is adapted from the original tutorial created by WGCNA authors Peter Langfelder and Steve Horvath. Although no longer hosted on the UCLA website, the tutorial is still available from Peter Langfelder's private repository. There are also several newer tutorials on the web here, here, and here, and in the last few years some new packages have appeared, including SimpleTidy_GeneCoEx and GWENA which perform similar analyses. This tutorial provides an introduction to WGCNA; additonal functions and capabilities are explored more fully in some of these other resources. 5.2 Set up Make sure you are in the ‘rnaseq/tmp’ directory, have the ‘usernaseq’ environment activated, open a new Jupyter notebook called “Suppl04-WGCNA”. In the first code chunk of the script we need to load a few packages to run these analyses: library(WGCNA) library(DESeq2) library(flashClust) library(igraph) library(repr) The first step is to import the data. We will use the same data that we used in the DESeq2 analysis. The files are preloaded in this directory. This time we are going to specify the variable of interest as treatment group. # read in counts and metadata counts &lt;- read.table(&quot;genecount.set1.tsv&quot;, header=TRUE, row.names=1) coldata &lt;- read.table(&quot;design.set1.tsv&quot;, header=TRUE, row.names=1) # factorise metadata coldata$group &lt;- factor(coldata$group) As before we are going to create a dds object and run the DESeq function, but with group in the design. This time we will filter out genes with less than 100 reads across all samples. This is partly in the interests of time - the analysis will run quicker with a smaller dataset - but as with DESeq, it is often useful to remove genes that are relatively uncommon. # create the deseq object dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design = ~ group) # remove genes with less than or equal to 100 reads across all samples keep &lt;- rowSums(counts(dds)) &gt;= 100 dds &lt;- dds[keep,] # Run DESeq dds &lt;- DESeq(dds) Now that we have run DESeq, we will carry out a transformation of the count data, extract the counts and reformat them for input into WGCNA. The variance stabilisation transformation, or VST, is useful to apply for RNA-seq datasets. Many statistical techniques assume variance is not dependent on the mean, but in RNA-seq, variance does often increase with the mean. VST helps to reduce this dependence. # transform data for use in WGCNA t_dds &lt;- vst(dds, blind = FALSE) # export normalised counts a_dds &lt;- assay(t_dds) # transpose data frame (swap rows for columns) ncount &lt;- t(a_dds) 5.3 Checking hierarchical clustering Before proceeding with the network construction, we are going to check how well expression in our samples relates to our treatment groups, and make sure that there are no outliers with vastly different expression. To begin with we need to reformat our metadata slightly. Our treatment data is categorical, but WGCNA generally prefers the metadata in a binary format. Fortunately, this is easily achieved with a helper function within WGCNA. # create binary variables for group bgroup &lt;- binarizeCategoricalVariable(coldata$group, includePairwise = FALSE, includeLevelVsAll = TRUE) # give the new metadata the same names as the previous metadata rownames(bgroup) &lt;- rownames(coldata) # makes sure the metadata and counts data are in the same order meta &lt;- bgroup[rownames(ncount),] Now we will cluster our samples based on their expression using the flashClust function. We can then plot that with our treatment information underneath. This will reveal whether we have any outlying samples, and how well the replicates group together. # Cluster samples based on the gene count data sampleTree2 &lt;- flashClust(dist(ncount), method = &quot;average&quot;) # Convert traits to a color representation: white means 0, red means 1 traitColors &lt;- numbers2colors(meta) # Plot the sample dendrogram and the colors underneath. plotDendroAndColors(sampleTree2, traitColors, groupLabels = colnames(meta)) As we can see, there are no outliers in the data set which is good! The replicates cluster together for some of our treatment groups, although for others the clustering is less clear. Which treatment group shows the strongest clustering of replicate samples (ignoring difference between the sexes)? B - Baseline E - Evolved monogamy M - Multiple mates However, the fact that the replicates do not cluster together may not be that unusual in a comparison where the treatments are relatively slight (we would expect to see stronger clustering when comparing different tissues or development stages for example). 5.4 Network construction The \"Weighted\" in Weighted Gene Co-expression Analysis refers to the fact that the connections between the nodes (genes) in our network are not simply present or absent (if they were, we would be carrying out Unweighted Gene Co-expression Analysis). Instead there are many interactions that have varying strengths, or weights. Determining the weights is the clever bit of WGCNA. Without going into too much detail, the network analysis will assign a connection weight to each gene pair in our data set that is based on the similarity of their expression. Raising the co-expression similarity between gene pairs to the power of an exponent (the \"soft threshold\") enables the topology of our network (the arrangement of nodes and connections) to approximate that of a scale-free network, i.e. one where most nodes have few connections but some nodes have many connections and act as hubs which is what we would expect in a gene expression network. In order to decide what power we want to use as our soft threshold, we can analyse the network topology at various exponents and see how well it fits a scale-free topology model. The creators of WGCNA suggest to ideally choose a soft threshold at the lowest power for which scale-free topology fit reaches 0.9, although using a slightly lower fit (0.8) is also valid if the values do not reach 0.9. # Call the network topology analysis function sft &lt;- pickSoftThreshold(ncount, powerVector = c(1:16), verbose = 5) # Change some graphical parameters par(mfrow=c(1,1)) # create the plot of scale-free topology fit index as a function of the soft-thresholding power plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab=&quot;Soft Threshold (power)&quot;, ylab=&quot;SFT Model Fit, R2&quot;, type=&quot;n&quot;) + text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=c(1:16),col=&quot;red&quot;) # plot line corresponding to R^2 cut-off of h abline(h=0.9,col=&quot;blue&quot;) As we can see, the topology of our network approaches a scale-free topology fit of 0.9 at around 6, so we will use this as our soft power. The next steps will: 1) Apply the chosen soft thresholding power to calculate the adjacency of gene pairs, i.e. how close every gene is to every other gene, 2) Calculate the Topological Overlap Matrix (TOM). Nodes which overlap many other nodes have high connectivity or centrality and are assigned high TOM scores, 3) Calculate the dissimilarity in TOM, which will allow us to identify discrete modules of distinct gene expression. Running the following code chunk may take a minute or two. While it is running, the book icon in the firefox tab for the jupyter notebook will be replaced by a sand timer. When it has finished running you should see the following message: # select our soft power value softPower &lt;- 6 # calculate network adjacency adjacency &lt;- adjacency(ncount, power = softPower) # turn adjacency into topological overlap matrix (TOM) TOM &lt;- TOMsimilarity(adjacency) # we use the dissimilarity (1-overlap) for module detection dissTOM &lt;- 1-TOM # remove the adjacency object, which we no longer need rm(adjacency) 5.5 Module detection Now that we have our weighted gene co-expression network for all genes, we can look at connectivity by splitting groups of highly connecting genes into co-expression modules. This couples a hierarchical clustering approach with the TOM dissimilarity we calculated in the last step. We also have to specify a minimum module size. The creators of WGCNA recommend a minimum module size of 30. Here we are going to use 50, but with your own data you may want to experiment with different minimum sizes (&gt;30). # cluster genes based on TOM dissimilarity geneTree &lt;- flashClust(as.dist(dissTOM), method = &quot;average&quot;) # set a minimum module size minModuleSize &lt;- 50 # module identification dynamicMods &lt;- cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = minModuleSize) # show modules table(dynamicMods) Excluding the '0', how many modules have been detected by the hierarchical clustering? 15 24 31 You should be able to see that the modules contain between 74 and 1697 genes. The number of modules depends on the dataset - because the differences between treatments in this experiment are fairly subtle, it is likely to have a relatively high number of modules, while an experiment with greater differences between treatments may have fewer but more distinct modules. We can assess module similarity by comparing the gene expression in each of the modules using module eignegenes (the first principal component of the expression matrix). But first, it's time to get colourful. Rather than using numbers to label modules, WGCNA uses colours. This is not only for aesthetic reasons, but makes it easier to keep a track of how different modules relate to one another and to treatments or phenotypes. # Give the modules colour name labels dynamicCols &lt;- labels2colors(dynamicMods) # show colourfully labelled modules table(dynamicCols) Note that the 0 module has been relabelled as \"grey\". This module contains all the genes that do not show sufficient similarity in gene expression to any other genes (and thus should not be considered in further analysis). Now that we have colourful module labels, we can create our module eigengenes and look at the similarity of expression between different modules. # Calculate eigengenes MEList &lt;- moduleEigengenes(ncount, colors = dynamicCols) MEs &lt;- MEList$eigengenes # Calculate dissimilarity of module eigengenes MEDiss &lt;- 1-cor(MEs, use = &quot;complete&quot;) # Cluster modules by eigengene similarity METree &lt;- flashClust(as.dist(MEDiss), method = &quot;average&quot;) # plot tree of modules plot(METree, main = &quot;Clustering of module eigengenes&quot;, sub= &quot;&quot;, xlab = &quot;&quot;) # Set a merge threshold MEDissThres = 0.25 # Plot the cut line into the dendrogram abline(h=MEDissThres) We can see that there are quite a few modules with fairly similar module eigengenes, such as the darkgrey and lightgreen, and the darkgreen and tan. We can merge these modules to reduce the overall number of modules in our network. # Call an automatic merging function merge &lt;- mergeCloseModules(ncount, dynamicCols, cutHeight = MEDissThres, verbose = 3) # new label for merged module colors mergedCols &lt;- merge$colors # new label for eigengenes of newly merged modules: mergedMEs &lt;- merge$newMEs # show colourfully labelled merged modules table(mergedCols) Finally we can look at our gene tree based on TOM dissimilarity together with the original modules of co-expression and the merged modules of co-expression. # Plot a dendrogram of gene TOM with modules before and after merging plotDendroAndColors(geneTree, cbind(dynamicCols, mergedCols), dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05) Compared to some data sets, that you may see, this does not cluster that clearly into discrete modules of gene co-expression, with many of the modules rather mixed together. Nonetheless, we can still see some well-defined blocks of colour at the bottom which highlight clear modules, such as the salmon coloured module on the left, the yellow and greenyellow coloured modules in the middle, and the blue coloured module on the right. In the next step we will see how they relate to our treatment groups. 5.6 Module-treatment correlation Now that we have our co-expression modules, we want to see how these relate to our treatments. To do this we are going to take the module eigengenes - the first principal component of an expression matrix for that module - and correlate these with our binary treatment variables for each of the groups. The first step requires us to calculate the correlations and their P-values and put them in a matrix. # Calculate correlations between module eigengenes and treatments moduleTraitCor &lt;- cor(mergedMEs, meta, use = &quot;p&quot;) # How many genes are in our dataset? nSamples &lt;- nrow(ncount) # Caluclate the P values for these correlations moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples) # combine correlations and P values into a matrix textMatrix &lt;- paste(signif(moduleTraitCor, 2), &quot;\\n(&quot;, signif(moduleTraitPvalue, 1), &quot;)&quot;, sep = &quot;&quot;) # update dimensions of testMatrix dim(textMatrix) &lt;- dim(moduleTraitCor) Now that we have the matrix we can plot our heatmap. We are going to alter some graphical parameters first so that the plot fits nicely into the window. # change some graphical parameters par(mar = c(5, 9, 4, 2)) par(mfrow = c(1,1)) options(repr.plot.width=7, repr.plot.height = 9) # plot the heatmap labeledHeatmap(Matrix = moduleTraitCor, xLabels = colnames(meta), yLabels = names(mergedMEs), ySymbols = names(mergedMEs), colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE) The heatmap shows that some of the module eigengenes have quite high correlations with our treatment groups. The best correlation is the blue module, which strongly positively correlates with the baseline male group (r = 0.75, p = 0.00002). However, we would probably be more interested in knowing the modules that correlate with the experimental treatment groups. What module eigengene shows the strongest correlation in any of the M (multiple matings) or E (Evolved monogamy) treatment groups? salmon greenyellow lightcyan One module that shows an interesting pattern of co-expression is the lightyellow module, which shows a negative correlation with the evolved monogamy male group (r = -0.51, p = 0.01), but also a positive correlation with the the multiple mated male group (r = 0.41, p = 0.04). We are going to use this module as an example for the final stage of this network analysis - plotting a network graph. 5.7 Network plots and hub genes WGCNA uses the concept of module membership (MM) to identify hub genes. Module membership is effectively the correlation between a given gene's gene expression profile and the module eigengene (a value between -1 and 1). High MM scores are close to -1 or 1, while low MM scores are close to 0. For each gene, the MM (and it's p value) are calculated for all the modules, but it will have the highest MM for the module to which it was assigned during the clustering analysis. Higher module membership is associated with intramodular connectivity, and thus can be used as a metric for identifying hub genes within a module. We are going to create a data frame of all MM scores and their p values for all genes and all modules, which we can query in the following steps. # names (colors) of the modules modNames &lt;- substring(names(MEs), 3) # Caluclate gene module membership and p value geneModMem &lt;- as.data.frame(cor(ncount, MEs, use = &quot;p&quot;)) MMPvalue &lt;- as.data.frame(corPvalueStudent(as.matrix(geneModMem), nSamples)) # Rename columns of these data frames names(geneModMem) &lt;- paste(&quot;MM&quot;, modNames, sep=&quot;&quot;) names(MMPvalue) &lt;- paste(&quot;p.MM&quot;, modNames, sep=&quot;&quot;) # merge data frames MMdata &lt;- data.frame(merge(x = geneModMem, y = MMPvalue, by = &quot;row.names&quot;), row.names = 1) Now we are going to specify the module that we are interested in, select the top n genes for that module according to their module membership scores, and then extract the TOM dissimilarity information for these genes, which can be used as an input for our network plot. # Select a module of interest modules &lt;- c(&quot;lightyellow&quot;) # Obtain the genes that are in that module inModuleCol &lt;- is.finite(match(mergedColors, modules)) modGenes &lt;- colnames(ncount)[inModuleCol] # how many genes are in the module? length(modGenes) # select module membership values for the module of interest modMMdata &lt;- MMdata[rownames(MMdata) %in% modGenes, c(paste(&quot;MM&quot;, modules, sep=&quot;&quot;),paste(&quot;p.MM&quot;, modules, sep=&quot;&quot;))] # How many genes do we want to include? 20 may be a a good number nnode &lt;- 20 # For our chosen module, select the top genes ordered by module membership. # Notice that we use &#39;abs&#39; to choose genes with high or low values #(module membership is scored between -1 and 1). topnode &lt;- modMMdata[order( -abs(modMMdata[,paste(&quot;MM&quot;, modules, sep=&quot;&quot;)]) ),][1:nnode,] # Select the TOM values for these genes topnodeGenes &lt;- rownames(topnode) inModuleGene &lt;- colnames(ncount) %in% topnodeGenes modTOM &lt;- TOM[inModuleGene, inModuleGene] dimnames(modTOM) &lt;- list(topnodeGenes, topnodeGenes) How many genes does the lightyellow module contain? 681 912 1337 Now we are going to visualise the connections between the nodes using the igraph package in R. In igraph nodes are referred to as vertices, and connections are referred to as edges. These terms are commonly used in network analysis and are synonymous. Although we have limited the network to only 20 genes, it is likely to retain a high number of edges (connections). To make it a little easier to interpret we can exclude some of the connections with low weights, as well as excluding nodes that are floating (those which have no connections after filtering by weight). Deciding the threshold for filtering is generally a case of trial and error, and will depend on how many genes you have selected to display and the topology of the module (e.g. does it have many hub genes or relatively few). In our case we are going to use a filter set to 0.1. # build the graph object net &lt;- graph_from_adjacency_matrix(modTOM, mode = &quot;upper&quot;, weighted = TRUE, diag = FALSE) # delete edges with a low weight ( &lt; 0.1) net &lt;- delete_edges(net, which(E(net)$weight &lt; 0.1)) # delete floating nodes net &lt;- delete_vertices(net, which(degree(net)==0)) # adjust graphics parameters options(repr.plot.width=6, repr.plot.height = 6) # plot the module network plot(net, vertex.size = 8, vertex.label.cex = 0.8, edge.color = &quot;grey85&quot;) This gives us a network plot of 20 fairly well connected genes. If some of the gene names overlap, try rerunning the the code. You can also view a larger version of the image by right clicking on the figure and selection \"Open image in new tab\". You can also dissociate the network by increasing the number for delete_edges (for example from 0.1 to 0.12). Now we have our network plot, the final steps of the analysis are to inspect the module membership information and identify which are the best candidates for hub genes, and to load some functional annotation information about these genes. The functional information here was obtained by submitting a list of gene symbols for Drosophila pseudoobscura to the Uniprot Knowledge Base. # read in uniprot annotations annot = read.table(&quot;updated_annot.tsv&quot;,sep = &quot;\\t&quot;,na.strings = &quot;NA&quot;, quote = &quot;&quot;, header = T) # create a data frame with annotation and module membership information hubs&lt;-merge(topnode, annot, by.x = 0, by.y = &quot;FBgn&quot;, all.x = TRUE) # display the top 10 genes by module membership head(hubs[order(-hubs[,paste(&quot;MM&quot;, modules, sep=&quot;&quot;)]),], n = 10) What is the protein name of the gene with the highest module membership score? NPC intracellular cholesterol transporter 1 Nicalin Adapter molecule Crk You will notice that the gene with the highest module membership score does not appear to sit at the centre of our network. Because we have limited ourselves to plotting only the top 20 genes, we are excluding a lot of information about genes in this module with more moderate MM scores. It is likely that the gene with the highest MM score is somewhat connected to a larger number of genes overall within the module, even if some of the other genes in the top 20 seem to be better connected among themselves. However, all these genes have very high scores, and could represent interesting candidates for further investigation. We can also plot the functional information directly onto the network graph with a small modification to our code. # Take the protein names that match the gene names in this module modProts &lt;- annot$Protein_names[match(modGenes, annot$FBgn)] # Update the modTOM object dimnames(modTOM) &lt;- list(modProts, modProts) Copy the 5 lines of code from #build the graph object up to and including #plot the module network and paste it into a new cell. When you run this code you'll see that it now displays the proteins names directly on the network graph. Unfortunately the names of our proteins are rather long, which makes the figure a little messy. However, if your annotations are shorter, then this can be a convenient way of displaying the functions of the hub genes in your network figures. The full list of genes within the module could also be exported for Gene Ontology enrichment analysis. When it comes to plotting network figures, igraph provides a nice first approach to visualise the results. Within R, the ggnet2 package provides options to fine tune their appearance. Output files from WGCNA can also be exported with the exportNetworkToCytoscape() function and visualised with Cytoscape software, an open-source desktop app that provides a greater level of control in plotting networks. Once you have done this you can close and halt your workbook. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
