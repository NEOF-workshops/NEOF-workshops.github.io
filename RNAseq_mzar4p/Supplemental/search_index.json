[["01-Supplemental.html", "RNA-seq gene expression and pathway analysis - supplemental material Chapter 1 Introduction", " RNA-seq gene expression and pathway analysis - supplemental material Katy Maher, Helen Hipperson, Steve Paterson, Bert Overduin, Matthew Gemmell, Xuan Liu 2023-05-30 Chapter 1 Introduction This bookdown is supplemental to the main one. It contains some additional code and examples of tools that may prove useful in addition to the core RNA-Seq pipeline. The sections in this supplement will cover: Introduction to R Making a count table from HTSeq output files Further analysis with DESeq2 Processing multiple samples using loops Ensure you have the rnaseq environment activated for using all of these materials. As a reminder, the command to do this is: . usernaseq This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-R_intro.html", "Chapter 2 Basic Introduction to R 2.1 Open a new Jupyter notebook 2.2 Your working directory 2.3 Packages 2.4 Functions 2.5 Assigning values to variables 2.6 A few useful commands and tips", " Chapter 2 Basic Introduction to R R is an open-source free language and environment which was designed for statistical computing and graphics. It is possible to install R on many UNIX platforms, Windows and MacOS. In addition to its base environment, that contains capabilities for data manipulation, calculation and graphical display, there are many packages (including DADA2) that can be installed and contain additional functions, data and code for analysing, manipulating and plotting different types of data. You do not need to understand all the code you will be running today but a basic foundation in R can be useful when you come to analysing your own data and running further analysis. Here are some useful links to get you started if you want to learn more about R after this course. Tutorial R Website Cran Website Rstudio Website If you are not familiar with R we have describe some of the common terminology and put a few hints to help you understand how to run a few basic R commands below. 2.1 Open a new Jupyter notebook First make sure you have launched Jupyter (type jupyter-notebook into the terminal whenre the (rnaseq) environment is loaded). Open a new notebook called called “Suppl01-R_into”. 2.2 Your working directory Your working directory is the folder you are currently working on on your computer. If you set this when you read in or write an output to a file R will automatically look for and save files in this directory. You can set your working directory by entering the following into a new code cell: setwd(&quot;/path/to/working_directory/&quot;) 2.3 Packages Packages contain additional functions, data and code for analysing, manipulating and plotting different types of data. Many common packages will be installed as default when you install R. Other more specialised packages, such as the DADA2 package, must be installed by the user. Packages found on The Comprehensive R Archive Network (CRAN) which is R’s central software repository can be installed easily using the following command. You do not need to run this command. install.packages(&quot;package_name&quot;) Every time you reload R you will need to load the packages you need if they are not one of the ones installed by default. To do this type (do not run this command): library(&quot;package_name&quot;) 2.4 Functions Functions are a set of commands that are organised to perform a specific task. There are a lot of functions that come pre-installed in packages in R and others can be installed as parts of packages. It is also possible for users to create their own functions. For example a specific function can be called like this, we will use the sum function: sum(1,2) # which sums 1+2 and prints 3 to the console window. And to write your own function you would type something like this: function_name &lt;- function(arg_1, arg_2, ...) { Function body } 2.5 Assigning values to variables A variable provides a means of accessing the data stored in Rs memory. Data can be assigned to a variable using either &lt;- or =. For example: x&lt;-sum(1,2) If you run this command and then type x into the R console 3 will be printed to the screen. You can then use this variable in another function and assign to another variable if desired: y&lt;-sum(x,x) y # y would be assigned the value 6 and be printed to the console When you have a large script containing many commands it is beneficial to give variables logical names which can help you remember what they contain and help you call them quickly when needed. 2.6 A few useful commands and tips rm(list=ls()) can be used to clear your environment when you start a new analysis. This will delete all the variables you have stored in Rs memory so be careful when you use this. The read.table() can be used to read in a file. R likes to work with simple formats such as .csv and .txt files. write.table() can be used to write a data frame or a matrix to a file. Just like linux, remember you can press the up arrow on your keyboard to list previous commands run in the current R session. To get the more information and help on the function you want to use you can call using ?_function.name_ e.g.: ?sum You can now close and halt your notebook. "],["03-Count_table.html", "Chapter 3 Making a count table from HTSeq output files", " Chapter 3 Making a count table from HTSeq output files Many of the software packages used for the analysis of RNA-Seq datasets will accept a table of count data. We can make such a table from our individual htseq-count outputs with a few lines of simple code in R. Open a new Jupyter notebook and name it “Suppl02-Count_table”. We will first set the working directory to the location where the htseq files are located. setwd(&quot;~/rnaseq/Practical_one/htseq&quot;) Next we will create a list of htseq file names from the files located in this directory by using the list.files function to list files with the extension .htseq. files &lt;- list.files(pattern=&quot;*genecount.htseq&quot;) To create the count table we will first create a blank object in R we will call counts. This will be used to store the data from the htseq data we will read in. After this we can use a loop which will read in the first htseq file from the list we made. It will then add the second column of this file (which contains the count data) to the counts object and then rename the row names using the gene names found in the htseq file in first column. The loop will then restart, this time using the second file in the list and add the data from this file, and so on. counts &lt;- c() # create blank object called counts for( i in 1:length(files)){ # loop through the &#39;files&#39; list x &lt;- read.table(file=files[i], sep=&quot;\\t&quot;, header=F) # read in the htseq file counts &lt;- cbind(counts, x[,2]) # add second column of htseq file to &#39;counts&#39; rownames(counts) &lt;- x[,1] # name the row names as gene names taken from the first htseq column } To look at the start of the data frame we have created type head(counts) As you can see we now have a data frame where the row names are labelled with the Gene IDs and each column has the count data from a sample. However, we are missing the sample names for each column. We will add them using the following command, which will set the column names based on the input file names but removing the end of the file name (so we only keep the sample name). colnames(counts) &lt;- sub(&quot;_genecount.htseq&quot;,&quot;&quot;,files) head(counts) Everything is now looking as we expect. However, HTSeq-Count adds extra information to the end of the output files which we do not want to include in our final table. tail(counts) We will remove the last 5 rows from our data frame. counts&lt;-head(counts, -5) tail(counts) We can now write this to a csv file by typing write.csv(counts, &quot;htseq_table_of_gene_counts.csv&quot;) You can now close and halt your notebook. "],["04-Further_DESeq2.html", "Chapter 4 Further analysis with DESeq2 4.1 Control for sex of fly 4.2 Fit with multiple groups", " Chapter 4 Further analysis with DESeq2 4.1 Control for sex of fly Here we will briefly cover a couple of slightly more complex models and how you would code them and extract the results. In our first model we looked at a single term (sex). For the second model, we may be primarily interested in the selection regime of the lines of flies. But, given that there are big differences due to sex of fly, we might want to control for this. We can fit a model of the form expression = sex + regime. Make sure you are in the ‘Practical_two’ directory, have the ‘usernaseq’ environment activated, open a new Jupyter notebook called “Suppl03-Further_DESeq2” and read in the count data and the meta data for the experiment into a new code cell. library(&quot;DESeq2&quot;) counts&lt;-read.table(&quot;genecount.set1.tsv&quot;, header=T, row.names = 1) coldata&lt;-read.table(&quot;design.set1.tsv&quot;, header=T, row.names = 1) # Make sure the metadata columns sex and regime are read as factors coldata$sex &lt;- factor(coldata$sex) coldata$regime &lt;- factor(coldata$regime) We can now create the DESeq data set for the additive model. As the variable of interest in this case is the “regime”, we put it at the end of the formula and control for the factor “sex”. dds2 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ sex + regime) As before remove lowly expressed genes and run the differential expression analysis. keep &lt;- rowSums(counts(dds2)) &gt;= 10 dds2&lt;- dds2[keep,] dds2 &lt;- DESeq(dds2) We are now ready to extract our results from the analysis we have run. First we will compare the evolved (monogamous) regime against the baseline population (the order that we specify the contrast here is important, with B being the reference). resEB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;E&quot;, &quot;B&quot;)) head(resEB) summary(resEB) Positive fold changes in gene expression in our results mean that expression was higher for these genes in the evolved line compared to the baseline. We can do the same again but compare the multiply mated regime against the baseline: resMB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;M&quot;,&quot;B&quot;)) head(resMB) summary(resMB) 4.2 Fit with multiple groups The last model we will show is how to fit a model with multiple groups. In the fly example here, it might be the case that a gene is differentially expressed between regimes M and E, but only in one sex of fly. This is an experiment on sexual selection, so it’s reasonable that selection might act on different genes in the males and the females. Interaction terms can be added to the design formula, but it can be much simpler to combine the factors of interest into a single factor with all combinations of the original factors. We can then change the design formula to include just this factor. We have done this for the “group” factor in our metadata. For example, BFCH is a female fly from regime B and we can compare the other all other groups (e.g. male-B, female-E, male-E, female-M &amp; male-M) against each other. # Make sure the metadata column group is set up as a factor coldata$group &lt;- factor(coldata$group) # Set the new model dds3 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ group) Filter and run the analysis as before. keep &lt;- rowSums(counts(dds3)) &gt;= 10 dds3&lt;- dds3[keep,] dds3 &lt;- DESeq(dds3) We can now extract the results of interest as we did in the previous example. Let’s look at the regime M vs E contrast, first in females: resMFvsEF&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MFCH&quot;, &quot;EFCH&quot;)) head(resMFvsEF) summary(resMFvsEF) In this case positive expression changes mean that gene expression was higher in multiply mated females compared to evolved (monogamous) females. And then in males: resMMvsEM&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MMCH&quot;, &quot;EMCH&quot;)) head(resMMvsEM) summary(resMMvsEM) For more information on model design and set up see the DESeq2 vignette. "],["05-Multiple_samples_loops.html", "Chapter 5 Using loops to process multiple samples", " Chapter 5 Using loops to process multiple samples In our main workflow we learnt how to run through our RNA-seq analysis pipeline with a single sample up until the differential gene expression step where we provided you with an example data set containing multiple samples. You may be wondering how you would run these initial steps when you have many samples. Ideally you don’t want to have to run the same command multiple times - this is a recipe for typos and errors creeping into your code as well as bing tedious and time consuming. One approach to get around this is to run a loop which will cycle thorough each of your samples running the task you specify. Put simply the syntax for a for loop is as follows: for &lt;variable name&gt; in &lt;a list of items&gt;; do &lt;run a command&gt; $&lt;variable name&gt; done The &lt;variable name&gt; is the name of the variable you will then use in the do part of your loop. It contains the item in your list you are on at that point in your loop. I.e. below we call this variable f but you could use any name as long as you use it consistently in your do section. The &lt;a list of items&gt; is anything that returns a list of items, e.g. a list of files in our case. Here is an example of a loop below, which can be adjusted accordingly for your samples and the software you are running but first we will specify a simplified loop so you can see clearly what the first part of the code is doing. Make sure you are in the directory rnaseq/Practical_one. for f in *_R1.fq.gz; #the following will loop through all files ending _R1.fq.gz do BASE=${f%_R1.fq.gz} #assign the file name &#39;$f&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; echo $f #print $f to screen echo ${FBASE} #print ${FBASE} to screen done By using echo to print the following variables to the console we can see that echo $f prints the full filename for the first file and then echo ${FBASE} prints just the start of the filename (minus the _R1.fq.gz extension as we specified in our code), the loop then repeats the commands on the next file in the list and will keep going until it has run through all files ending with _R1.fq.gz in the given directory. done specifies the end of the commands in the loop. All commands between do and done in your loop will be executed. In this case we only have two files but this would work with any number of files. This is a useful bit of code as it means we can keep the filename but change the ending/extension of the file in our loops. Now we can write a loop to run trimmomatic starting with the code we used above as a base. for f in *_R1.fq.gz; #the following will loop through all files ending _R1.fq.gz do BASE=${f%_R1.fq.gz} #assign the file name &#39;$f&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; trimmomatic PE -threads 4 -phred33 \\ #call trimmomatic and specify parameters ${BASE}_R1.fq.gz \\ #specify input R1 extension ${BASE}_R2.fq.gz \\ #specify input R2 extension trimmed/${BASE}_R1_out_paired.fastq \\ #specify directory and filename for output of paired R1 read trimmed/${BASE}_R1_out_unpaired.fastq \\ #specify directory and filename for output of unpaired R1 read trimmed/${BASE}_R2_out_paired.fastq \\ #specify directory and filename for output of paired R2 read trimmed/${BASE}_R2_out_unpaired.fastq \\ #specify directory and filename for output of unpaired R2 read ILLUMINACLIP:TruSeq3-PE-2.fa:2:30:12 SLIDINGWINDOW:4:30 MINLEN:80 #further paramenters for trimmomatic done #end of commands You can then edit this code to run other software in a loop. For a nice basic intro to Linux loops please click here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
