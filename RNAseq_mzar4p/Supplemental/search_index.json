[["01-Supplemental.html", "RNA-seq gene expression and pathway analysis - supplemental material Chapter 1 Introduction Table of contents", " RNA-seq gene expression and pathway analysis - supplemental material Katy Maher, Helen Hipperson, Steve Paterson, Bert Overduin, Matthew Gemmell, Xuan Liu 2024-06-10 Chapter 1 Introduction This bookdown is supplemental to the main one. It contains some additional code and examples of tools that may prove useful in addition to the core RNA-Seq pipeline. Ensure you have the rnaseq environment activated for using all of these materials. As a reminder, the command to do this is: . usernaseq Table of contents Making a count table from HTSeq output Further analysis with DESeq2 Processing multiple samples using loops This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-Count_table.html", "Chapter 2 Making a count table from HTSeq output files", " Chapter 2 Making a count table from HTSeq output files Many of the software packages used for the analysis of RNA-Seq datasets will accept a table of count data. We can make such a table from our individual htseq-count outputs with a few lines of simple code in R. Open a new Jupyter notebook and name it “Suppl02-Count_table”. We will first set the working directory to the location where the htseq files are located. setwd(&quot;~/rnaseq/Practical_one/htseq&quot;) Next we will create a list of htseq file names from the files located in this directory by using the list.files function to list files with the extension .htseq. files &lt;- list.files(pattern=&quot;*genecount.htseq&quot;) To create the count table we will first create a blank object in R we will call counts. This will be used to store the data from the htseq data we will read in. After this we can use a loop which will read in the first htseq file from the list we made. It will then add the second column of this file (which contains the count data) to the counts object and then rename the row names using the gene names found in the htseq file in first column. The loop will then restart, this time using the second file in the list and add the data from this file, and so on. counts &lt;- c() # create blank object called counts for( i in 1:length(files)){ # loop through the &#39;files&#39; list x &lt;- read.table(file=files[i], sep=&quot;\\t&quot;, header=F) # read in the htseq file counts &lt;- cbind(counts, x[,2]) # add second column of htseq file to &#39;counts&#39; rownames(counts) &lt;- x[,1] # name the row names as gene names taken from the first htseq column } To look at the start of the data frame we have created type head(counts) As you can see we now have a data frame where the row names are labelled with the Gene IDs and each column has the count data from a sample. However, we are missing the sample names for each column. We will add them using the following command, which will set the column names based on the input file names but removing the end of the file name (so we only keep the sample name). colnames(counts) &lt;- sub(&quot;_genecount.htseq&quot;,&quot;&quot;,files) head(counts) Everything is now looking as we expect. However, HTSeq-Count adds extra information to the end of the output files which we do not want to include in our final table. tail(counts) We will remove the last 5 rows from our data frame. counts&lt;-head(counts, -5) tail(counts) We can now write this to a csv file by typing write.csv(counts, &quot;htseq_table_of_gene_counts.csv&quot;) You can now close and halt your notebook. "],["03-Further_DESeq2.html", "Chapter 3 Further analysis with DESeq2 3.1 Control for sex of fly 3.2 Fit with multiple groups", " Chapter 3 Further analysis with DESeq2 3.1 Control for sex of fly Here we will briefly cover a couple of slightly more complex models and how you would code them and extract the results. In our first model we looked at a single term (sex). For the second model, we may be primarily interested in the selection regime of the lines of flies. But, given that there are big differences due to sex of fly, we might want to control for this. We can fit a model of the form expression = sex + regime. Make sure you are in the ‘Practical_two’ directory, have the ‘usernaseq’ environment activated, open a new Jupyter notebook called “Suppl03-Further_DESeq2” and read in the count data and the meta data for the experiment into a new code cell. library(&quot;DESeq2&quot;) counts&lt;-read.table(&quot;genecount.set1.tsv&quot;, header=T, row.names = 1) coldata&lt;-read.table(&quot;design.set1.tsv&quot;, header=T, row.names = 1) # Make sure the metadata columns sex and regime are read as factors coldata$sex &lt;- factor(coldata$sex) coldata$regime &lt;- factor(coldata$regime) We can now create the DESeq data set for the additive model. As the variable of interest in this case is the “regime”, we put it at the end of the formula and control for the factor “sex”. dds2 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ sex + regime) As before remove lowly expressed genes and run the differential expression analysis. keep &lt;- rowSums(counts(dds2)) &gt;= 10 dds2&lt;- dds2[keep,] dds2 &lt;- DESeq(dds2) We are now ready to extract our results from the analysis we have run. First we will compare the evolved (monogamous) regime against the baseline population (the order that we specify the contrast here is important, with B being the reference). resEB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;E&quot;, &quot;B&quot;)) head(resEB) summary(resEB) Positive fold changes in gene expression in our results mean that expression was higher for these genes in the evolved line compared to the baseline. We can do the same again but compare the multiply mated regime against the baseline: resMB&lt;-results(dds2, contrast=c(&quot;regime&quot;, &quot;M&quot;,&quot;B&quot;)) head(resMB) summary(resMB) 3.2 Fit with multiple groups The last model we will show is how to fit a model with multiple groups. In the fly example here, it might be the case that a gene is differentially expressed between regimes M and E, but only in one sex of fly. This is an experiment on sexual selection, so it’s reasonable that selection might act on different genes in the males and the females. Interaction terms can be added to the design formula, but it can be much simpler to combine the factors of interest into a single factor with all combinations of the original factors. We can then change the design formula to include just this factor. We have done this for the “group” factor in our metadata. For example, BFCH is a female fly from regime B and we can compare the other all other groups (e.g. male-B, female-E, male-E, female-M &amp; male-M) against each other. # Make sure the metadata column group is set up as a factor coldata$group &lt;- factor(coldata$group) # Set the new model dds3 &lt;- DESeqDataSetFromMatrix(countData = counts, colData = coldata, design= ~ group) Filter and run the analysis as before. keep &lt;- rowSums(counts(dds3)) &gt;= 10 dds3&lt;- dds3[keep,] dds3 &lt;- DESeq(dds3) We can now extract the results of interest as we did in the previous example. Let’s look at the regime M vs E contrast, first in females: resMFvsEF&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MFCH&quot;, &quot;EFCH&quot;)) head(resMFvsEF) summary(resMFvsEF) In this case positive expression changes mean that gene expression was higher in multiply mated females compared to evolved (monogamous) females. And then in males: resMMvsEM&lt;-results(dds3, contrast=c(&quot;group&quot;, &quot;MMCH&quot;, &quot;EMCH&quot;)) head(resMMvsEM) summary(resMMvsEM) For more information on model design and set up see the DESeq2 vignette. "],["04-Multiple_samples_loops.html", "Chapter 4 Using loops to process multiple samples 4.1 Simple loop example 4.2 Trimmomatic loop example", " Chapter 4 Using loops to process multiple samples In our main workflow we learnt how to run through our RNA-seq analysis pipeline with a single sample up until the differential gene expression step, where we provided you with an example data set containing multiple samples. You may be wondering how you would run these initial steps when you have many samples. Ideally you don’t want to have to run the same command multiple times - this is a recipe for typos and errors creeping into your code as well as being tedious and time consuming. One approach to get around this is to run a loop which will cycle through each of your samples running the task you specify. Put simply the syntax for a for loop is as follows: for &lt;variable name&gt; in &lt;a list of items&gt;; do &lt;run a command&gt; $&lt;variable name&gt;; done The &lt;variable name&gt; is the name of the variable you will use in the do part of your loop. It contains the item in your list the loop is currently using at that point. I.e. in the simple loop example (below) we call this variable f but you could use any name as long as you use it consistently in your do section. The &lt;a list of items&gt; is anything that returns a list of items, e.g. a list of files in our case. 4.1 Simple loop example Below is an example of a loop, which can be adjusted for your samples and the software you are running. This simplified loop will clearly demonstrate what the first part of the code is doing. Make sure you are in the directory rnaseq/Practical_one and in a terminal window (not in Jupyter). #The following will loop through all files ending _R1.fq.gz for f in *_R1.fq.gz; #assign the file name &#39;$f&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; do BASE=${f%_R1.fq.gz} #print $f to screen echo $f #print ${BASE} to screen echo ${BASE}; done By using echo to print the following variables to the console we can see: echo $f: prints the full filename. echo ${BASE}: prints just the start of the filename (minus the _R1.fq.gz extension as we specified in our code) The loop then repeats the commands on the next file in the list and will keep going until it has run through all files ending with _R1.fq.gz in the given directory. done specifies the end of the commands in the loop. All commands between do and done in your loop will be executed. In this case we only have two files but this would work with any number of files. This is a useful bit of code as it means we can keep the filename but change the ending/extension of the file in our loops. 4.2 Trimmomatic loop example Now we can write a loop to run trimmomatic starting with the code we used above as a base. #the following will loop through all files ending _R1.fq.gz for f in *_R1.fq.gz; #assign the file name &#39;$f&#39; to a variable called &#39;BASE&#39; but remove the extension &#39;_R1.fq.gz&#39; do BASE=${f%_R1.fq.gz} #call trimmomatic and specify parameters trimmomatic PE -threads 4 -phred33 \\ #specify input R1 extension ${BASE}_R1.fq.gz \\ #specify input R2 extension ${BASE}_R2.fq.gz \\ #specify directory and filename for output of paired R1 read trimmed/${BASE}_R1_out_paired.fastq \\ #specify directory and filename for output of unpaired R1 read trimmed/${BASE}_R1_out_unpaired.fastq \\ #specify directory and filename for output of paired R2 read trimmed/${BASE}_R2_out_paired.fastq \\ #specify directory and filename for output of unpaired R2 read trimmed/${BASE}_R2_out_unpaired.fastq \\ #further paramenters for trimmomatic ILLUMINACLIP:TruSeq3-PE-2.fa:2:30:12 SLIDINGWINDOW:4:30 MINLEN:80; #end of commands done You can then edit this code to run other software in a loop. For a nice basic intro to Linux loops please click here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
