[
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Overview",
    "section": "License",
    "text": "License\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "Linux/01-Linux_Introduction.html",
    "href": "Linux/01-Linux_Introduction.html",
    "title": "Linux",
    "section": "",
    "text": "Linux is a multitasking, multiuser Unix-like computer operating system (OS). Linux can run many different applications (multitasking) and it can be used by many different people (multiuser) on the same computer at the same time.\nIt is utilised by many programmers, including Bioinformaticians. It is a relatively easy OS to run commands and develop software for. The vast majority of programs and tools for computational analysis of biological data will work in Linux.\nThere are three parts of the Linux OS:\nIt is important to learn the Linux language so you can run commands on the command line. This is because:"
  },
  {
    "objectID": "Linux/01-Linux_Introduction.html#linux-or-unix",
    "href": "Linux/01-Linux_Introduction.html#linux-or-unix",
    "title": "Linux",
    "section": "Linux or Unix?",
    "text": "Linux or Unix?\nLinux and Unix are almost identical and are commonly used interchangeably. The main difference is that Linux is free and open source whilst Unix is not free and is closed source."
  },
  {
    "objectID": "Linux/02-Starting.html#linux-access",
    "href": "Linux/02-Starting.html#linux-access",
    "title": "Starting",
    "section": "Linux access",
    "text": "Linux access\nPrior to running through these materials you will need to have acces to a Linux terminal. The 2 main methods are a terminal on your own computer or connecting to remote a machine such as an HPC. Below are a variety of methods to gain this.\n\nComputer terminal\nDepending on the OS you are using there are differetn ways to access a temrinal.\n\nWindows\nWindows has a terminal but it is not Linux based. You can install a subsystem of Linux to use Linux on your windows machine. This is carried out with WSL(Windows Subsystem for Linux). The following is a link on how to install WSL: Windows install WSL\n\n\nLinux & macOS\nIf you are using a Linux or macOS machine you can use the terminal to carry out Linux commands. This is possible as macOS is a Unix-based system.\nIf you would like to install and use a Linux OS we recommend Linux Mint. The following link is a guide to install Mint Linux:\nMint Linux install\n\n\n\nRemote access\nFor remote access you can use a terminal to ssh to the remote machine.\nIf you are on a windows machine you may need to download a terminal program to ssh to a linux cluster. Below are a few suggestions of windows terminals:\n\nMobaXterm\nPutty\n\n\nssh\n\n\n\nThe ssh (Secure Shell Protocol) command is used to login into cluster and other machines. For more information on this please see the following online tutorial: ssh tutorial\n\n\nFile transferring\n\n\n\nWhen working with a remote cluster you will most likely want to transfer files from your computer to the cluster and vice versa.\nFor transferring on windows machine I would suggest WinSCP.\nFor transferring on macOS & Linux I would suggest FileZilla"
  },
  {
    "objectID": "Linux/02-Starting.html#the-terminal-window",
    "href": "Linux/02-Starting.html#the-terminal-window",
    "title": "Starting",
    "section": "The Terminal Window",
    "text": "The Terminal Window\nYour terminal may look similar to the below image. We are using the terminal window as our shell to interpret our commands to the kernel. Depending on your system and preferences it will most likely look different.\n\n\n\nAlready there is useful information for us on the terminal window.\n\nnsc206: This is the login name, also known as the username. In this case nsc206 is a demonstrator’s account. Your screen should show a different account name which will be your username for the Linux machine/cluster you are logged into.\nada02: This is the machine name the user is logged into.\n~: This represents the current directory of the user, or the directory a command was run in. In the Linux OS and others ‘~’ is a short cut to the user’s home directory.\nEverything after the ‘$’ is where commands are typed into the terminal. This is also referred to as the command line.\n\nTo open a new terminal window, right click on the main screen, choose Applications -&gt; Shell -&gt; bash"
  },
  {
    "objectID": "Linux/02-Starting.html#commands",
    "href": "Linux/02-Starting.html#commands",
    "title": "Starting",
    "section": "Commands",
    "text": "Commands\nCommands are typed into the terminal and then run by pressing “enter””\n\n\n\nTo run a command select your terminal by clicking on it or using “alt+shift”.\nNow run the below command:\n\necho \"Hello World\"\n\nIn this case echo is a command that prints out the term “Hello World”.\nNow try:\n\necho \"Bye World\"\n\nThere are many different Linux commands and we will run through a few. With a large variety it can be hard to remember all the commands and how they work.\nThree convenient resources are:\n\nSearch engines (e.g. Google): There are many forums where people ask for help with command line issues. If you have an issue and are not sure what to do, most likely someone else has had the same issue and asked for help on a forum. The tricky part of this is knowing the specific terminology to use when searching. Forums where people ask bioinformatics questions include SEQanswers, Stack overflow and biostars.\nCheat sheets: It is never wrong to “cheat” when coding. Cheat sheets with many commands and good descriptions are very useful. Here is a good example of one: https://files.fosswire.com/2007/08/fwunixref.pdf\nManual pages: Linux commands have many different parameters and options. If you ever need to figure out what they all are and what they do you can use the man command.\n\nE.g. The below command will show the manual page for the echo command:\n\nman echo\n\nThe below command will show the manual page for the man command:\n\nman man\n\nNote: The man page acts like using the command less (we will get into more specifics later). Important notes for now are to use the arrow keys to go up and down the page and press q to exit the manual\nNote: There is a cheat sheet at the end of this document with all the commands covered in this practical."
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html",
    "href": "Linux/03-Directories_and_Files.html",
    "title": "Directories and Files",
    "section": "",
    "text": "YouTube walk through video"
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html#acquiring-workshop-data",
    "href": "Linux/03-Directories_and_Files.html#acquiring-workshop-data",
    "title": "Directories and Files",
    "section": "Acquiring Workshop data",
    "text": "Acquiring Workshop data\nThe first step to download the data for the workshop to your home directory.\n\nChanging directories\nBefore downloading you will need to change the directory to your home directory.\n\ncd is the command to Change Directory. It is followed by the directory you want to change to.\n“~” represents your home directory.\n\nChange directory to your home directory by running the following command in your terminal:\n\ncd ~ \n\nIn Linux the default of cd is to change directory to your home directory. Therefore the following command will do the same as the above.\n\ncd\n\nTo determine your current working directory you can either look at the part of the terminal which displays it or you can use the command pwd (print working directory). Enter the following command:\n\npwd\n\nIn this case it will not show a “~” but the full path of your home directory. An example of a home directory is “/pub14/tea/nsc206/”.\n\nThe first “/” is the root of the system. Every directory, subdirectory, file and program of the machine is within the root.\n“pub14/”: A directory within the root.\n“tea/”: A subdirectory of “pub14/” and a sub-subdirectory of the root (“/”).\n“nsc206”: The home directory of user nsc206. It is a subdirectory of “tea/” which is a subdirectory of “pub14/” which is a subdirectory of the root (“/”).\n\n\n\nDownloading and unzip the data\nNow that you are in our home directory we can download the data we need. To download data the Linux/bash terminal we can use the wget command.\nRun the below to download the zipped directory Linux.zip.\n\nwget https://neof-workshops.github.io/BFX_resources/Linux.zip\n\nOptionally, you can manually download the file and move it into your home directory of the Linux based system you are using.\nCheck the file was downloaded to your current directory with ls. ls lists the contents of directories and we will go into more detail of it use later.\n\nls\n\nIf you see the file is listed you can then unzip the directory with the unzip command\n\nunzip Linux.zip\n\nNow change directory into the unzipped directory.\n\ncd Linux\n\nPrint to screen the path of your current working directory.\n\npwd\n\nAdditionally, it always good to list the contents of the current directory when you move directory.\n\nls"
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html#directory-structure",
    "href": "Linux/03-Directories_and_Files.html#directory-structure",
    "title": "Directories and Files",
    "section": "Directory structure",
    "text": "Directory structure\nYou can think of the directory structure in two different ways.\n\nThe Directory tree\nThis starts as the root (“/”) which branches out into directories and files. Directories contain files and subdirectories which contain files and subdirectories etc.\nBelow is an example of visualising the location of the “Linux” directory within the user ncs006’s home directory as a tree. This only includes a subset of directories.\n\n\n\n\n\nBoxes\nAnother analogy to the directory structure is boxes and items. In this case there is one large box that contains all the boxes and items, this is the root (“/”). In the root are items and boxes which hold items and boxes etc.\nBelow is an example of visualising the location of the “Linux” directory within the user ncs006’s home directory as boxes. This only includes a subset of directories."
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html#paths",
    "href": "Linux/03-Directories_and_Files.html#paths",
    "title": "Directories and Files",
    "section": "Paths",
    "text": "Paths\n\n\n\nOn the command line directories and files are referred to by paths e.g. “/pub14/tea/nsc206/Linux/” is a path.\nPaths are case sensitive. The path “directory/file.txt” is different than “diRectory/File.txt”.\nSpaces should always be avoided in path names. It is highly recommended to use “_” instead. This is because spaces are used to separate options and parameters in commands.\nThere are multiple ways to refer to a path. The two main ways are through absolute paths and relative paths.\n\nAbsolute paths\nAbsolute paths are paths that start from the root e.g.\n\n“/pub14/tea/nsc206/Linux/”\n“~/Linux/” (In this case ~ is a shortcut which includes the root)\n“/pub14/tea/nsc206/file.txt”\n\n\n\nRelative paths\nRelative paths are paths that are relative to another location besides the root e.g.\n\n“.” (This means the current working directory).\n“..” (This refers to one directory up e.g. if the current directory was “/pub14/tea/nsc206/”, the “..” directory would be “/pub14/tea/”).\n“1_directory/”, would refer to the directory “1_directory/” in your current directory\n\n\n\nChange directory examples\nBelow is a subset of valid methods to change directory into your “Linux/” directory\nNote: You will have different file paths in your machine so you will not be able to run the below commands.\nMethod 1\n\ncd /pub14/tea/nsc206/Linux/\n\nMethod 2\n\ncd ~\ncd Linux/\n\nMethod 3\n\ncd /pub14/tea/nsc206/Linux/1_directory/\ncd ..\n\nMethod 4\n\ncd /pub14/\ncd tea/\ncd nsc206/\ncd Linux/"
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html#listing-directory-content",
    "href": "Linux/03-Directories_and_Files.html#listing-directory-content",
    "title": "Directories and Files",
    "section": "Listing Directory content",
    "text": "Listing Directory content\n\n\n\nTo list the contents (files and directories) within a directory you can use the ls command.\nThe output of ls will include file names that are coloured black and directory names that are coloured blue in our VNC terminals.\nBefore carrying out the below commands make sure you are in your “Linux” directory with the pwd command.\nList the contents in your current directory:\n\nls\n\nList the contents in your home directory:\n\nls ..\n\nList the contents in the root directory and put each separate file/directory on a separate line. In the below command the -1 is a parameter that indicates there will be only 1 piece of content on each line. Note: -2, -3 etc are not parameters that work with ls.\n\nls -1 /\n\nReminder: you can use the man command to look at more options for commands.\nls is my most typed command. I am consistently using it to see what directories and files are in my current directory and other directories. I suggest you do the same."
  },
  {
    "objectID": "Linux/03-Directories_and_Files.html#mcqs-files-directories",
    "href": "Linux/03-Directories_and_Files.html#mcqs-files-directories",
    "title": "Directories and Files",
    "section": "MCQs: Files & Directories",
    "text": "MCQs: Files & Directories\n\n\n\nPlease attempt to answer the below Multiple-Choice Questions to reinforce what you have learnt in this chapter.\n\nWhat command lists the contents of directories?\n\n cp cd ls\n\n\n\nWhat command changes directory?\n\n cp cd ls\n\n\n\nChoose the option that represents the root directory.\n\n ~ / ..\n\n\n\nChoose the option that represents your home directory.\n\n ~ / ..\n\n\n\nChoose the option that represents one directory above.\n\n ~ / ..\n\n\n\nWhich path is an absolute path?\n\n ./Linux/ /pub14/tea/nsc206/Linux/\n\n\n\nWhich path is a relative path?\n\n ./Linux /pub14/tea/nsc206/Linux/"
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html",
    "href": "Linux/04-Tips_and_tricks.html",
    "title": "Tips and tricks",
    "section": "",
    "text": "YouTube walk through video"
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#tab-complete",
    "href": "Linux/04-Tips_and_tricks.html#tab-complete",
    "title": "Tips and tricks",
    "section": "Tab complete",
    "text": "Tab complete\nTab complete is a method to quickly type commands and file paths without error. In bioinformatics tab complete is your best friend. The tab key looks like:\n\n\n\nTab complete serves the following purposes:\n\nTo complete path names and commands\nTo list all content that starts with what you have already typed\nTo ensure you have no typos\n\nIn the below examples press the tab button when you see &lt;tab&gt; and replace 2xx with your user number.\nMove into the directory “1_directory”\n\ncd ~/Linu&lt;tab&gt;1_d&lt;tab&gt;\n\nPrint out all the content within the current directory that starts with “1_” in the file or directory name. This is carried out with a double tab.\nNote: the “./” is put before the 1 so it only looks in the current directory otherwise it will also look for commands.\n\n./1_&lt;tab&gt;&lt;tab&gt;\n\nList the contents of directory “1_1_directory”\n\nls 1_1&lt;tab&gt;\n\nChange directory to “1_2_directory”. The “./” is not needed before the file name as tab will only look for directories because it is used for an argument of the cd command.\n\ncd 1_2&lt;tab&gt;\n\nChange directory to example_1_part_1. The last tab will add the “/” to the end of the directory name, this informs you that you have correctly and fully typed in the directory name. However, this will not always occur if there is another directory name that starts the same but is longer. That is where double tab comes in handy.\n\ncd e&lt;tab&gt;1&lt;tab&gt;1&lt;tab&gt;\n\nIn this practical session I have given paths purposefully long names. This has been carried out to demonstrate the usefulness of tab complete and to encourage its use. Although they have been artificially extended in this case, in Bioinformatics long and informative path names are advised."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#ending-a-command",
    "href": "Linux/04-Tips_and_tricks.html#ending-a-command",
    "title": "Tips and tricks",
    "section": "Ending a command",
    "text": "Ending a command\nThere are times when you will want to abandon a command on the command line. To do this simple press ‘Ctrl’ + ‘c’.\nThis is useful if a command won’t respond or you noticed you have run a command with a typo or with the wrong file."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#history",
    "href": "Linux/04-Tips_and_tricks.html#history",
    "title": "Tips and tricks",
    "section": "History",
    "text": "History\n\n\n\nLinux will save commands you have previously entered. In the terminal, whilst at the command line, you can press the up and down keys to scroll through your history. You can then rerun previous commands or edit them with the left and right arrow keys, and run the edited version."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#clear",
    "href": "Linux/04-Tips_and_tricks.html#clear",
    "title": "Tips and tricks",
    "section": "Clear",
    "text": "Clear\nThe clear command can be used to clear all the text from the terminal. This is useful for keeping a tidy terminal."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#bash-escape",
    "href": "Linux/04-Tips_and_tricks.html#bash-escape",
    "title": "Tips and tricks",
    "section": "Bash escape",
    "text": "Bash escape\nTo continue a command on a new line on the command line use the backslash character, \\. When you press \\ followed by enter, the command will not run and you will be on a new line on the command line. This can be useful for clarity and for long commands. In the below example press “enter” after the end of a line.\nPrint to screen the term “Hello universe, today is a very nice day. Don’t you think so?”\n\necho \\\n“Hello universe, today is a very nice day. Don’t you think so?”\n\nNotice that there is a space before the \\. This is because there needs to be a space between the echo and text to print out. It is always recommended to use a space before a \\ to bash escape.\nBash escape is useful for this document as it will show if commands in this document are separate commands or one command over multiple lines."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#annotations",
    "href": "Linux/04-Tips_and_tricks.html#annotations",
    "title": "Tips and tricks",
    "section": "Annotations",
    "text": "Annotations\n\n\n\nYou can annotate your code so it will not run. This is carried out by putting a # at the start of a code line.\nAn example:\n\n#This line is annotation and will not run\n#The below line will print out the text \"this line is not annotated\"\necho \"this line is not annotated\"\n\nThis is useful to give yourself information about what your code is doing and it is vital if you are creating scripts. We will also use annotations in this workbook to explain what some lines of code are doing.\nI also find it useful to put a # at the front of a long command that I am typing or editing. This means the command won’t run if I accidentally press enter. Just be sure to remove the # at the start of the line before you want to run it."
  },
  {
    "objectID": "Linux/04-Tips_and_tricks.html#mcqs-tips-tricks",
    "href": "Linux/04-Tips_and_tricks.html#mcqs-tips-tricks",
    "title": "Tips and tricks",
    "section": "MCQs: Tips & tricks",
    "text": "MCQs: Tips & tricks\n\n\n\nPlease attempt to answer the below Multiple-Choice Questions to reinforce what you have learnt in this chapter.\n\nWhat allows you to auto fill paths and commands so you can quickly type without error?\n\n # Tab complete clear\n\n\n\nWhat command clears text from the terminal?\n\n # Tab complete clear\n\n\n\nWhat symbol is used for annotation?\n\n # Tab complete clear\n\n\n\nWhat keyboard short cut cancels/ends a command?\n\n Ctrl + c \\ Up and down arrow\n\n\n\nWhat keys scroll through your previously run commands (aka history)?\n\n Ctrl + c \\ Up and down arrows\n\n\n\nBash escape allows you to run commands over multiple lines. What symbol is used for bash escape?\n\n Ctrl + c \\ Up and down arrow"
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html",
    "href": "Linux/05-Manipulating_directories.html",
    "title": "Manipulating directories",
    "section": "",
    "text": "YouTube walk through video"
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html#make-a-directory",
    "href": "Linux/05-Manipulating_directories.html#make-a-directory",
    "title": "Manipulating directories",
    "section": "Make a directory",
    "text": "Make a directory\nTo make a directory the command mkdir is used.\nFor the below examples we will be making heavy use of ls so you can hopefully visualise the contents of the directories.\nType in the following commands to make a subdirectory within the “CGR_Linux” directory called “Chicken” then make a subdirectory within “Chicken” called “Egg”.\n\n#Change directory to CGR_linux in your home (~)\ncd ~/Linux/\n#Always good to list contents when you move into a directory\nls\n#Make a directory called Chicken in your current directory\nmkdir Chicken\n#Make a subdirectory of Chicken called Egg\nmkdir Chicken/Egg\n#List the contents of the Chicken directory\nls Chicken\n\nTip: You can use the up arrow key to get to previously run commands which you can edit using the right and left keys."
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html#moving-directories-and-files",
    "href": "Linux/05-Manipulating_directories.html#moving-directories-and-files",
    "title": "Manipulating directories",
    "section": "Moving Directories and Files",
    "text": "Moving Directories and Files\n\n\n\nFiles and directories can be moved with the mv command. This can also be used to change the name of a file or a directory.\nNote: If you move a file to the path of a file that already exists, the pre existing file will be overwritten.\nFirst ensure your working directory is the “Linux” directory.\nMove the “Chicken” directory into the “3_chicken_farm/3_1_hut/” directory. This will move the directory and all its contents.\n\n#Before moving list the contents of the the destination directory\nls 3_chicken_farm/3_1_hut/\n#Also list the contents of the current directory to ensure \n#Chicken is present\nls\n#Move Chicken to 3_chicken_farm/3_1_hut/\nmv Chicken/ 3_chicken_farm/3_1_hut/\n#List the current directory and destination\nls . 3_chicken_farm/3_1_hut/\n\nMove the Directory “3_chicken_farm/3_1_hut/Chicken/” to “3_chicken_farm/3_2_field” and rename it “Outdoor_Chicken”.\n\n#List the contents of the start directory\nls ~/Linux/3_chicken_farm/3_1_hut\n#Move the Chicken directory whilst renaming it\nmv ~/Linux/3_chicken_farm/3_1_hut/Chicken/ \\\n~/Linux/3_chicken_farm/3_2_field/Outdoor_Chicken\n#List the contents of the destination directory\nls ~/Linux/3_chicken_farm/3_2_field/Outdoor_Chicken\n\nMove the file “3_chicken_farm/3_3_supplies/feed.txt” to the directory “3_chicken_farm/3_2_field” and rename it “used_feed.txt”\n\n#List start directory to see if the feed.txt file exists\nls 3_chicken_farm/3_3_supplies/feed.txt\n#Move and rename the feed.txt file\nmv 3_chicken_farm/3_3_supplies/feed.txt \\\n3_chicken_farm/3_2_field/used_feed.txt\n#List destination directory\nls 3_chicken_farm/3_2_field/"
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html#copying-directories-and-files",
    "href": "Linux/05-Manipulating_directories.html#copying-directories-and-files",
    "title": "Manipulating directories",
    "section": "Copying Directories and Files",
    "text": "Copying Directories and Files\n\n\n\nFiles and directories can be copied with the cp command. Directories and files can be copied to any directory and given a new name. Note: If you copy a file to the path of a file that already exists, the pre existing file will be overwritten.\nBefore running the below commands move into your “~/Linux/3_chicken_farm/” directory.\n\n#Change directory\ncd ~/Linux/3_chicken_farm/\n#List contents of current directory\nls\n\nCopy the file “3_1_hut/Laid_Egg.txt” to the “3_2_field” directory and give it the filename “Chick.txt”\n\n#List contents of 3_1_hut\nls 3_1_hut\n#Copy Laid_egg to another directory as a new file called Chick.txt\ncp 3_1_hut/Laid_Egg.txt 3_2_field/Chick.txt\n#List contents of 3_2_field\nls 3_2_field\n\nCopy the file “3_2_field/Chick.txt” and give the copy the name “Chick_2.txt”\n\n#List contents of 3_2_field\nls 3_2_field\n#Copy the Chick.txt file as Chick_2.txt\ncp 3_2_field/Chick.txt 3_2_field/Chick_2.txt\n#List contents of 3_2_field\nls 3_2_field\n\nCopy the directory “3_1_hut” to “3_1_hut_2”\n\n#List contents of current directory\nls\n#Copy directory with -r (recursively)\ncp -r 3_1_hut 3_1_hut_2\n#List contents of current directory\nls"
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html#deleting-files-and-directories",
    "href": "Linux/05-Manipulating_directories.html#deleting-files-and-directories",
    "title": "Manipulating directories",
    "section": "Deleting Files and Directories",
    "text": "Deleting Files and Directories\n\n\n\nTo delete files and directories the command rm can be used.\nImportant: This command can be very dangerous. There is no recycle bin on Linux machines so once you delete something it cannot be recovered. Be very careful when deleting files and directories. To avoid major loss try to keep backups of important data and scripts.\nEnsure you are in your “3_chicken_farm/” directory\nRemove the file “3_2_field/Chick_2.txt”\n\n#List contents of 3_2_field\nls 3_2_field\n#Remove Chick_2.txt\nrm 3_2_field/Chick_2.txt\n#List contents of 3_2_field\nls 3_2_field\n\nRemove the directory “3_1_hut_2/” and its contents\n\n#List contents of current directory\nls\n#Remove directory with -r (recursively)\nrm -r  3_1_hut_2\n#List contents of current directory\nls"
  },
  {
    "objectID": "Linux/05-Manipulating_directories.html#mcqs-manipulating-directories",
    "href": "Linux/05-Manipulating_directories.html#mcqs-manipulating-directories",
    "title": "Manipulating directories",
    "section": "MCQs: Manipulating directories",
    "text": "MCQs: Manipulating directories\n\n\n\nPlease attempt to answer the below Multiple-Choice Questions to reinforce what you have learnt in this chapter.\n\nWhat command removes files and directories?\n\n rm mv ls\n\n\n\nWhat command moves files and directories?\n\n rm mv ls\n\n\n\nWhat command makes a new directory?\n\n -r mkdir ls\n\n\n\nWhat option is needed for moving or removing a directory?\n\n -r mkdir ls\n\n\n\nWhat command list the contents of directories?\n\n -r mkdir ls"
  },
  {
    "objectID": "Linux/06-Exercise1.html",
    "href": "Linux/06-Exercise1.html",
    "title": "Exercise 1",
    "section": "",
    "text": "Perform the following tasks with the skills and knowledge you have gained.\nChange the name of the subdirectory “four_exercises” within your “Linux” directory to “4_exercises”"
  },
  {
    "objectID": "Linux/06-Exercise1.html#answers",
    "href": "Linux/06-Exercise1.html#answers",
    "title": "Exercise 1",
    "section": "Answers",
    "text": "Answers\nClick on the below expandable boxes to view my solutions for the exercise. These are not the definitive solution but only examples of solutions. If your method works and you understand why then you have done it correctly.\n\n\nDirectory setup\n\nEnsure you are in the correct directory before carrying out the below commands\n\ncd ~/Linux/\n\n\n\n\nAnswer 1\n\nMake a backup of the 4_exercises directory\n\ncp -r 4_exercises 4_exercises_backup \n\n\n\n\nAnswer 2\n\nList the contents of the 4_exercises directory\n\nls 4_exercises\n\n\n\n\nAnswer 3\n\nWithin the directory 4_exercises\n\ncd 4_exercises\n\nPrint the working directory\n\npwd\n\n\nPrint out to screen the phrase ‘the echo command allows me to print phrases to screen’\n\n\necho “the echo command allows me to print phrases to screen”\n\n\nCopy the file copy_this_file.txt to the directory to_me\n\n\ncp copy_this_file.txt to_me\n\n\nRename the directory to_me to you\n\n\nmv to_me you\n\n\nDelete the initial copy_this_file.txt file\n\n\nrm copy_this_file.txt"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html",
    "href": "Linux/07-File_reading_and_processing.html",
    "title": "File reading and processing",
    "section": "",
    "text": "There are many ways to show the contents of a file. Below are a few examples.\nThe files for the examples are within the directory: “/pub14/tea/nsc2xx/Linux/5_reading_files/” (replace xxx with your user number).\nYouTube walk through video"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#print-out-a-file",
    "href": "Linux/07-File_reading_and_processing.html#print-out-a-file",
    "title": "File reading and processing",
    "section": "Print out a file",
    "text": "Print out a file\n\n\n\nThe cat command will print out the entire contents of a file to the screen. This is useful for small text files and pipelines (pipelines are not covered here). Example commands are below (remember to replace xxx with your user name number):\nNote: remember tab complete and using the arrow keys\nPrint contents of “short_file.txt” to screen\n\ncat ~/Linux/5_reading_files/short_file.txt\n\nPrint contents of “Scientist.txt” to screen\n\ncat ~/Linux/5_reading_files/Scientist.txt\n\nPrint contents of “ecoli.gbk” to screen\n\ncat ~/Linux/5_reading_files/ecoli.gbk\n\nRemember: The clear command."
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#head-and-tail",
    "href": "Linux/07-File_reading_and_processing.html#head-and-tail",
    "title": "File reading and processing",
    "section": "head and tail",
    "text": "head and tail\n\n\n\nThe head command will print out to screen the top n lines of a file.\nThe tail command will print out to screen the bottom n lines of a file.\nThe default value is 10. The -n option can be used to indicate how many lines to print out.\nCarry out the below commands in the directory “/pub14/tea/nsc2xx/Linux/5_reading_files/”\nPrint out the top 10 lines of “ecoli.gbk”\n\nhead ecoli.gbk\n\nPrint out the bottom 10 lines of “ecoli.gbk”\n\ntail ecoli.gbk\n\nPrint out the top 25 lines of “ecoli.gbk”\n\nhead -n 25 ecoli.gbk\n\nPrint out the bottom 2 lines of “ecoli.gbk”\n\ntail -n 2 ecoli.gbk\n\nPrint out all but the bottom 2 lines of “Scientist.txt”\n\nhead -n -2 Scientist.txt\n\nPrint out all lines starting from the 2nd top line of “Scientist.txt”\n\ntail -n +2 Scientist.txt\n\nPrint out all but the bottom 5 lines of “Scientist.txt”\n\nhead -n -5 Scientist.txt\n\nPrint out all lines starting from the 3rd top line of “Scientist.txt”\n\ntail -n +3 Scientist.txt\n\nPrint out the top 25 lines of “ecoli.gbk”\n\nhead -n +25 ecoli.gbk\n\nPrint out the bottom 2 lines of “ecoli.gbk”\n\ntail -n -2 ecoli.gbk"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#file-viewing-with-less",
    "href": "Linux/07-File_reading_and_processing.html#file-viewing-with-less",
    "title": "File reading and processing",
    "section": "File viewing with less",
    "text": "File viewing with less\n\n\n\nThe less command will display a file’s contents one page at a time. Various keys on the keyboard will allow you to navigate the contents of the files. The below actions will occur identically with the man command.\n\nq : Exit\nup and down arrow keys : Will move up/down 1 line at a time\nspace : Move down one page\nb : Move up one page\n/ : Follow this by a term to search for it in the file’s contents\nn : Find the next occurrence of the term last searched for\nN : Find the previous occurrence of the term last searched for\ng : Jump to the first line of the file\nG : Jump to the bottom line of the file\n\nUse the less command to view the contents of the “ecoli.gbk” file. Then find the 3rd occurrence of the word ‘ribosome’. Afterwards move around the file.\n\nless ecoli.gbk\n\nLook at the manual for less and search for the first occurrence of the string ‘percent’. Afterwards look around the manual page.\n\nman less"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#word-count",
    "href": "Linux/07-File_reading_and_processing.html#word-count",
    "title": "File reading and processing",
    "section": "Word count",
    "text": "Word count\n\n\n\nThe wc command will allow allow you to word count files. It will display line, word and byte counts for files in that order.\nUse wc to see the line, word and byte count of the “short_file.txt” and “ecoli.gbk” files. As you can see you can carry this out on multiple files at once.\n\nwc short_file.txt Scientist.txt ecoli.gbk\n\nCount the number of characters in the “short_file.txt” file\n\nwc -m short_file.txt\n\nCount the number of lines in the “ecoli.gbk” file\n\nwc -l ecoli.gbk"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#pattern-searching",
    "href": "Linux/07-File_reading_and_processing.html#pattern-searching",
    "title": "File reading and processing",
    "section": "Pattern searching",
    "text": "Pattern searching\n\n\n\nThe grep command will search for a pattern in a text file and output all the lines containing the pattern.\nPrint out the lines from “Scientist.txt” that have the number 18 in them. In this particular example it prints out all scientists which were born in the 1800s. This will not always be the case depending on the data in the file.\n\ngrep “18” Scientist.txt\n\nPrint out the lines which have the string “Ada” in them.\n\ngrep “Ada” Scientist.txt\n\nPrint out the lines which have the string “ada” in them. There should be none, as grep is case sensitive.\n\ngrep “ada” Scientist.txt\n\nType in the following command.\n\ngrep Scientist.txt\n\nThe above command will be stuck as grep does not know what it is looking for. To cancel the command use ‘Ctrl’ + ‘c’"
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#text-editor",
    "href": "Linux/07-File_reading_and_processing.html#text-editor",
    "title": "File reading and processing",
    "section": "Text editor",
    "text": "Text editor\n\n\n\nThree of the most popular text editors are vim, gedit and nano. Below are quick introductions to nano and vim.\nnano is the easiest to learn but is quite limiting. vim and gedit are quite similar in power with different people preferring one or the other.\nThe below will teach you nano.\n\nnano\n\n\n\nTo enter the nano text editor you can use the command nano. The command is: nano file.txt.\nnano can be run with a previous file name which you can then edit or a new file name in which case you will create a new file.\nOnce you are in the editor you can type characters and move around with the arrow keys.\nTo carry out specific functions you will need to use Ctrl or Alt with another key. At the bottom of the editor are a few examples where the ^ indicates Ctrl. For example the ^G Get Help means you need to press Ctrl+G to get help. When you use letters this way in nano they are case insensitive (i.e. the CAPS lock can be on or off and you will get the same result).\nAfter you carry out a function ensure you look at the bottom of the editor again as it may ask you to type something or you may get a new series of functions you can use.\nBelow are some important examples:\n\nCtrl+X - Exit nano\nCtrl+S - Save file\nCtrl+O - Save file as\nCtrl+A - Jump to the start of a line\nCtrl+E - Jump to the end of a line\nCtrl+W - Start search (Where is) Note This unfortunately is also the shortcut to close a tab in internet browsers. Therefore this can’t be used with our webVNC.\nAlt+W - Continue search forward (find next occurrence forward)\nAlt+Q - Find next occurrence backward\nAlt+K - Cut current line\nAlt+\\ - Go to the first line\nAlt+/ - Go to the last line\n\nNano cheatsheet\n\n\nTasks\nCarry out the following tasks in the directory: “~/Linux/5_reading_files/”\nUsing nano, add an entry for Scientist Mae Jemison (Born: 1956) to the file “Scientist.txt”. The names and date are separated by one tab.\nUsing your text editor of choice delete all the scientists born before 1000 in the “Scientist.txt” file and save this as “Scientist_post_1000.txt”."
  },
  {
    "objectID": "Linux/07-File_reading_and_processing.html#mcqs-file-reading-and-processing",
    "href": "Linux/07-File_reading_and_processing.html#mcqs-file-reading-and-processing",
    "title": "File reading and processing",
    "section": "MCQs: File reading and processing",
    "text": "MCQs: File reading and processing\n\n\n\nPlease attempt to answer the below Multiple-Choice Questions to reinforce what you have learnt in this chapter.\n\nWhat command searches for a pattern?\n\n wc grep cat\n\n\n\nWhat command word counts files?\n\n wc grep cat\n\n\n\nWhat command prints the contents of a file?\n\n wc grep cat\n\n\n\nWhat command displays a file’s contents one page at a time and allows keyboard navigation?\n\n less tail head\n\n\n\nWhat command prints out the top n lines of a file\n\n less tail head\n\n\n\nWhat command prints out the bottom n lines of a file\n\n less tail head"
  },
  {
    "objectID": "Linux/08-Recap.html",
    "href": "Linux/08-Recap.html",
    "title": "Recap",
    "section": "",
    "text": "Throughout this practical we have covered the topics:\n\nLinux\n\nMultiuser Multitasking OS\nUser, Shell and Kernel\n\nRunning commands on the command line\n\nSearch engines, cheat sheets and manual pages\nCommands: man\n\nUseful Linux practice and commands\n\nTab complete\nUp and Down arrow keys to access history\n‘Ctrl’ + ‘c’ to stop a command\nCommands: clear\n\nFiles and Directories\n\nNavigating through directory structure and looking at files with paths\nCommands: cd, pwd, ls, mkdir\n\nManipulating files i.e. creating, copying, moving, deleting\n\nCommands: cp, mv, rm\n\nLooking at files\n\nCommands: cat, head, tail, less, wc, grep\n\nText editor\n\nCommands: vim\n\n\nNote: There is a cheatsheet at the end of this book with these commands."
  },
  {
    "objectID": "Linux/09-Fastq.html",
    "href": "Linux/09-Fastq.html",
    "title": "Fastq format",
    "section": "",
    "text": "The next exercise will focus on a set of files including fastq files.\n\nFastq files are very commonly used in bioinformatics.\nFastq files contain DNA or Amino acid sequenceing data.\nFastq files contain the nucleotide/amino acid content and its sequencing quality for sequences.\nGenerally these files are separated by sample but not always.\nA fastq file acts as a normal txt file that can be read but is of a specific format.\nOne fastq file contains many fastq entries, one after the other.\nEach fastq entry contains four lines.\n\nOne fastq entry represents one sequence.\n\n\nThe format of one entry is as below:\n@Sequence 1\nCTGTTAAATACCGACTTGCGTCAGGTGCGTGAACAACTGGGCCGCTTT\n+\n=&lt;&lt;&lt;=&gt;@@@ACDCBCDAC@BAA@BA@BBCBBDA@BB@&gt;CD@A@B?B@@\nThe lines represent:\n1. Header for fastq entry known as the fastq header. This always begins with a ‘@’.\n2. Sequence content of sequence\n3. Quality header. Always begins with a ‘+’. Sometimes also contains the same information as fastq header.\n4. Quality values for each base in the 2nd line. NOTE: ‘@’ can be used as quality values.\nFor more information on the fastq format the below resource is good: Wikipedia fastq page"
  },
  {
    "objectID": "Linux/10-Exercise2.html",
    "href": "Linux/10-Exercise2.html",
    "title": "Exercise 2",
    "section": "",
    "text": "The directory “~/Linux/6_final_exercise/” has all the files you need. Below is a set of tasks and questions that will require all the skills you have gained from this practical."
  },
  {
    "objectID": "Linux/10-Exercise2.html#answers",
    "href": "Linux/10-Exercise2.html#answers",
    "title": "Exercise 2",
    "section": "Answers",
    "text": "Answers\nClick on the below expandable boxes to view my solutions for the exercise. These are not the definitive solution but only examples of solutions. If your method works and you understand why then you have done it correctly.\n\n\nDirectory setup\n\nEnsure you are in the correct directory before carrying out the below commands\n\ncd ~/Linux/6_final_exercise\n\n\n\n\nAnswer 1\n\nSee what files are in the directory\n\nls\n\n\n\n\nAnswer 2\n\n\nRename the file 3-P£_CACTTCGA_L001_R1_001.fastq to 3-P3_CACTTCGA_L001_R1_001.fastq\n\n\nmv 3-P£_CACTTCGA_L001_R1_001.fastq \\\n3-P3_CACTTCGA_L001_R1_001.fastq\n\n\n\n\nAnswer 3\n\nMake a backup of the files in a directory called backup\n\nmkdir backup\ncp 1-P1_ATGCCTGG_L001_R1_001.fastq backup/\ncp 1-P1_ATGCCTGG_L001_R2_001.fastq backup/\ncp 2-P2_AAGGACAC_L001_R1_001.fastq backup/\ncp 2-P2_AAGGACAC_L001_R2_001.fastq backup/\ncp 3-P3_CACTTCGA_L001_R1_001.fastq backup/\ncp 3-P3_CACTTCGA_L001_R2_001.fastq backup/\ncp 4-E1_ATTGGCTC_L001_R1_001.fastq backup/\ncp 4-E1_ATTGGCTC_L001_R2_001.fastq backup/\ncp metadata.txt backup/\n\nThis can be done a lot quicker with the use of wildcard characters (Covered in Advanced Linux section)\n\nmkdir backup\ncp *fastq backup\ncp *txt backup\n\n\n\n\nAnswer 4\n\nHow many reads are in the samples? The below command will give the number of lines in the files, this number can then be divided by 4 (mentally or using a calculator). These values will be the same for the R2 files as they are for the matching R1 file.\n\nwc -l 1-P1_ATGCCTGG_L001_R1_001.fastq \\\n2-P2_AAGGACAC_L001_R1_001.fastq \\\n3-P3_CACTTCGA_L001_R1_001.fastq\n\nAn advanced method using regular expressions, wildcard characters and grep\n\ngrep -c \"^@[0-9]*_\" *R1*.fastq\n\n\n\n\nAnswer 5\n\nRemove the fastq files with no data Check which files have no data\n\nwc \\\n1-P1_ATGCCTGG_L001_R1_001.fastq 1-P1_ATGCCTGG_L001_R2_001.fastq \\\n2-P2_AAGGACAC_L001_R1_001.fastq 2-P2_AAGGACAC_L001_R2_001.fastq \\\n3-P3_CACTTCGA_L001_R1_001.fastq 3-P3_CACTTCGA_L001_R2_001.fastq \\\n4-E1_ATTGGCTC_L001_R1_001.fastq 4-E1_ATTGGCTC_L001_R2_001.fastq \n\nRemove empty files\n\nrm \\\n4-E1_ATTGGCTC_L001_R1_001.fastq 4-E1_ATTGGCTC_L001_R2_001.fastq\n\n\n\n\nAnswer 6\n\nUpdate the backup files with the previous change\n\nrm backup/4-E1_ATTGGCTC_L001_R1_001.fastq \\\nbackup/4-E1_ATTGGCTC_L001_R2_001.fastq \n\n\n\n\nAnswer 7\n\nCheck if the 1st read names match in the paired files\n\nhead -n 1 \\\n1-P1_ATGCCTGG_L001_R1_001.fastq 1-P1_ATGCCTGG_L001_R2_001.fastq \\\n2-P2_AAGGACAC_L001_R1_001.fastq 2-P2_AAGGACAC_L001_R2_001.fastq \\\n3-P3_CACTTCGA_L001_R1_001.fastq 3-P3_CACTTCGA_L001_R2_001.fastq \n\n\n\n\nAnswer 8\n\nCheck if the last read names match in the paired files\n\ntail -n 4 \\\n1-P1_ATGCCTGG_L001_R1_001.fastq 1-P1_ATGCCTGG_L001_R2_001.fastq \\\n2-P2_AAGGACAC_L001_R1_001.fastq 2-P2_AAGGACAC_L001_R2_001.fastq \\\n3-P3_CACTTCGA_L001_R1_001.fastq 3-P3_CACTTCGA_L001_R2_001.fastq \n\n\n\n\nAnswer 9\n\nIn file 1-P1_ATGCCTGG_L001_R1_001.fastq look for sequence headers with the term ‘psychrobacter’\n\ngrep “psychrobacter” 1-P1_ATGCCTGG_L001_R1_001.fastq\n\n\n\n\nAnswer 10\n\nIn the sample 1-P1 remove any fastq entries where the term ‘psychrobacter’ appears in the fastq header. Do this for the R1 and R2 file. - Using nano use “Ctrl+W” to search for psychrobacter. Then use “Ctrl+K” to cut the lines followed by “Ctrl+W” and “Ctrl+X” to save and exit. - Using vim with “/” to search for psychrobacter, “dd” to delete lines and “:wq” to save the file and exit it. 11. Print to screen the fastq header, sequence and quality data for the 25th sequence in sample 2-P2 for both the R1 and R2 file. Do this with one command. @24_ecoli is grepped as the first sequence is @0_ecoli\n\ngrep -A 3 \"@24_ecoli\" 2-P2_AAGGACAC_L001_R1_001.fastq\ngrep -A 3 \"@24_ecoli\" 2-P2_AAGGACAC_L001_R2_001.fastq"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html",
    "href": "Linux/11-Advanced_linux_practice.html",
    "title": "Advanced Linux practice",
    "section": "",
    "text": "We have covered a small amount of Linux coding. This should be sufficient to carry out our future workshops but if you were to continue in bioinformatics we would recommend learning more advanced methods.\nBelow are some short sections to introduce you to some more advanced linux coding techniques. These give you a quick overview and some examples. This will hopefully put you in a good position to allow you to to learn these techniques in more depth outside of this workshop.\nThe following sections will all be run with the files in the directory “~/Linux/advanced_practice/”. Therefore ensure you are in this directory before running the below examples. This contains fastq and txt files for 20 samples. Each sample contains a fastq file and txt file for uncorrected and corrected reads. These fastq files are single end (i.e. there is no reverse/R2 reads)."
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#wildcard-characters",
    "href": "Linux/11-Advanced_linux_practice.html#wildcard-characters",
    "title": "Advanced Linux practice",
    "section": "Wildcard characters",
    "text": "Wildcard characters\n\n\n\nThese are characters that can be used to represent a variety of other characters. This can be useful for deleting many files, searching for files with specific patterns in their names and more!\nBe very careful when using wildcard character with the command rm.\nThree basic and useful wildcards include:\n\n* - This represents zero or more characters\n\n? - This represents a single character\n\n[] - This represents a range of characters\n\nBelow are various examples you can run to show wildcards in action.\nList all the files and directories in the working directory\n\nls *\n\nList all files ending in “.fastq”\n\nls *.fastq\n\nList all files ending in “.txt”\n\nls *.txt\n\nList all files with the string “corrected” somewhere in the file name\n\nls *corrected*\n\nList all files with the string “corrected” somewhere in the file name and it ends in “fastq”\n\nls *corrected*fastq\n\nList all files that begin with “sample_2”\n\nls sample_2*\n\nList all files that begin with “sample_2_”\n\nls sample_2_*\n\nList the files that begin with “sample_1” and ends with “AAAA.txt”. It may have zero or more characters between these two.\n\nls sample_1_*AAAA.txt\n\nList the fastq files of samples with a single digit number\n\nls sample_?_*fastq\n\nList the txt files of samples with a number in the tens\n\nls sample_1?_*txt\n\nList the txt files for samples 3,4,5,6 & 7 i.e. 3-7\n\nls sample_[3-7]_*txt\n\nList the txt files for the non corrected information of samples with single digits.\n\nls sample_?_*[ATGC].txt\n\nList the corrected txt files for samples with numbers divisible by 10.\n\nls sample_[0-9][0]_*corrected.txt"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#redirection",
    "href": "Linux/11-Advanced_linux_practice.html#redirection",
    "title": "Advanced Linux practice",
    "section": "Redirection",
    "text": "Redirection\n\n\n\nRedirection allows you to put the output of a command to a file. The redirect symbol is &gt;. Be careful when redirecting as it will overwrite any existing files. To append to the bottom of a file use &gt;&gt;.\nBelow are various examples of redirecting in action.\nCreate a file called ecoli.tmp containing the text “I am escherichia coli”\n\necho “I am escherichia coli” &gt; ecoli.tmp\n\nCreate a file called pcryohalolentis.tmp containing the text “I am psychrobacter cryohalolentis”\n\necho “I am psychrobacter cryohaloloentis” &gt; pcryohalolentis.tmp\n\nCreate a new file called bacteria.tmp which will contain the text from ecoli.tmp and pcryohalolentis.tmp\n\ncat *tmp &gt; bacteria.tmp\n\nCreate a file called vcholerae.tmp containing the text “I am not ecoli or pcryohalolentis”\n\necho “I am not ecoli or pcryohalolentis” &gt; vcholerae.tmp\n\ncat the file vcholerae.tmp and redirect it to bacteria.tmp.\n\ncat vcholerae.tmp &gt; bacteria.tmp\n\nLook at the contents of bacteria.tmp\n\ncat bacteria.tmp\n\nThis has removed the ecoli and pcryohalolentis lines. Append the contents of ecoli.tmp and pcryohalolentis.tmp to bacteria.tmp and then check the file\n\ncat ecoli.tmp pcryohalolentis.tmp &gt;&gt; bacteria.tmp\ncat bacteria.tmp\n\nPut information regarding number of lines of all the fastq files into a new file called fastq_lines.tmp\n\nwc -l *fastq &gt; fastq_lines.tmp\n\nNow delete all the files that were created in the above examples. Again be very careful about using the rm command with wildcards.\n\nrm *tmp"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#pipes",
    "href": "Linux/11-Advanced_linux_practice.html#pipes",
    "title": "Advanced Linux practice",
    "section": "Pipes",
    "text": "Pipes\n\n\n\nPipes allow you to put the output of one command to the input of another. For example you could use grep to get all the lines with a certain string and pipe the output to wc to count the number of lines that have the specific string.\nThe pipe symbol is |. This is normally found on your keyboard directly left of the Z key. Weirdly the symbol is represented by | but split in the middle on some keyboards.\nA useful tip when building up longer pipes is to start with a smaller amount of data and check the output of each step as you go. To do this you could use head instead of cat whilst testing.\nBelow are various examples of piping in action\nPrint to screen the second last fastq entry of the file sample_20_ATAC_corrected.fastq\n\ncat sample_20_ATAC_corrected.fastq | tail -n 8 | head -n 4 \n\nNote: In the above command the tail command is working on the output of the cat command. Therefore this would not work to get the second last fastq entry of multiple files. For example the following command would print the second last fastq entry of the last fastq file (i.e. sample_9_AAGA.fastq due to file ordering)\n\ncat *fastq | tail -n 8 | head -n 4\n\nCount the number of lines within all the fastq files\n\ncat *fastq | wc -l\n\nCount the number of lines which contain the text “TAG” within all the fastq files\n\ncat *fastq | grep “TAG” | wc -l"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#regular-expressions",
    "href": "Linux/11-Advanced_linux_practice.html#regular-expressions",
    "title": "Advanced Linux practice",
    "section": "Regular expressions",
    "text": "Regular expressions\n\n\n\nRegular expressions are similar to wildcard characters but more complex and used for commands like grep and sed.\nBelow are a basic set of regular expressions:\n\n. : A single character\n\n? : The preceding character matches 1 or 0 times\n\n* : The preceding character matches zero or more times\n\n+ : The preceding character matches one or more times\n\n{n} : The preceding character matches exactly n times\n\n{n,m} : The preceding character matches n to m times\n\n[AT] : The character is one of the characters in the brackets\n\n[^CG] : The character is not one of those in the brackets\n\n[1-7] : The character is 1,2,3,4,5,6 or 7. This works with letters too.\n\n() : Group several characters into one\n\n| : Logical OR operator\n\n^ : Matches the beginning of the line\n\n$ : Matches the end of the line\n\nBelow are various examples of regular expressions in action.\nLook at the contents of metadata.txt\n\ncat metadata.txt\n\n!Print out the lines for the Healthy patients\n\ncat metadata.txt | grep “HEALTHY”\n\nPrint out the lines for the IBD patients from Craigavon and Belfast. In the below command \\ is used to allow | to be used as an or operator instead of acting as a string to match.\n\ncat metadata.txt | grep \"IBD\" | grep \"BELFAST\\|CRAIGAVON\"\n\nPrint out the lines for the Pre information of patients not from Edinburgh or Aberdeen\n\ncat metadata.txt | grep \"PRE$\" | grep -v \"ABERDEEN\\|EDINBURGH\"\n\nPrint out the lines for patients 1,2,3 and 4\n\ncat metadata.txt | grep \"Patient_[1-4][^0-9]\" \n\nPrint to screen every fastq header of file sample_15_AACG_corrected.fastq\n\ncat sample_15_AACG_corrected.fastq | grep “^@sample”\n\nIn the piping examples we counted the number of lines with the text “TAG” within the fastq files. However this also counted fastq headers due to the name of the samples. Let us use a regular expression to only count the number of sequences within the fastq files that contain “TAG”.\n\ncat *fastq | grep “^[^@].*TAG”\n\nPrint to screen every line within the file sample_3_AAAG_corrected.fastq that has a possible Threonine codon in the forward direction.\n\ngrep \"^[^@].*AC[ACTG]\" sample_3_AAAG_corrected.fastq\n\nIn the above example fastq quality lines are also extracted as some of them also contain the pattern we are searching for. To get around this we can pipe. First grep the fastq quality header (i.e. +), as no other line only contains “+”, and the line before it. Then we can remove lines with only a plus with an invert grep. Finally we can grep for the threonine pattern using only the sequence lines. Let us build this up step by step.\nPrint to screen the fastq quality header plus the one line preceding each (i.e. Sequence line) for file sample_3_AAAG_corrected.fastq.\n\ngrep -B 1 “^+$” sample_3_AAAG_corrected.fastq\n\nNow pipe this output so it removes the lines with “+” (fastq quality headers) and “–” (separators of each grep match provided by grep because of the -B 1 option).\n\ngrep -B 1 \"^+$\" sample_3_AAAG_corrected.fastq | grep -v \"+\\|--\"\n\nNow from this output, grep for the Threonine pattern plus colour each match within the line with the option “–color”.\n\ngrep -B 1 \"^+$\" sample_3_AAAG_corrected.fastq | grep -v \"+\\|--\" | grep --color \"AC[ACTG]\"\n\nLet us repeat the above but add the possibility of the threonine being in the reverse direction.\n\ngrep -B 1 \"^+$\" sample_3_AAAG_corrected.fastq | grep -v \"+\\|--\" \\\n| grep --color \"AC[ACTG]\\|[ACTG]CA\"\n\nResources to learn more in the future\nRex Egg, A good resource to learn more about regular expressions:\nhttps://www.rexegg.com/\nCheatsheet:\nhttps://www.rexegg.com/regex-quickstart.html\nRegex Crossword, A online game like soduku that is useful to practice regular expressions. Best used in conjunction with the above cheat sheet:\nhttps://regexcrossword.com/"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#sed",
    "href": "Linux/11-Advanced_linux_practice.html#sed",
    "title": "Advanced Linux practice",
    "section": "sed",
    "text": "sed\n\n\n\nThis is a complicated yet powerful command that can be used to edit text files quickly and efficiently. The main use is to substitute text with other text. sed can be used with regular expressions.\nThe basic outline of a sed substitute command is as below. In the below case s/ signifies that sed will be used for substitution\n\nsed “s/old_text/new_text/” old_file &gt; new_file\n\nBelow are some examples of sed in action.\nPrint out a list of all the sample names using the fastq files\n\nls -1 *[AGTC].fastq | sed \"s/.fastq//\"\n\nFirst print out the contents of the file metadata.txt\n\ncat metadata.txt\n\nPrint out metadata.txt and change IBD to DISEASE without altering the file\n\nsed \"s/IBD/DISEASE/\" metadata.txt\n\nor\n\ncat metadata.txt | sed \"s/IBD/DISEASE/\"\n\nsed is case sensitive and will by default only replace the first instance it finds within each line. Print metadata.txt to screen and then change the “P” in “Patient” to “Human_P”\n\ncat metadata.txt | sed \"s/P/Human_P/\"\n\nTo replace every instance of the old pattern within each line g can be added after the last /. This stands for global therefore it changes the command to a global substitute.\nPrint metadata.txt to screen and change every occurrence of a number to “number”. To get the regular expression meaning of “+” it needs a “\\” before the “+”\n\ncat metadata.txt | sed \"s/[0-9]\\+/number/g\"\n\nThe file metadata.txt is tab delimited (i.e. there is a tab between each column. Make a comma separated file containing the information of metadata.txt called metadata.csv (csv = comma separated value). \\t presents a tab.\n\ncat metadata.txt | sed \"s/\\t/,/g\" &gt; metadata.csv\n\nFor a very in depth look into the sed command please look at the following link: http://www.grymoire.com/Unix/Sed.html"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#permissions",
    "href": "Linux/11-Advanced_linux_practice.html#permissions",
    "title": "Advanced Linux practice",
    "section": "Permissions",
    "text": "Permissions\nAll files, directories and programs have permissions. It is important to know about this so you know your read, write and executability permissions for the content within machines.\nBelow is a useful link to learn about file permissions:\nhttps://www.guru99.com/file-permissions.html"
  },
  {
    "objectID": "Linux/11-Advanced_linux_practice.html#mcqs-advanced-linux",
    "href": "Linux/11-Advanced_linux_practice.html#mcqs-advanced-linux",
    "title": "Advanced Linux practice",
    "section": "MCQs: Advanced linux",
    "text": "MCQs: Advanced linux\n\n\n\nPlease attempt to answer the below Multiple-Choice Questions to reinforce what you have learnt in this chapter.\n\nWhich symbol is used to pipe the output of one command to the input of another?\n\n &gt; | sed\n\n\n\nWhat command can be used to substitute text with other text?\n\n &gt; | sed\n\n\n\nWhich symbol is used to redirect the output of a command to a file?\n\n &gt; | sed\n\n\n\nWhich wildcard represents a single character?\n\n * [] ?\n\n\n\nWhich wildcard represents zero or more characters?\n\n * [] ?\n\n\n\nWhich wildcard represents a range of characters?\n\n * [] ?\n\n\n\nWhich regular expression indicates that the preceding character matches 1 or 0 times?\n\n . ? *\n\n\n\nWhich regular expression represents a single character?\n\n . ? *\n\n\n\nWhich regular expression indicates that the preceding character matches zero or more times?\n\n . ? *\n\n\n\nWhich regular expression matches the end of the line?\n\n | ^ $\n\n\n\nWhich regular expression is a logical OR operator?\n\n | ^ $\n\n\n\nWhich regular expression matches the start of the line?\n\n | ^ $"
  },
  {
    "objectID": "Linux/12-Advanced_practice_exercise.html#answers",
    "href": "Linux/12-Advanced_practice_exercise.html#answers",
    "title": "Advanced practice exercise",
    "section": "Answers",
    "text": "Answers\nClick on the below expandable boxes to view my solutions for the exercise. These are not the definitive solution but only examples of solutions. If your method works and you understand why then you have done it correctly.\n\n\nDirectory setup\n\nEnsure you are in the correct directory before carrying out the below commands\n\ncd ~/Linux/\n\n\n\n\nAnswer 1\n\nCopy the directory ~/Linux/advanced_practice to ~/Linux/advanced_practice_exercise\n\ncp -r ~/Linux/advanced_practice ~/Linux/advanced_practice_exercise\n\n\n\n\nAnswer 2\n\nMove into ~/Linux/advanced_practice_exercise\n\ncd ~/Linux/advanced_practice_exercise\n\n\n\n\nAnswer 3\n\nMake a directory called fastq and one called txt\n\nmkdir fastq txt\n\n\n\n\nAnswer 4\n\nWith one command move all the fastq files into the directory fastq\n\nmv *.fastq fastq/\n\n\n\n\nAnswer 5\n\nWith one command move all the txt files, excluding metadata.txt and samples.txt, into the directory txt.\n\nmv sample_*txt txt/\n\n\n\n\nAnswer 6\n\nCreate a file in the fastq directory called patient_1_corrected.fastq and put all the corrected fastq data for patient_1 into the file.\n\ncat fastq/sample_[1-2]_*corrected.fastq &gt; \\\nfastq/patient_1_corrected.fastq\n\n\n\n\nAnswer 7\n\nAppend the metadata line for sample_1_AAAA from metadata.txt to the bottom of the file sample_1_AAA.txt in the txt directory.\n\ncat metadata.txt | grep \"sample_1_AAAA\" &gt;&gt; txt/sample_1_AAAA.txt\n\n\n\n\nAnswer 7\n\nFor all the corrected fastq files find the sequences that start with a stop codon in the forward orientation (i.e. TAG, TAA or TGA). Print out to screen the sample name and sequence info separated by a “:” only (i.e. sample_10_AAGT:TAAGAGAACAATGAACAGATATTAATAATTTTGCCGCTTTTCTGCGGGAT)\n\ngrep \"^TA[AG]\\|^TGA\" fastq/*corrected.fastq | \\\nsed \"s/.*sample/sample/\" | sed \"s/_corrected.fastq//\"\n\n\n\n\nAnswer 9\n\nCount the number of Gs and Cs within the sequences of file sample_16_AACC.fastq\n\ncat fastq/sample_16_AACC.fastq | grep -B 1 \"^+$\" | \\\ngrep -v \"+\\|--\" | sed \"s/A\\|T//g\" | wc -c\n\n\n\n\nAnswer 10\n\nGet the fastq headers of sequences with homopolymers made of As with a length of 5 or greater for the uncorrected fastq files for samples 8-13 with one command. Then in the same command make the final output of each line in the format of “Sample_13: Sequence 12”\n\ncat fastq/*[3-5]*[AGCT].fastq | grep -B 2 \"^+$\" | \\\ngrep -B 1 \"AAAAA\" | grep \"^@\" | sed \"s/^@s/S/\" | \\\nsed \"s/_[AGCT]*_/: Sequence /\" | sed \"s/ 1:$//\""
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html",
    "href": "Linux/13-Bioinformatic_languages.html",
    "title": "Bioinformatic languages",
    "section": "",
    "text": "Unfortunately you cannot do everything you would want directly on the Linux command line. Even the tasks you can do are sometimes not very efficient or easy. Fortunately there are many other programming languages you can use. There is a large amount of other programming languages and it can be hard to know which one to learn. Below is a list of commonly used bioinformatic program languages with a brief summary on their purpose and links to online resources to introduce you to the language."
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#awk",
    "href": "Linux/13-Bioinformatic_languages.html#awk",
    "title": "Bioinformatic languages",
    "section": "awk",
    "text": "awk\nawk is typically used as a data extraction and reporting tool. It is very good due to its power and versatility.\nTutorial:\nhttp://www.grymoire.com/Unix/Awk.html\nManual:\nhttps://www.gnu.org/software/gawk/manual/gawk.html"
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#python",
    "href": "Linux/13-Bioinformatic_languages.html#python",
    "title": "Bioinformatic languages",
    "section": "Python",
    "text": "Python\n\n\n\nPython is used for software development and other applications It is favoured in Bioinformatics due to its relative ease to learn and it is able to handle strings well (i.e. genetic code). There are also many packages for python that help the analysis of biological data and other scientific data.\nPython website:\nhttps://www.python.org/\nBioPython:\nhttps://biopython.org/"
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#perl",
    "href": "Linux/13-Bioinformatic_languages.html#perl",
    "title": "Bioinformatic languages",
    "section": "Perl",
    "text": "Perl\n\n\n\nPerl is a similar language to python with similar uses. The main difference is how they look.\nTutorial:\nhttps://www.tutorialspoint.com/perl/perl_introduction.htm\nPerl website:\nhttps://www.perl.org/\nBioPerl:\nhttps://bioperl.org/"
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#python-or-perl",
    "href": "Linux/13-Bioinformatic_languages.html#python-or-perl",
    "title": "Bioinformatic languages",
    "section": "Python or Perl?",
    "text": "Python or Perl?\nGenerally speaking people normally choose to either learn python or perl. However there are many bioinformatic tools written in perl and many written in python. Therefore it is good to know a bit in both so you can debug scripts and specialise in one so you can write your own scripts. Our suggestion would be to specialise in Python due to its ease to learn and its growing popularity in the Bioinformatics field. However there are also other upcoming programming languages that are becoming more popular in bioinformatics, so you may like to give them a look."
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#ruby",
    "href": "Linux/13-Bioinformatic_languages.html#ruby",
    "title": "Bioinformatic languages",
    "section": "Ruby",
    "text": "Ruby\n\n\n\nA programming language that is becoming more popular in bioinformatics due to its beginner friendliness.\nTutorial:\nhttp://rubylearning.com/\nRuby website:\nhttps://www.ruby-lang.org/en/\nBioRuby:\nhttp://bioruby.org/\nWhy learn Ruby?\nhttp://www.bestprogramminglanguagefor.me/why-learn-ruby"
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#golang-aka-go",
    "href": "Linux/13-Bioinformatic_languages.html#golang-aka-go",
    "title": "Bioinformatic languages",
    "section": "Golang (AKA Go)",
    "text": "Golang (AKA Go)\n\n\n\nAnother easy programming language with a library specifically made for bioinformatics.\nTutorial:\nhttps://tour.golang.org/welcome/1\nGo website:\nhttps://golang.org/\nbiogo:\nhttps://github.com/biogo/biogo"
  },
  {
    "objectID": "Linux/13-Bioinformatic_languages.html#r",
    "href": "Linux/13-Bioinformatic_languages.html#r",
    "title": "Bioinformatic languages",
    "section": "R",
    "text": "R\n\n\n\nR is a very powerful programming language for statistical analysis and visualisation. It unfortunately has a large barrier to entry and normally quite unclear documentation. However it will unlikely be surpassed by another language any time soon due to its widespread use and large amount of very useful and powerful packages for various uses in the public domain. We would recommend using the IDE Rstudio when using R.\nTutorial:\nhttps://swirlstats.com/\nR Website:\nhttps://www.r-project.org/\nCran Website:\nhttps://cran.r-project.org/\nRstudio Website:\nhttps://www.rstudio.com/"
  },
  {
    "objectID": "Linux/a1-cheat_sheet.html",
    "href": "Linux/a1-cheat_sheet.html",
    "title": "Practical cheat sheet",
    "section": "",
    "text": "Practical cheat sheet\n\n\n\n\n\n\n\n\n\n\n\nCommand\nDescription\nUsage example\n\n\n\n\necho\nPrint out a string to screen\nEcho ‘Hello World’\n\n\nman\nLook at the manual page of a command\nman man\n\n\nclear\nClear the screen\nclear\n\n\n&lt;tab&gt;\nComplete a path or command\n&lt;tab&gt;\n\n\ncd\nChange directory\ncd /directory/path/\n\n\npwd\nPrint Working Directory\npwd\n\n\nls\nList the contents of a directory\nls /directory/path/\n\n\nmkdir\nMake a directory\nmkdir /directory/path/new_directory/\n\n\ncp\nCopy content to another path\ncp /directory/path/file.txt /directory/path/new_directory/\n\n\nmv\nMove content to a new path\nmv /directory/path/file.txt /directory/path/new_directory/\n\n\nrm\nDelete content\nrm /directory/path/file.txt\n\n\ncat\nPrint contents of a file to screen\ncat /directory/path/file.txt\n\n\nhead\nPrint out the first n lines of a file to screen\nhead -n 10 /directory/path/file.txt\n\n\ntail\nPrint the last n lines of a file to screen\ntail -n 12 /directory/path/file.txt\n\n\nless\nRead a file one page at a time\nless /directory/path/file.txt\n\n\nwc\nPrint out line, word and byte count\nwc /directory/path/file.txt\n\n\ngrep\nSearch for lines that contain a specific pattern\ngrep “pattern” /directory/path/file.txt\n\n\nvim\nText editor\nvim /directory/path/file.txt"
  },
  {
    "objectID": "Linux/index.html",
    "href": "Linux/index.html",
    "title": "Introduction",
    "section": "",
    "text": "Bioinformatics is an increasingly important skill for biological scientists. Many bioinformatic tools can only be run on Linux based operating systems. This course aims to introduce you to Linux and is aimed at beginners and novices to the command line.\nThis part of the website contains theory, practice code, and exercises. Multiple choice questions will help reinforce what you have learnt throughout the book.\nAt the end of the course learners will be able to:\nThe Advanced topics section contains some additional advanced Linux commands and introductions to other programming languages used by bioinformaticians.\nCommands are in the following font, colour, and box. They should be run in the command line.\necho \"This is a command example\"\nAdditionally, please use the cheatsheet as a reminder of all the commands you will be learning."
  },
  {
    "objectID": "Linux/index.html#table-of-contents",
    "href": "Linux/index.html#table-of-contents",
    "title": "Introduction",
    "section": "Table of contents",
    "text": "Table of contents\n\n\n\nWhat is Linux?\n\n\n\n\n\nStarting\n\n\n\n\n\n\n\nDirectories and files\n\n\n\n\n\nTips and tricks\n\n\n\n\n\n\n\nManipulating Directories\n\n\n\n\n\nFile reading and processing\n\n\n\n\n\n\n\nAdvanced Linux\n\n\n\n\n\nOther Bioinformatics programming languages\n\n\n\n\n\n\n\nAppendix\n\n\n\n\n\n\n\n\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  }
]