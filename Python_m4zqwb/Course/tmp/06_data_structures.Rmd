# Data Structures
<center>![](./images/python_data_structure.png){width=25%}</center>

We now know the different types of data points that Python can hold, whether
they are __integers__, __floats__, __strings__ of text, or __boolean__ values.

Typically, data points do not exist in isolation but instead are in a group. 
For example, consider a set of measurements of the peak day temperature over
a period of a week. 
A group of data points such as these can be stored in a __list__.

## Lists

<center>![](./images/data_icon.webp){width=15%}</center>

__Lists__ are used to store multiple items within a single __variable__. 
__Lists__ allow duplicate values and once defined are always in the same order (ordered).
Additional items can be added to the __list__ and by default will appear at the bottom.
Finally, __lists__ are indexed meaning that we can easily retrieve the 1st, 2nd....nth item from the __list__.

### Add numeric data to a list
<center>![](./images/up_down.webp){width=15%}</center>

We define a __list__ like any other __variable__. 
To add multiple values to the __list__ we enclose them in square braces and include a comma between each value.

Add the following (made up) data representing some fold-change values generated by an RNA-Seq type experiment.

```{python, eval=FALSE}
gene_fold_change = [0.25, -0.42, 0.62, 1.27, -0.5, 0]
```

To add an additional value to the **end** of the list, we can use the `append()` __method__:

__Reminder__: Each unique __method__ can only be used on one type of data. The `append()` method can only be used with __lists__.

```{python, eval=FALSE}
gene_fold_change.append(0.33)

gene_fold_change
```

## Subsetting data
<center>![](./images/R_square_bracket.png){width=15%}</center>


A value from the __list__ can be retrieved by the **position** it occupies in the list.
This selection can be carried out using square braces.

This process of selecting a certain portion of data is known as subsetting.

One of the most vital aspects to grasp for Python is that data structures start at position zero.
This can be confusing but is a common feature of many programming languages.

To select the first entry in the __list__, we therefore pass position "0" in the square braces:

```{python, eval=FALSE}
# Get the first value:
gene_fold_change[0]

# Get the fifth value:
gene_fold_change[4]
```

We can also use a negative value to count from the other end of the __list__. I.e. to get the last value in the list.

```{python, eval=FALSE}
# Get the last value (without knowing the length of the list)
gene_fold_change[-1]
```

The same technique also works to select a range of values from the list. The upper and lower position of the range to be selected given in square brackets, separated by a colon. 

When using a range in this manner the last number is exclusive. In other words all the positions except the last one will be selected.

```{python, eval=FALSE}
# subset the third and fourth values
gene_fold_change[2:4]
# subset the first to fifth value
gene_fold_change[0:5]
# subset the first values
gene_fold_change[0:1]
```

To subset everything from a certain position onwards, leave the upper value blank. This also works to select everything before a certain position.

```{python, eval=FALSE}
# subset the sixth value to the end
gene_fold_change[5:]

# subset everything up to (but excluding) the third value
gene_fold_change[:2]
```

## Set
<center>![](./images/golf_club_set.png){width=15%}</center>

A __set__ is similar to a __list__ except that it can only hold __unique__ values.
A __set__ also differs from a __list__ in that a set does not retain the order of the elements (unordered).

__Sets__ are defined using the curly braces (`{}`). Define a __set__ containing plants found in a (fictional) pollen metabarcoding experiment. 

```{python, eval=FALSE}
plants_set = {"Dandelion", "Buttercup", "Clover", "Poppy"}

plants_set
```

A second round of analysis found an extra plant species. 
We can add a new element to our __set__ using the `add()` __method__.

```{python, eval=FALSE}
plants_set.add("Honeysuckle")

plants_set
```

Combining data from more samples might mean that duplicate plants were detected in the data. 
Adding plants that are already in the set has no effect as it cannot hold duplicate values.

```{python, eval=FALSE}
plants_set.add("Buttercup")

plants_set
```

## Transform a list to a set
<center>![](./images/transform_2.png){width=15%}</center>

Sometimes we have a __list__ of non-unique values and it is useful to extract the unique values. We can do this by transforming a __list__ into a __set__.

Add some gene IDs to a __list__:

```{python, eval=FALSE}
gene_IDs = ["Agl", "Pygm", "Pgm2", "Ugp2", "Pygm", "Pgm2"]

# Note that a list can hold duplicate values
gene_IDs
```

We can transform the __list__ into a __set__ using the __function__ `set()`:

```{python, eval=FALSE}
gene_set = set(gene_IDs)

# The duplicates have been removed
gene_set
```

## Dictionary

<center>![](./images/dictionary_icon.png){width=15%}</center>

The third data structure we will learn is the **dictionary**. A __dictionary__ is an
ordered data structure which holds **pairs** of values; a **key** and a **value**.

For example, say we want to store the gene identifiers alongside our fold-change data
that we recorded earlier in a __list__. 
Each gene identifier/fold-change pair is the __key__/__value__ of the __dictionary__.

__Dictionaries__ are also defined using the curly braces but a pair of values are given each time, separated by a colon.

Enter the following. 

__Note__: You need to press enter after each line.

```{python, eval=FALSE}
gene_fold_change = {
  "Agl" : 0.25,
  "Pygm" : -0.42,
  "Pgm2" : 0.62,
  "Ugp2" : 1.27,
  "Gys1" : -0.5,
  "Phka1" : 0,
  "Phkg1" : 0.33
}
gene_fold_change
```

__Dictionaries__ are **indexed** meaning that individual records can be retrieved 
very quickly (important if you are working with very large dictionaries).

We can retrieve the information for "Gys1" by using the identifier as the **key** 
and the __dictionary__ will then return the **value**.

```{python, eval=FALSE}
gene_fold_change["Gys1"]
```

New values can be added to the __dictionary__ in a similar way to how they are retrieved:
```{python, eval=FALSE}
gene_fold_change["ZT1"] = 3.2
gene_fold_change["ZT1"]
```

The pairing up of values in __dictionaries__ is extremely useful if you are working with DNA sequence files (Fasta or FastQ). 
It offers an easy way of matching up the read identifier with the DNA nucleotide data, for example. 
Once indexed, the individual records can then be accessed extremely quickly.

## Recap

<center>![](./images/recap.webp){width=25%}</center>


**Lists** hold an ordered catalogue of values. 
Values can be accessed by their position in the list (remember to count from zero!). 

**Sets** can only hold unique values.

**Dictionaries** hold pairs of values (key and value) and can be used to quickly access individual records, even when they are extremely large.

We are going to be using these data structures to look at and manipulate DNA sequence data specifically, but the principles apply to any datasets stored in these structures.