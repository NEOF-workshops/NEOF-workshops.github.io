[["index.html", "Python for Bioinformatics 1 Introduction", " Python for Bioinformatics November, 2022 1 Introduction In this practical session we are going to learn Python programming skills. We will be learning the fundamentals of Python scripting and several Python tools focused on data manipulation. Whilst we will be working mostly with DNA sequence data, the methods and approaches can be modified to work with most types of data. During this session we will work through the following sections: Course Introduction Working in the VNC Scripting in Python Python Fundamentals Data Structures Conditions (if and else statements) Loops Working with DNA Sequence Data Manipulating Sequence Data Reading and Writing Files "],["01-intro.html", "2 Python for bioinformatics 2.1 Materials Covered in the Course 2.2 Inputting Commands 2.3 Pseudocode", " 2 Python for bioinformatics This is a course to explore and learn the fundamentals of programming in the Python language with a specific focus on how this tool can be used in bioinformatics. Python is a high level programming language enabling very rapid development of applications or scripts. It has a simple, easy-to-read syntax and is very accessible as a first or second programming language. Python has many pre-built modules and packages, allowing you to import lots of functionality, and avoid the need to \"re-invent the wheel\". Python is favoured by many programmers for the flexibility it affords and the speed at which it can be written. This course assumes absolutely no Python experience or prior programming experience in any other language. Over the next two days you will: Learn the fundamental components of a Python script Discover how to write, edit and run a Python script Understand and use variables Understand and choose data structures Use control structure (conditions and loops) Learn string manipulation Read and manipulate DNA sequence data Be able to read input files and write output files Have a plan on what to do next to further your knowledge. We will cover the theory behind Python concepts and terminology. Python is designed to be human-readable code and understanding the underlying processes is important. There will be lots of opportunity to practice writing Python. Practice will involve typing and running Python code whilst working through the workshop materials. This will allow you to see the output of Python commands and help you to understand how Python works. 2.1 Materials Covered in the Course After learning some of the basics of Python we will import some DNA sequence data and perform some common types of analyses. The focus is on learning the theory and the ways in which Python can be used, rather than the specifics of the analysis. Hopefully you will take away new skills that can be applied to your own data. In the supplementary material, we import and work with a different form of data often encountered by biologists; the comma delimited file. 2.2 Inputting Commands Commands are in the following font and colour and should be run in the VNC window following the link provided to you by the course coordinators. (Do not try to run the following, however.) This is an example of a command. 2.3 Pseudocode Sometimes to illustrate how a concept works, we will illustrate it with some pseudocode. This is a way of representing a concept in simple terms that can be understood without knowing the correct programming terminology or syntax. Do not try to run the pseudocode as Python will not understand it. "],["02_cluster_introduction.html", "3 Cluster Introduction 3.1 Logon Instructions 3.2 The Terminal Window 3.3 Load workshop data", " 3 Cluster Introduction 3.1 Logon Instructions For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent. You will now be in a logged-in Linux VNC desktop with a terminal window visible. You will see something as below. If you do not see something similar please ask for assistance. If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. Ensure you can see one whole terminal. During the first chapters of this session you will be working directly in the terminal window in the VNC. During the latter chapters we will open a plain text editor called Gedit. 3.2 The Terminal Window In our case the terminal window looks like the picture below. We are using the terminal window as our shell to interpret our commands to the kernel. Depending on your system and preferences it may look different. You're now ready to stat the workshop! 3.3 Load workshop data Before we get started, we need to copy across some data files to analyse later in the workshop. In the terminal window, issue the following commands to copy the data into your account: cd ~ cp -r /pub14/tea/nsc201/Python_course_data . "],["03_basic_scripting.html", "4 Scripting in Python 4.1 Introduction to commands and scripts 4.2 Issuing commands directly to the interpretator 4.3 A note on indentation 4.4 Tabs vs spaces", " 4 Scripting in Python 4.1 Introduction to commands and scripts There are two important components to programming in Python; the commands that are committed by the user, and the interpreter which receives and implements the commands. Each command can be thought of as a single instruction and these can be added together into a series of steps, called a script. Think about how a cooking recipe is often presented: Break a few eggs Make an omelette These are two distinct commands, but together they form a script for how to transform raw eggs into an omelette. In Python we can either issue commands one at a time to the Python interpreter or we can put them into a file and submit the whole script at once. 4.2 Issuing commands directly to the interpretator Open up the Python interpreter in the terminal window of the VNC with the following command. We are using Python version 3, the current version. python3 Python has opened correctly if you see the following message (or very similar): Python 3.9.6 | packaged by conda-forge (default, Jul 11 2021, 12:28:51) [GCC 9.3.0] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; The \"&gt;&gt;&gt;\" and blinking cursor shows that the Python command line interface is ready to receive commands. Try using the print command as shown below. Python is very particular about braces/brackets and quote marks. print(&quot;Hello, world!&quot;) print(&quot;I&#39;m excited to be learning some Python!&quot;) Get the current working directory using Python as we will need this for our scripts later. import os os.getcwd() This will return something like: '/pub39/tea/nsc206' (your number will be different though). Highlight this filepath text, including the quote marks, right click and 'copy'. So far we have issued simple instructions to Python but if we had lots of complex commands it would very quickly become cumbersome to type them in or to run it repeatedly. Throughout the workshop, we will build up more complex scripts and submit them to the interpreter to be run all at once. 4.3 A note on indentation Indentation refers to any spaces or tab characters at the beginning of a line of code. Indentation helps readability of code by helping to define code blocks dedicated to a single purpose. However, indentation in Python is mandatory and the interpreter will give an error if the indentation is wrong. The code editor we are going to be using today attempts to auto indent code but we still need to take care that the level of indentation in the script matches that in the workbook exactly. 4.4 Tabs vs spaces There is an active debate about whether tabs or spaces are more appropriate for indentation. For reference, one tab = 4 spaces. You can use either tabs or space, but you cannot use them interchangeably! Do not enter the below, this is just an illustration of how three levels of TAB indentation looks in a script. # Zero level of indentation # One level of indentation # Two levels of identation # Zero level of indentation "],["04_python_fundamentals.html", "5 Python Fundamentals 5.1 Operators 5.2 Comments 5.3 Variables 5.4 Classes of variable 5.5 Transforming variables 5.6 Functions and methods 5.7 Recap", " 5 Python Fundamentals This chapter covers some of the fundamental concepts of scripting in Python. An understanding of how to use operators, variables, and functions will give a good grounding in how the language works and allow you to develop your own methods and code. You definitely do not need to memorise all the information here as all of these concepts will be explored more in the rest of the tutorial. The best way to learn how various aspects of the Python language work is by doing rather than by reading. Consider coming back to this page later if you want to remind yourself of how a particular operator works or how to define a function. For each of the following sections of example code, enter them directly into the Python interpreter and press enter after each line. 5.1 Operators Python allows the use of the usual arithmetic operators and follows the traditional rules of mathematical precedence (BODMAS). The maths operators are: + (addition) - (subtraction) * (multiplication) / (division) ** (power) //(integer division) 5.2 Comments It is often useful to include human-readable comments in your scripts and code. Comments in Python are indicated by the hash symbol (#). Anything to the right of the hash is considered a comment and is ignored by the interpreter. When working through the workbook there is no need to add the comments into the commands or scripts. # This line is a comment print(&quot;This section will print&quot;) # This section is ignored 5.3 Variables Variables are used to store information which can then be referenced or manipulated later. They are also useful to label data with a descriptive name which is easily read by a human. You can think of a variable as a 'container' to hold a piece of information. Variables are assigned a value using the equals (=) character. Variable names: Start with either a letter or an underscore Only contain alphanumeric characters (and underscores) Are case sensitive. Python supports several classes (or types) of variables including strings, integers, floats, and booleans. 5.3.1 Strings Strings are used to store alphanumeric text. A string is defined by enclosing the text with either single or double quotes. Enter the following into the Python terminal, pressing enter after each line. Here we define two string variables, and then retrieve them again by using their name, or identifier. DNA_string = &quot;GCACAAACC&quot; amino_acids = &quot;ARG VAL TRP&quot; DNA_string amino_acids 5.3.2 Integers Integers are used to store whole numbers. These should not be declared with quote marks otherwise they will be stored as a string. Enter the following: my_int = 7 my_int 5.3.3 Floats (floating point numbers) Floating point numbers are used to store real numbers (I.e. a number written with a decimal point dividing the integer and the fractional parts). Enter the following: my_float = 7.0001 another_float = 345.765 yet_another_float = -5.423e+19 my_float another_float yet_another_float 5.3.4 Booleans Booleans are a special type of variable than can represent one of two values: True or False. You can compare any two values in Python and get a result of either True or False. To check if two values are equal we use double equals: == To check if two values are not equal we use: != Greater than (&gt;) or less than (&lt;) also work. Enter the following: a_bool = 10&gt;9 a_bool another_bool = &quot;ATGCA&quot; != &quot;ATGCA&quot; another_bool yet_another_bool = 9&gt;42 yet_another_bool 5.4 Classes of variable Every variable in Python has a class. These are the characteristics we described above: String (&lt;class 'str'&gt;) Integer (&lt;class 'int'&gt;) Float (&lt;class 'float'&gt;) Boolean (&lt;class 'bool'&gt;) Unlike some other languages, you do not need to tell Python which class a variable should have. Python will try to figure it out based on the value assigned. You can check the class of a variable by passing it to the type() function: variable1 = &quot;a piece of text&quot; type(variable1) variable2 = 5 type(variable2) variable3 = 7.0001 type(variable3) variable4 = True type(variable4) 5.5 Transforming variables Variables can be transformed from one type to another provided the value can be coerced into the new data type (I.e. you could not transform a string of text to a floating point number). To transform a float to an integer using the int() function (note the loss of precision): a_float = 17.45 int(a_float) To transform an integer to a string using the str() function: an_integer = 783473 str(an_integer) You can also transform to a floating point using float(). 5.6 Functions and methods Functions and methods are groups of instructions that together perform a specific task. This may be a task that you need to run repeatedly on your data and by storing these instructions in a single function, you only need to enter the code once and simply re-use it each time. A function returns a value after it has performed the specific task. 5.6.1 Running a function A function is a distinct piece of code which requires data to be sent to it in order to run. To run a function you need to give the name of the function followed by a pair of braces with the desired input within the braces. We have already been using some functions: the int() and str() functions. For example, we might want to find the length of a string of nucleotides. In this instance, we can use the built-in len() function on the string: (use any string of 'ACGT' you like, no need to copy this one exactly!) DNA = &quot;ACGTGTTATATGCGCGTTAGTGTAGTCGATC&quot; # print the length of the string len(DNA) 5.6.2 Running a method Methods are very similar to functions in that they process an input in some manner. They differ in that methods are associated with a particular data class (string, for example) and are called via the data itself. Methods are called using a different syntax; the variable is followed by \".\" and the name of the method with a pair of braces. First let's try a couple of methods associated with manipulation of string data: # define a string called sequencers sequencers = &quot;illumina,oxford_nanopore,pac-bio&quot; # the upper() method converts string variables to uppercase sequencers.upper() # split() chops a string up wherever the specified sub-string occurs (comma in this case) sequencers.split(&quot;,&quot;) We can also use built-in methods for some simple analysis using the \"DNA\" string generated earlier. For example, the built in count() method can be used to count the number of each nucleotide in the string. DNA.count(&quot;A&quot;) DNA.count(&quot;C&quot;) DNA.count(&quot;G&quot;) DNA.count(&quot;T&quot;) By using the len() function and the count() method, we can calculate the GC content of the DNA sequence: ## count the number of G and C in the sequence G_total = DNA.count(&quot;G&quot;) C_total = DNA.count(&quot;C&quot;) # calculate the percentage of the sequence that is GC (G_total + C_total)/len(DNA)*100 5.7 Recap We have described and tried some of the major types of variables which are used in Python. All variables have a class and this can determine which functions and methods we can apply to them. We have also explored functions (function_name(variable)) and methods (variable_name.function_name()), and can now apply them to variables. There was lots of information in this chapter. You don't need to memorise it. Please refer back to this chapter at any point. "],["05_data_structures.html", "6 Data Structures 6.1 Lists 6.2 Subsetting data 6.3 Set 6.4 Transform a list to a set 6.5 Dictionary 6.6 Recap", " 6 Data Structures We now know the different types of data points that Python can hold, whether they are integers, floats, strings of text, or boolean values. Typically, data points do not exist in isolation but instead are in a group. For example, consider a set of measurements of the peak day temperature over a period of a week. A group of data points such as these can be stored in a list. 6.1 Lists Lists are used to store multiple items within a single variable. Lists allow duplicate values and once defined are always in the same order (ordered). Additional items can be added to the list and by default will appear at the bottom. Finally, lists are indexed meaning that we can easily retrieve the 1st, 2nd....nth item from the list. 6.1.1 Add numeric data to a list We define a list like any other variable. To add multiple values to the list we enclose them in square braces and include a comma between each value. Add the following (made up) data representing some fold-change values generated by an RNA-Seq type experiment. gene_fold_change = [0.25, -0.42, 0.62, 1.27, -0.5, 0] To add an additional value to the end of the list, we can use the append() method: Reminder: Each unique method can only be used on one type of data. The append() method can only be used with lists. gene_fold_change.append(0.33) gene_fold_change 6.2 Subsetting data A value from the list can be retrieved by the position it occupies in the list. This selection can be carried out using square braces. This process of selecting a certain portion of data is known as subsetting. One of the most vital aspects to grasp for Python is that data structures start at position zero. This can be confusing but is a common feature of many programming languages. To select the first entry in the list, we therefore pass position \"0\" in the square braces: # Get the first value: gene_fold_change[0] # Get the fifth value: gene_fold_change[4] We can also use a negative value to count from the other end of the list. I.e. to get the last value in the list. # Get the last value (without knowing the length of the list) gene_fold_change[-1] The same technique also works to select a range of values from the list. The upper and lower position of the range to be selected given in square brackets, separated by a colon. When using a range in this manner the last number is exclusive. In other words all the positions except the last one will be selected. # subset the third and fourth values gene_fold_change[2:4] # subset the first to fifth value gene_fold_change[0:5] # subset the first values gene_fold_change[0:1] To subset everything from a certain position onwards, leave the upper value blank. This also works to select everything before a certain position. # subset the sixth value to the end gene_fold_change[5:] # subset everything up to (but excluding) the third value gene_fold_change[:2] 6.3 Set A set is similar to a list except that it can only hold unique values. A set also differs from a list in that a set does not retain the order of the elements (unordered). Sets are defined using the curly braces ({}). Define a set containing plants found in a (fictional) pollen metabarcoding experiment. plants_set = {&quot;Dandelion&quot;, &quot;Buttercup&quot;, &quot;Clover&quot;, &quot;Poppy&quot;} plants_set A second round of analysis found an extra plant species. We can add a new element to our set using the add() method. plants_set.add(&quot;Honeysuckle&quot;) plants_set Combining data from more samples might mean that duplicate plants were detected in the data. Adding plants that are already in the set has no effect as it cannot hold duplicate values. plants_set.add(&quot;Buttercup&quot;) plants_set 6.4 Transform a list to a set Sometimes we have a list of non-unique values and it is useful to extract the unique values. We can do this by transforming a list into a set. Add some gene IDs to a list: gene_IDs = [&quot;Agl&quot;, &quot;Pygm&quot;, &quot;Pgm2&quot;, &quot;Ugp2&quot;, &quot;Pygm&quot;, &quot;Pgm2&quot;] # Note that a list can hold duplicate values gene_IDs We can transform the list into a set using the function set(): gene_set = set(gene_IDs) # The duplicates have been removed gene_set 6.5 Dictionary The third data structure we will learn is the dictionary. A dictionary is an ordered data structure which holds pairs of values; a key and a value. For example, say we want to store the gene identifiers alongside our fold-change data that we recorded earlier in a list. Each gene identifier/fold-change pair is the key/value of the dictionary. Dictionaries are also defined using the curly braces but a pair of values are given each time, separated by a colon. Enter the following. Note: You need to press enter after each line. gene_fold_change = { &quot;Agl&quot; : 0.25, &quot;Pygm&quot; : -0.42, &quot;Pgm2&quot; : 0.62, &quot;Ugp2&quot; : 1.27, &quot;Gys1&quot; : -0.5, &quot;Phka1&quot; : 0, &quot;Phkg1&quot; : 0.33 } gene_fold_change Dictionaries are indexed meaning that individual records can be retrieved very quickly (important if you are working with very large dictionaries). We can retrieve the information for \"Gys1\" by using the identifier as the key and the dictionary will then return the value. gene_fold_change[&quot;Gys1&quot;] New values can be added to the dictionary in a similar way to how they are retrieved: gene_fold_change[&quot;ZT1&quot;] = 3.2 gene_fold_change[&quot;ZT1&quot;] The pairing up of values in dictionaries is extremely useful if you are working with DNA sequence files (Fasta or FastQ). It offers an easy way of matching up the read identifier with the DNA nucleotide data, for example. Once indexed, the individual records can then be accessed extremely quickly. 6.6 Recap Lists hold an ordered catalogue of values. Values can be accessed by their position in the list (remember to count from zero!). Sets can only hold unique values. Dictionaries hold pairs of values (key and value) and can be used to quickly access individual records, even when they are extremely large. We are going to be using these data structures to look at and manipulate DNA sequence data specifically, but the principles apply to any datasets stored in these structures. "],["06_conditions.html", "7 Python Conditions: 'if' and 'else' statements 7.1 If statements 7.2 If else statements 7.3 Recap", " 7 Python Conditions: 'if' and 'else' statements A powerful feature of most programming languages is the ability to compare values/variables and to make decisions based upon the outcome. This type of behaviour is achieved using logical conditions. The conditions allowed depend on the type of data you are comparing. For example, you cannot use greater than or less than on string variables directly (although you could compare their lengths). Python supports the following logical conditions: Equals: a == b Does not equal: a != b Less than: a &lt; b Less than or equal to: a &lt;= b Greater than: a &gt; b Greater than or equal to: a &gt;= b Try the following: a = &quot;ATTGCG&quot; b = &quot;AGCGAT&quot; a==b len(a) == len(b) These logical conditions are most typically used in if statements. 7.1 If statements By testing whether certain comparisons evaluate as either True or False, we can change the flow of our programs. An if statement is a programming statement which acts like a switch. If the statement is True, the switch is activated. If the statement is False, the switch remains inactivated. A generic if statement using pseudocode would have the following structure: If a condition is met: Perform a task 7.2 If else statements We can also include an action for when the condition has not been met using else. The else statement works in conjunction with the if and offers a different action if the condition evaluated to False. If a condition is met: Perform a task Else: Do something else For example, we might have a string of nucleotide data which we want to move through, translating any thymine (T) bases into uracil (U). The other three bases (A, C, and G) do not require any processing. The if and else statements to do this would look something like (again, using pseudocode): If the current nucleotide is \"T\": Print \"U\" Else: Print the current nucleotide We will explore using loops to move through data more in the next chapter. 7.3 Recap If and else statements can be used to make decisions in our programs by comparing values. This might be to check if two strings are the same, two lists contain the same number of items, or a string of nucleotide data has 100 or more bases. We can think of them as switches. Often we need to make these if/else comparisons for every item in a data structure and to do this we can use loops. "],["07_scripting_in_python.html", "8 Scripting in Python 8.1 Open a plain text editor 8.2 Running a script from the terminal", " 8 Scripting in Python At this point we are going to stop issuing commands directly to the Python interpreter and instead build up a Python script. In the terminal window, exit from the interactive Python session: quit() 8.1 Open a plain text editor In the terminal window, run the following to open up an instance of the 'Gedit' text editor. gedit &amp; Gedit is a 'plain text editor' which means it will not add any hidden characters or formatting to the document. It is important to not to edit code in a word processor such as Microsoft Word. You should still have your current working directory on the clipboard. (If you don't, run os.getcwd() in the terminal window and copy it again) Paste this into the Gedit window and define a variable wd (working directory) using a version of the following (your filepath will be slightly different). wd = &#39;/pub39/tea/nsc014&#39; print(&quot;Hello, world!&quot;) print(wd) Save the script into the directory of your username (something like nsc014) and name it 'script01.py'. See the image below to make sure it is being saved in the correct place. This is important because we need to tell Python where the script is. 8.2 Running a script from the terminal Return to the terminal window. You may need to clear some text from the terminal leftover from when we launched Gedit; do this with ctrl + c. Run the Python script we have just saved with the following: python3 script01.py This process of editing the script file in Gedit, saving, and running the script in the terminal will form the basis of the rest of the tutorial. Return to the Python script and comment (#) out the two print statements. We will continue working in this same script file in the next section. wd = &quot;/pub39/tea/nsc014&quot; #print(&quot;Hello, world!&quot;) #print(wd) "],["08_loops.html", "9 Loops 9.1 Data Structure Recap 9.2 Introduction To Loops 9.3 For Loops 9.4 For Loop Example 9.5 Use a for loop to complement a DNA sequence 9.6 Use a for loop to reverse-complement a DNA sequence 9.7 While loops 9.8 Further control statements 9.9 Recap", " 9 Loops 9.1 Data Structure Recap We now have some knowledge of Python data structures (lists, sets, and dictionaries), what type of data they hold, and how we can access the elements within them. How might we apply something to each element of a list? Perhaps we need to count the number of characters in each entry in the list? 9.2 Introduction To Loops Where we need to apply the same function to every item in a data structure, we can use a loop. This means that we do not need to manually apply the function to every item in the list, one at a time. There are several types of loop; we will cover some of the most important in this section. 9.3 For Loops One of the most important and most common types of loop is the for loop. The for loop runs through a set of variables (such as those in our list) and applies a command (or series of commands) to each element once. This is the loop that you will most often encounter. Imagine you have a bag of 10 potatoes that you need to peel and put into a pot. Using some pseudocode we can imagine how this script might look: from bag_of_potatoes pick up potato_01 peel potato_01 put potato_01 into pot from bag_of_potatoes pick up potato_02 peel potato_02 put potato_02 into pot ....(and so on) You can see how inefficient this code is, especially if it was a particularly large bag of potatoes! Instead, we can use a for loop to recycle the code. for each potato in bag_of_potatoes: peel potato put potato into pot This loop would run until the bag of potatoes is empty, achieving the job in just three lines of code. This pseudocode is actually very similar to the required Python syntax. The generic format of a for loop is: for &lt;value&gt; in &lt;data_structure&gt;: do something Note the colon (:) starting the loop and the tab indent of any commands inside the loop. 9.4 For Loop Example As we have seen, for loops are extremely useful when we have a lot of values (for example, in a list) and we need to apply some commands to all of them. As an example, we will take a string of DNA nucleotides and use a loop to generate the complement and reverse complement sequences. Add a string of nucleotides to the script (script01.py) in Gedit (you can use any random nucleotide sequence - no need to copy this one exactly), and code a for loop to move through the DNA string, printing each base to the screen. Save and run the script. Remember to tab indent the lines inside the for loop. DNA_string = &quot;ATTCGAAGTCGTGTAGTACCGCGTATA&quot; # loop through each base in the string for base in DNA_string: # print the current base print(base) We can see from the output that the loop allows us to process each base in the string separately; in this case by printing them individually. 9.5 Use a for loop to complement a DNA sequence Next, let's use this loop functionality to do something useful to each base such as translate each nucleotide to the appropriate complement base. For this, we will use a dictionary to swap each base for the complement. Recall that a dictionary has a key and value for each entry. We can define the 'standard' base as the key, and the 'complement' as the value. First create the dictionary holding the complementary pairs of bases. In the script this needs to come before the for loop. Modify the above to the following: Note That each of the four lines of the dictionary need to have a leading TAB character. DNA_string = &quot;ATTCGAAGTCGTGTAGTACCGCGTATA&quot; # define our dictionary of complements complements = { &quot;A&quot; : &quot;T&quot;, &quot;T&quot; : &quot;A&quot;, &quot;G&quot; : &quot;C&quot;, &quot;C&quot; : &quot;G&quot; } # loop through each base in the string for base in DNA_string: # print the current base print(base) At present, the print() function is still printing the base as it appears in the original string. We need to change the loop so the original nucleotides (base) are passed to the dictionary and the appropriate complementary bases are returned. Modify the loop as follows: # loop through each base in the string for base in DNA_string: # print the current base #print(base) # print the complemented base print(complements[base]) Save, and run the script to verify that the complementary base is printed fo each iteration of the loop. Finally, we can build up an 'output string' to format the complemented sequence. The complemented base is added to the variable output_sting each time and the whole string is printed at the end. #Create and empty string to add the complemented bases to output_string = &quot;&quot; # loop through each base in the string for base in DNA_string: # print the current base #print(base) # print the complemented base #print(complements[base]) # add the complemented base to the output string output_string = output_string + complements[base] # print the input and output strings for comparison print(DNA_string) print(output_string) Save, and run the script to check the output sequence is as expected. 9.6 Use a for loop to reverse-complement a DNA sequence To generate the reverse complement we can use Python's built in reversed() function to loop through the original DNA sequence in the reverse order. Comment out the original for loop line, and replace with the following: # comment out the original for loop #for base in DNA_string: # replace with for base in reversed(DNA_string): Running the script now will produce the reverse complement of our original DNA sequence. 9.7 While loops The other type of loop you might encounter is the while loop. A while loop continues to run while a statement remains True. For example, returning to our bag of potatoes, a while loop for the same job might look like this: while bag_of_potatoes is not empty : peel potato put potato into pot This loop would run until the last potato has been prepared, at which point the while statement would return False and the loop would be stopped. The generic format of a while loop is as follows: while &lt;condition&gt; : do something While loops are much less commonly used and we will not spend any more time on them in this session. Hopefully you can see the difference between a for loop and a while loop and have an idea of how they run. 9.8 Further control statements You can control loops further using break, continue and pass statements although we are not covering these in this tutorial as they are much less common. You can find good resources covering Python control statements online. 9.9 Recap Loops are really useful when we need to perform the same task, or commands, over-and-over again. Where we have data stored in a data structure such as a list, we can apply something to everything in the list using a for loop. This is an efficient way to code as it means we do not need to duplicate the instructions. "],["09_DNA_sequence_data.html", "10 Reading sequence data 10.1 SeqIO 10.2 Reading a FASTQ DNA data file into Python 10.3 The FASTQ format 10.4 Read a FASTQ file into Python 10.5 Setting up a script to use BioPython 10.6 Read a fie of sequence data 10.7 Modifying reads 10.8 Count reads", " 10 Reading sequence data Biopython is a suite of libraries and tools designed for analysis of biological datasets in Python, largely centered around the processing of DNA sequence data. You can find much more information about Biopython on the website. During this section on Biopython we are going to be using the SeqIO module. The knowledge and approaches from the previous chapters will now be used to process some genomic DNA sequence data. 10.1 SeqIO The SeqIO tools are the main Sequence Input/Output interface for Biopython. It provides a relatively simple, uniform interface for working with various types of DNA sequence files. The module reads raw sequence files (such as .FASTQ files you will likely receive from your sequencing facility) and converts them to a Python readable format; a SeqRecord class. 10.2 Reading a FASTQ DNA data file into Python One of the most common types of DNA sequence data files you will be working with is the FASTQ file. The FASTQ file contains multiple DNA sequences, each one might be a single short read from an Illumina sequencer and the file can contain thousands or millions of sequences depending on which sequencer was used to produce it. The FASTQ has a very specific format and holds three important pieces of information. 10.3 The FASTQ format The file has a repetitive structure of four distinct components: A unique sequence identifier (ID) The DNA nucleotide sequence A small spacer The quality score associated with each nucleotide The ID line always starts with the @ symbol and this is followed by a string of numbers and letters giving details such as the sequencer that produced the data, the run number, and an index adapter used on the sample. The DNA nucleotide sequence is shown as a string of ATGC characters. There is a spacer consisting of the \"+\" character which separates the sequence from the quality scores. The quality score associated with each nucleotide above is ASCII encoded with each symbol representing a quality score from 0 to 40 (higher being better). This line is not meant to be easily human-readable. An example of a single unit of this four line repeat can be seen below: @MISEQ:42:000000000-A8DD3:1:1101:15046:1468 TTCACATCCTGACCATTCAGTTGAGCAAAATAGTTCTTCAGT + CCFFFFFGHHHHJIJJJJIJJJIIJJJJIIIJJGFIIIJEDD 10.4 Read a FASTQ file into Python Scenario: You have just received some FASTQ formatted data back from your sequencing facility. The data was generated using a shotgun, whole-genome sequencing approach to sequence the genome of the undulate ray (Raja undulata). We are going to read the data into Python, ready to do some data processing and analyses. 10.5 Setting up a script to use BioPython Open a new file in Gedit by clicking the \"Create a new document\" button () at the top-left. We need to load a couple of Python libraries: Biopython (a suite of bioinformatics focused Python tools) ...and... re (allows us to perform searches using wildcards and special characters). Add the following to the top of the script. from Bio import SeqIO import re You should hopefully still have the current working directory on your clipboard. Set a variable called 'wd', (working directory) to the filepath on your clipboard by adding a version of the following: wd = &quot;/pub14/tea/nsc201&quot; 10.6 Read a fie of sequence data We are going to use SeqIO (which stands for sequence in/out) and the parse function which splits the FASTQ file into its separate components. We store the information on which file to parse in the variable called R_undulata_R1_data. SeqIO.parse requires two arguments: The filepath to the file which is to be read. The format of that file. R_undulata_data = SeqIO.parse(wd + &quot;/Python_course_data/R_undulata_WGS.fastq&quot;, &quot;fastq&quot;) We can then look through the file using a for loop. Each of the four-unit repeats of the FASTQ file is read as a separate 'record' and we can access them in the script. To access the ID line of each record, we use '.id' and to access the sequence we use '.seq'. Each of these elements can be printed in the terminal using an appropriate print statement. for record in R_undulata_data: print(record.id) print(record.seq) Save the new script as 'script02.py' and run it from the terminal window to print the ID and sequences. 10.7 Modifying reads We can perform operations on each of these elements. For example, Biopython has a built in translate() method to convert nucleotide sequence into protein sequence (although bear in mind that we are not considering reading frames and we likely have lots of non-coding data). Modify the for loop above to the following: for record in R_undulata_data: print(record.id) #print(record.seq) print(record.seq.translate()) Save the script and run it on the terminal. 10.8 Count reads We can implement a counter to tally the total number of reads in the file. Modify the for loop above to the following (you do not need to add the comments however): ## start a counter to track how many reads counter = 0 for record in R_undulata_data: #print(record.id) #print(record.seq) #print(record.seq.translate()) # increase the counter by 1 each time it sees a new read counter = counter + 1 # save the number of raw sequences for use later number_raw_reads = counter print(&quot;Raw sequence file has &quot; + str(number_raw_reads) + \\ &quot; sequence records.&quot;) Note that we need to convert the number_raw_reads to a string type for the print statement to work using the str() function. Python will not print variables of different types in the same statement. "],["10_DNA_conditions.html", "11 Using Conditions to Modify DNA Data 11.1 Remove short reads 11.2 Remove PCR primers 11.3 Recap", " 11 Using Conditions to Modify DNA Data Suppose we want to filter the raw sequence reads by some parameter. For example we could remove reads of a certain length or remove sections of a sequence such as PCR primer sequences. We can use our knowledge of loops and conditions to perform these tasks. 11.1 Remove short reads Using what we know, we can write a script to remove reads below a certain read-length threshold from a FastQ file. Starting a new section at the bottom of the script, re-specify where SeqIO.parse should read the file. We need to do this because the SeqIO.parse object gets 'consumed' in the loop we built during the last section. To loop again, and do something else, we need to re-establish the SeqIO.parse connection. R_undulata_data = SeqIO.parse(wd + &quot;/Python_course_data/R_undulata_WGS.fastq&quot;, &quot;fastq&quot;) Suppose we want to find and ultimately remove short reads from the data. As our loop moves through the file, we can count the number of nucleotides in each read using the Python function len(). for record in R_undulata_data: print(len(record.seq)) Save and run the script to print the lengths of all the sequences. We can see there is some variation in the length of reads in the file and can use an if statement to select only those reads with a read length of &gt; 100 nucleotides. Modify the loop above to the following: # initialise an empty list to hold the records that we want to keep wanted_sequences = [] for record in R_undulata_data: #print(len(record.seq)) if len(record.seq) &gt; 100: # add the record to the list of records we want to keep wanted_sequences.append(record) print(&quot;Found &quot; + str(len(wanted_sequences)) + &quot; reads &gt;100bp in length.&quot;) Save and run the script. You will now have 2 lines of text as output, one saying the number of raw reads, and one saying the number of reads with a length &gt;100bp. We used the len() function to see how many records are contained in the wanted_sequences. 11.2 Remove PCR primers Often you may want to check your sequence file for PCR primers, and remove them when they are found. Using a for loop to move through the sequence file, we can check each DNA sequence read for the presence of a pre-defined primer sequence. If it is present, we'll remove it. We are going to check for the presence of the 13 nucleotide PCR primer \"ACACTGCTGATCG\" at the start of the reads using the startswith() method. This method checks whether a string starts with a particular sub-string and returns True or False. It is very useful for checking for primer sequences in our data. The input for this primer removal step will be the 'wanted_sequences' variable from above (those of &gt;100bp in length). Continue from the bottom of your \"script2.py\". Note: Below is the primer in triplet bases for ease of reading. Ensure you type it as one string with no spaces. ACA CTG CTG ATC G # loop through the sequence records for record in wanted_sequences: # check whether the sequence starts with the primer sequence if record.seq.startswith(&quot;ACACTGCTGATCG&quot;): print(record) Save and run your script. The code above prints a lot to the terminal. In each record, look at the lines starting \"Seq\" and note that every sequence does indeed start with the primer we specified above. This indicates that there are lots of sequences with the primer sequence present. Now that we have identified their presence, let's trim them off the start of the reads. Modify the block of code above to the following: # define a list to hold the trimmed sequences trimmed_sequences = [] #Start counter to count number of reads with primer counter = 0 # loop through the sequence records for record in wanted_sequences: # check whether the sequence starts with the primer sequence if record.seq.startswith(&quot;ACACTGCTGATCG&quot;): #print(record.seq) # if it does, subset the read from position 14 onwards # and store in trimmed_sequences trimmed_sequences.append(record[13:]) counter = counter + 1 else: # if it doesn&#39;t have the primer, # retain the whole read and store in trimmed_sequences trimmed_sequences.append(record) number_sequences_trimmed = counter print(&quot;Found and trimmed &quot; + str(number_sequences_trimmed) + \\ &quot; reads with PCR primer present at start.&quot;) Save and one the code one more time to see your three lines of information printed to screen. 11.3 Recap Using our knowledge of reading FASTQ files, looping through the data, and using conditions to check certain characteristics of the data we have been able to filter out short-reads and also remove primer contamination. We are starting to build a pipeline! We will learn to write data out and store it in a new file in the next chapter. "],["11_reading_and_writing.html", "12 Reading and writing files 12.1 'open' 12.2 'with' 12.3 Read a data file 12.4 Write data to a file 12.5 Write out the filtered Undulate ray sequence data 12.6 Recap", " 12 Reading and writing files Often we want to read from a data file, perform some task with the data, and write out another file. To read/write a file in Python we open a data stream using a statement such as: (don't add this line to the script) with open(path_to_file, &quot;open_mode&quot;) as input_file: There are two parts to consider: open(path_to_file, mode) with(...&lt;input-file&gt;...) as input_file: 12.1 'open' The 'open' statement asks the Python interpreter to make a link to the specified file and open a data stream. We need to specify the mode by which the file is opened. The most common modes are: 'w' - WRITE: Open for writing. If the file doesn't exist, it will be created. If it does exist, it will be replaced by a new, empty file. 'r' - READ: Open an existing file for reading. 'a' - APPEND: Open for reading and writing. If the file doesn't exist, it will be created. If it does exist, new data will be added to the end of the existing file. There are other modes but these three cover the majority of file tasks. 12.2 'with' The with statement, which is wrapped around the open() statement, gives this data stream a variable name (input_file). It also performs important 'under-the-hood' cleaning up that stops files from becoming corrupted. 12.3 Read a data file Open a new script in Gedit. Again add the location of our working directory and load the SeqIO library. Add the following to open a data stream to read the provided file 'patients_data.csv'. Then add a for loop to print each line of the file. Save the script as \"script03.py\" and run it from the terminal. wd = &quot;/pub14/tea/nsc201&quot; from Bio import SeqIO with open(wd + &quot;/Python_course_data/patients_gut_data.csv&quot;, &#39;r&#39;) as input_file: for row in input_file: print(row) The data from the file is printed in the terminal window (we will learn to organise this output in a more usable way in the supplementary material). 12.4 Write data to a file Modify the script above to add a second data stream, opening a second file for write access. Again, we loop through the input_file however this time for each row in the file, we prepend the line of data with the string \"Study_2022,\", and write this new data line to the output file using the .write() method. with open(wd + &quot;/Python_course_data/patients_modified.csv&quot;, &#39;w&#39;) as output_file: with open(wd + &quot;/Python_course_data/patients_gut_data.csv&quot;, &#39;r&#39;) as input_file: for row in input_file: #print(row) output_file.write(&quot;Study_2022,&quot; + row) In the terminal window, run the following to view first few lines of the new \"patients_modified.csv\" file. You will see that each row in the data now starts with the \"Study_2022\" string. # In the terminal (not the Python script) cd ~ head Python_course_data/patients_modified.csv 12.5 Write out the filtered Undulate ray sequence data Returning to our example data relating to the undulate ray, we have a list of sequence records (trimmed_sequences) which have passed our filters and we now want to write out the FASTQ file so that it might be further analysed using another piece of software. Return to the script in Gedit that was concerned with the FastQ data (named script02.py). At the bottom of the script, we will open up a data stream to a new output file, and then used SeqIO's built in write method to write out data, specifying that we want a FASTQ format file: with open(wd + &quot;/Python_course_data/R_undulata_filtered_seqs.fastq&quot;, &#39;w&#39;) as output_file: SeqIO.write(trimmed_sequences, output_file, &quot;fastq&quot;) This trimmed, filtered file would now be ready to go into whichever subsequent analysis was desired. 12.6 Recap To read or write files we need to open a data stream using the with and open functions. Each file can be opened in one of several modes; either write, read, or append, depending on what you need to do. Once files are written to the disk they are available to use in further analyses or other pieces of software. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
