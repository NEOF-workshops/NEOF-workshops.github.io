# Data Structures {#data_structures}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/python_data_structure.png", auto_pdf = TRUE)
```

We now know the different types of data points that Python can hold, whether
they are __integers__, __floats__, __strings__ of text, or __boolean__ values.

Typically, data points do not exist in isolation but instead are in a group. 
For example, consider a set of measurements of the peak day temperature over
a period of a week. 
A group of data points such as these can be stored in a __list__.

Use the same notebook (__"01-Fundamentals"__) and add the following __markdown cell__:

```{python, eval=FALSE}
## Data structures
### Lists
```

From now on you won't be instructed to make __markdown cells__, instead use your judgement and make your own.

## Lists
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/shopping_list.png", auto_pdf = TRUE)
```

__Lists__ are used to store multiple items within a single __variable__. 
__Lists__ allow duplicate values and once defined are always in the same order (__ordered__).
Additional items can be added to the __list__ and by default will appear at the bottom.
Finally, __lists__ are indexed meaning that we can easily retrieve the 1st, 2nd....nth item from the __list__.

We define a __list__ like any other __variable__. 
To add multiple values to the __list__ we enclose them in square braces (`[]`) and include a comma between each value.

Create the __list__ in the below code block. 
It consists of made up fold-change values generated by an RNA-Seq type experiment.

```{python, eval=FALSE}
gene_fold_change = [0.25, -0.42, 0.62, 1.27, -0.5, 0]
gene_fold_change
```

To add an additional value to the **end** of the __list__, we can use the `.append()` __method__:

__Reminder__: Each unique __method__ can only be used on one type of data. The `append()` method can only be used with __lists__.

```{python, eval=FALSE}
gene_fold_change.append(0.33)
gene_fold_change
```

You can create __lists__ containing strings.

```{python, eval=FALSE}
taxonomy_levels = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"]
taxonomy_levels
```

You can even create __lists__ with multiple data __classes__.

```{python, eval=FALSE}
numerals = ["I", 1, "V", 5, True]
numerals
```

## Subsetting data
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/noun-list-5537185.png", auto_pdf = TRUE)
```

A value from a __list__ can be retrieved by the **position** it occupies in the list.
This selection can be carried out using square braces (`[]`).

This process of selecting a certain portion of data is known as __subsetting__.

One of the most vital aspects to grasp for Python is that data structures start at position __zero__.
This can be confusing but is a common feature of many programming languages.

### Single values
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/one_hand.png", auto_pdf = TRUE)
```

To select the first entry in a __list__, we therefore pass position "0" in the square braces:

__Reminder__: Create your own informative __markdown cells__.

```{python, eval=FALSE}
#Get the first value
gene_fold_change[0]
```
```{python, eval=FALSE}
#Get the fifth value
gene_fold_change[4]
```

We can also use a negative value to count from the other end of the __list__. I.e. to get the last value in the __list__.

```{python, eval=FALSE}
#Get the last value (without knowing the length of the list)
gene_fold_change[-1]
```

### Multiple values
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/four_hand.png", auto_pdf = TRUE)
```

The same technique also works to select a range of values from the __list__. The upper and lower position of the range to be selected given in square brackets, separated by a colon (`X:Y`). 

When using a range in this manner:

- The first number (`X:`) is inclusive. 
- The last number (`:Y`) is exclusive.

In other words all the positions except the last one will be selected.

Try out the following code blocks to see this in practice.

```{python, eval=FALSE}
#Create a list containing the numbers 1 to 7
one_to_seven = [1,2,3,4,5,6,7]
one_to_seven
```
```{python, eval=FALSE}
#Subset the third and fourth values
one_to_seven[2:4]
```
```{python, eval=FALSE}
#Subset the first to fifth values
one_to_seven[0:5]
```
```{python, eval=FALSE}
#Subset the first value
one_to_seven[0:1]
```

If you find this confusing you are not the only one so please don't feel bad about it.
It will take time and effort for most people to get used to this.

To subset everything from a certain position onwards, leave the upper value blank. This also works to select everything before a certain position.

```{python, eval=FALSE}
#Subset the sixth value to the end
one_to_seven[5:]
```
```{python, eval=FALSE}
#Subset everything up to (but excluding) the third value
one_to_seven[:2]
```

__Lists__ are incredibly useful but have their limitations so it is good to learn other data structures.

## Set
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/uk_plants.png", auto_pdf = TRUE)
```

A __set__ is similar to a __list__ except that it can only hold __unique__ values.
A __set__ also differs from a __list__ in that they do not retain the order of the elements (unordered).

__Sets__ are defined using the curly braces (`{}`). Define a __set__ containing the plants found on the one pound coin. 

```{python, eval=FALSE}
plants_set = {"Leek", "Rose", "Shamrock"}
plants_set
```

We forgot the Scottish thistle! 
We can add a new element to our __set__ using the `.add()` __method__.

```{python, eval=FALSE}
plants_set.add("Thistle")
plants_set
```

In real world analysis combining data from more samples might mean that duplicate plants were detected in the data. 
Adding values that are already in the __set__ has no effect as it cannot hold duplicate values.

```{python, eval=FALSE}
plants_set.add("Shamrock")
plants_set
```

## Convert a list to a set
```{r, fig.align = 'center',out.width= '65%', echo=FALSE }
knitr::include_graphics(path = "figures/list_to_set.png", auto_pdf = TRUE)
```

Sometimes we have a __list__ of non-unique values and it is useful to extract the unique values. We can do this by transforming a __list__ into a __set__.

Add some gene IDs to a __list__.

```{python, eval=FALSE}
gene_IDs = ["Agl", "Pygm", "Pgm2", "Ugp2", "Pygm", "Pgm2"]
gene_IDs
```

We can transform the __list__ into a __set__ using the __function__ `set()`.

```{python, eval=FALSE}
gene_set = set(gene_IDs)
gene_set
```

## Dictionary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/dictionary.png", auto_pdf = TRUE)
```

The third data structure we will learn is the **dictionary**. A __dictionary__ is an
ordered data structure which holds **pairs** of values; a **key** and a **value**.

For example, say we want to store the gene identifiers alongside our fold-change data
that we recorded earlier in a __list__. 
Each gene identifier/fold-change pair is the __key__/__value__ of the __dictionary__.

__Dictionaries__ are also defined using the curly braces but a pair of values are given each time, separated by a colon (`{key:value}`).

Enter the following. 

__Note__: You need to press enter after each line.

```{python, eval=FALSE}
gene_fold_change = {
  "Agl" : 0.25,
  "Pygm" : -0.42,
  "Pgm2" : 0.62,
  "Ugp2" : 1.27,
  "Gys1" : -0.5,
  "Phka1" : 0,
  "Phkg1" : 0.33
}
gene_fold_change
```

__Dictionaries__ are **indexed** meaning that individual records can be retrieved 
very quickly (important if you are working with very large dictionaries).

We can retrieve the information for "Gys1" by using the identifier as the **key** 
and the __dictionary__ will then return the **value**.

```{python, eval=FALSE}
gene_fold_change["Gys1"]
```

New values can be added to the __dictionary__ in a similar way to how they are retrieved:
```{python, eval=FALSE}
gene_fold_change["ZT1"] = 3.2
gene_fold_change["ZT1"]
```

You __cannot__ subset __dictionaries__ with numbers like a __list__.

The pairing up of values in __dictionaries__ is extremely useful if you are working with DNA sequence files (Fasta or FastQ). 
It offers an easy way of matching up the read identifier with the DNA nucleotide data, for example. 
Once indexed, the individual records can then be accessed extremely quickly.

## Data structures MCQ recap
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/question_bubble_purple.png", auto_pdf = TRUE)
```

Grand! You have learnt about different data structures in __Python__.

Try choosing the correct option in the below senteces to recap what you have learnt.

```{r, echo = FALSE}
opts_p <- c("__Dictionaries__", answer="__Lists__", "__Sets__")
```
1. ________ hold an ordered catalogue of values. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__Dictionaries__", "__Lists__", answer="__Sets__")
```
2. ________ can only hold unique values. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__Dictionaries__", "__Lists__", "__Sets__")
```
3. ________ hold pairs of values (key and value). They can be used to quickly access individual records, even when they are extremely large. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__-1__", answer="__0__", "__1__")
```
4. Data structures in Python start at position ________. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__Exclusive__", answer="__Inclusive__", "__Key__")
```
5. When subsetting values in a __list__ the first number (`[X:]`) is ________. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__Exclusive__", "__Inclusive__", "__Key__")
```
6. When subsetting values in a __list__ the last number (`[:Y]`) is ________. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__Exclusive__", "__Inclusive__", answer="__Key__")
```
7. You can access the __value__ of a __dictionary__ with its matching ________. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__`.add()`__", answer="__`.append()`__", "__`set()`__")
```
8. The ________ __method__ can add a value to a __list__. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__`.add()`__", "__`.append()`__", "__`set()`__")
```
9. The ________ __method__ can add a value to a __set__. `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__`.add()`__", "__`.append()`__", answer="__`set()`__")
```
10. The ________ __function__ can create a __set__ from a __list__. `r longmcq(opts_p)`


We are going to be using these data structures to look at and manipulate DNA sequence data specifically, but the principles apply to any datasets stored in these structures.

Ensure you save your notebook. However, don't close it as you may find its contents useful for the next chapter of exercises.