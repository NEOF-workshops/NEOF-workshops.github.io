[
  {
    "objectID": "upset/upset_tibble_creation.html",
    "href": "upset/upset_tibble_creation.html",
    "title": "Upset tibble creation",
    "section": "",
    "text": "In this part we will finish creating the tibble needed for our upset plot. The steps are:\n\nRemove the Abundance column so we only have the Taxa (Phylum) and Metadata (Sample) columns.\nGroup the tibble by the column we will use as the group for the upset plot (Phylum).\nCreate the intersection column by summarising, via listing, the set column (Sample).\n\nTo carry this out we will build up a tidyverse based pipeline step by step.\n\n\n\n\n  \n\n\nThe first step is to remove the now unwanted Abundance column with dplyr::select(). We are only interested in presence for our upset plot and have already removed the rows that represent absence so we can safely remove this row.\nTo view a transposed summary of the tibble we will use dplyr::glimpse()\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance)\n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nYou will notice we have 201 rows, and 2 columns called Phylum and Sample.\n\n\n\n\n\n  \n\n\nNext we will group the tibble by the Phylum column with dplyr::group_by(), creating a grouped tibble. Grouping a column is needed for some tidyverse functions such as the dplyr::summarise() function in the next step.\nUse the same code block as the previous step adding in the new annotations and code.\nTip: Ensure you add |&gt; to the end of the dplyr::select() line.\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Phylum column important for next step\n    dplyr::group_by(Phylum)    \n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nThe glimpse () function shows the same information but also includes a line about the grouping info: Groups: Phylum [27]. This lets us know that it is grouped by the Phylum column and that there are 27 groups (i.e. 27 unique phyla).\n\n\n\n\n\n  \n\n\nOur final step is to use dplyr::summarise() to convert the Sample column into a list column. Each row will then have a unique Phylum (group) with a corresponding vector (intersections) of the samples (sets) it is found in.\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Phylum column important for next step\n    dplyr::group_by(Phylum) |&gt;\n    #Summarize Sample column so it becomes column of list variables\n    dplyr::summarize(Samples = list(Sample))  \n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nUnfortunately, Jupyter notebook does not like displaying tibbles that have lists as columns. Therefore we will also view it with str() to get a larger picture of it\n\n#Structure of tibble\nstr(phyla_upset_tibble)\n\nTo get an even better picture of the tibble layout, view the contents from the first and seventh row.\n\n#First row\n#Phylum\nphyla_upset_tibble |&gt; dplyr::slice(1) |&gt; dplyr::pull(Phylum)\n#List of samples it is present in\nphyla_upset_tibble |&gt; dplyr::slice(1) |&gt; dplyr::pull(Samples)\n\n\n#Seventh row\n#Phylum\nphyla_upset_tibble |&gt; dplyr::slice(7) |&gt; dplyr::pull(Phylum)\n#List of samples it is present in\nphyla_upset_tibble |&gt; dplyr::slice(7) |&gt; dplyr::pull(Samples)\n\nNow that we have our formatted tibble we can create an upset plot.",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset tibble creation"
    ]
  },
  {
    "objectID": "upset/upset_tibble_creation.html#abundance-column-removal",
    "href": "upset/upset_tibble_creation.html#abundance-column-removal",
    "title": "Upset tibble creation",
    "section": "",
    "text": "The first step is to remove the now unwanted Abundance column with dplyr::select(). We are only interested in presence for our upset plot and have already removed the rows that represent absence so we can safely remove this row.\nTo view a transposed summary of the tibble we will use dplyr::glimpse()\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance)\n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nYou will notice we have 201 rows, and 2 columns called Phylum and Sample.",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset tibble creation"
    ]
  },
  {
    "objectID": "upset/upset_tibble_creation.html#group-tibble",
    "href": "upset/upset_tibble_creation.html#group-tibble",
    "title": "Upset tibble creation",
    "section": "",
    "text": "Next we will group the tibble by the Phylum column with dplyr::group_by(), creating a grouped tibble. Grouping a column is needed for some tidyverse functions such as the dplyr::summarise() function in the next step.\nUse the same code block as the previous step adding in the new annotations and code.\nTip: Ensure you add |&gt; to the end of the dplyr::select() line.\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Phylum column important for next step\n    dplyr::group_by(Phylum)    \n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nThe glimpse () function shows the same information but also includes a line about the grouping info: Groups: Phylum [27]. This lets us know that it is grouped by the Phylum column and that there are 27 groups (i.e. 27 unique phyla).",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset tibble creation"
    ]
  },
  {
    "objectID": "upset/upset_tibble_creation.html#summarise",
    "href": "upset/upset_tibble_creation.html#summarise",
    "title": "Upset tibble creation",
    "section": "",
    "text": "Our final step is to use dplyr::summarise() to convert the Sample column into a list column. Each row will then have a unique Phylum (group) with a corresponding vector (intersections) of the samples (sets) it is found in.\n\n#Remove Abundance column and then make Sample column contain lists\nphyla_upset_tibble &lt;- phyla_tibble_long |&gt;\n    #Remove Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Phylum column important for next step\n    dplyr::group_by(Phylum) |&gt;\n    #Summarize Sample column so it becomes column of list variables\n    dplyr::summarize(Samples = list(Sample))  \n#Glimpse tibble\nphyla_upset_tibble |&gt; dplyre::glimpse()\n\nUnfortunately, Jupyter notebook does not like displaying tibbles that have lists as columns. Therefore we will also view it with str() to get a larger picture of it\n\n#Structure of tibble\nstr(phyla_upset_tibble)\n\nTo get an even better picture of the tibble layout, view the contents from the first and seventh row.\n\n#First row\n#Phylum\nphyla_upset_tibble |&gt; dplyr::slice(1) |&gt; dplyr::pull(Phylum)\n#List of samples it is present in\nphyla_upset_tibble |&gt; dplyr::slice(1) |&gt; dplyr::pull(Samples)\n\n\n#Seventh row\n#Phylum\nphyla_upset_tibble |&gt; dplyr::slice(7) |&gt; dplyr::pull(Phylum)\n#List of samples it is present in\nphyla_upset_tibble |&gt; dplyr::slice(7) |&gt; dplyr::pull(Samples)\n\nNow that we have our formatted tibble we can create an upset plot.",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset tibble creation"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html",
    "href": "upset/upset_data_format.html",
    "title": "Upset data format",
    "section": "",
    "text": "The structure of the data for an upset plot is not a typical tibble. It only requires one column of intersections. This is a list containing the intersections of sets.\nTo demonstrate we’ll create an example tibble required for an upset plot and visualise it.\n\n\n\n\n\nFor clarity we will include a group column. The group column is a normal vector column of characters.\n\n#Group column\ngroup_vec &lt;- c(\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\")\n\n\n\n\n\n\n\nMore complicated is the required intersections column. This column is a list where each element is a character vector.\nLists are one dimensional objects like vectors. However, lists can contain multiple data classes (heterogeneous) where vectors can only contain one (homogeneous). This allows lists to contain vectors as elements.\nEach vector contains the sets found in the row’s group. This represents the intersection.\nFor simplicity we’ll only include 3 different sets (A, B, & C).\n\n#Create vectors of intersections for the 6 groups\ni1 &lt;- c(\"A\",\"B\",\"C\")\ni2 &lt;- c(\"A\",\"B\")\ni3 &lt;- c(\"C\")\ni4 &lt;- c(\"A\",\"B\")\ni5 &lt;- c(\"A\",\"B\")\ni6 &lt;- c(\"A\",\"B\",\"C\")\n#Create a list of the vectors\nintersection_list &lt;- list(i1,i2,i3,i4,i5,i6)\n#Display intersection list\nintersection_list\n\n\n\n\n\n\n\nWe can now combine our group vector and our intersection list into a tibble.\n\n#Upset tibble creation\nupset_tbl &lt;- tibble::tibble(group_vec, intersection_list)\n#Display upset tibble\nupset_tbl |&gt; dplyr::glimpse()\n\nGlimpsing the tibble shows you have 2 columns, one being a character vector (&lt;chr&gt;) and one being a list (&lt;list&gt;). Important features include:\n\nEach list element/vector is flanked by chevrons (&lt; & &gt;) unless the element/vector only contains one element itself (e.g. the \"C\" of group \"G3\").\nThe elements of the list are separated by the commas (,) outside the chevrons.\nThe ... indicates that dplyr::glimpse() is not displaying all the data from the column.\n\nThe intersection for \"G1\" is \"A\", \"B\", \"C\" as denoted by &lt;\"A\", \"B\", \"C\"&gt;.\n\n\n\nAs a quick preview of the Upset plots part we’ll create an upset plot.\nNote: The below functions will be explained later on.\n\n#Upset plot with bar chart\nupset_plot &lt;- upset_tbl |&gt;\n    ggplot2::ggplot(aes(x = intersection_list)) +\n        #Add bar chart\n        ggplot2::geom_bar() +\n        #Add upset visualisation as x axis below bar chart\n        ggupset::scale_x_upset() + \n        #Specify y axis label\n        ggplot2::labs(y=\"Group count\", x=\"Intersections\")\nggplot2::ggsave(filename = \"./example_upset.png\", plot = upset_plot,\n       device = \"png\", dpi = 300, units = \"mm\", height = 75, width = 100)\nIRdisplay::display_png(file=\"./example_upset.png\")\n\nYou may note that we don’t actually need the group column for the plot but I find it good to have so I know what the groups are for the sets. Additionally, it can be used for more complex graphics.\nWe will talk in more depth about upset plots in the Upset plots part but briefly in the below plot you can see:\n\nThere are three different interactions (A+B, A+B+C, and just C).\nThese interactions are found in different numbers of groups (3, 2, and 1).\n\n\n\n\n\n\n\n\n\n\n\nSuperb! Attempt the following MCQs by choosing the correct word for the blanks.\n\nThe required column for an upset plot is a ____________.\n\n Intersection List Vector\n\n\n\nThe row elements of the required column for an upset plot are each a ____________.\n\n Intersection List Vector\n\n\n\nThe required column for an upset plot contains the ____________ information.\n\n Intersection List Vector",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html#group-vector-column",
    "href": "upset/upset_data_format.html#group-vector-column",
    "title": "Upset data format",
    "section": "",
    "text": "For clarity we will include a group column. The group column is a normal vector column of characters.\n\n#Group column\ngroup_vec &lt;- c(\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\")",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html#intersection-list-column",
    "href": "upset/upset_data_format.html#intersection-list-column",
    "title": "Upset data format",
    "section": "",
    "text": "More complicated is the required intersections column. This column is a list where each element is a character vector.\nLists are one dimensional objects like vectors. However, lists can contain multiple data classes (heterogeneous) where vectors can only contain one (homogeneous). This allows lists to contain vectors as elements.\nEach vector contains the sets found in the row’s group. This represents the intersection.\nFor simplicity we’ll only include 3 different sets (A, B, & C).\n\n#Create vectors of intersections for the 6 groups\ni1 &lt;- c(\"A\",\"B\",\"C\")\ni2 &lt;- c(\"A\",\"B\")\ni3 &lt;- c(\"C\")\ni4 &lt;- c(\"A\",\"B\")\ni5 &lt;- c(\"A\",\"B\")\ni6 &lt;- c(\"A\",\"B\",\"C\")\n#Create a list of the vectors\nintersection_list &lt;- list(i1,i2,i3,i4,i5,i6)\n#Display intersection list\nintersection_list",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html#upset-tibble",
    "href": "upset/upset_data_format.html#upset-tibble",
    "title": "Upset data format",
    "section": "",
    "text": "We can now combine our group vector and our intersection list into a tibble.\n\n#Upset tibble creation\nupset_tbl &lt;- tibble::tibble(group_vec, intersection_list)\n#Display upset tibble\nupset_tbl |&gt; dplyr::glimpse()\n\nGlimpsing the tibble shows you have 2 columns, one being a character vector (&lt;chr&gt;) and one being a list (&lt;list&gt;). Important features include:\n\nEach list element/vector is flanked by chevrons (&lt; & &gt;) unless the element/vector only contains one element itself (e.g. the \"C\" of group \"G3\").\nThe elements of the list are separated by the commas (,) outside the chevrons.\nThe ... indicates that dplyr::glimpse() is not displaying all the data from the column.\n\nThe intersection for \"G1\" is \"A\", \"B\", \"C\" as denoted by &lt;\"A\", \"B\", \"C\"&gt;.",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html#upset-plot",
    "href": "upset/upset_data_format.html#upset-plot",
    "title": "Upset data format",
    "section": "",
    "text": "As a quick preview of the Upset plots part we’ll create an upset plot.\nNote: The below functions will be explained later on.\n\n#Upset plot with bar chart\nupset_plot &lt;- upset_tbl |&gt;\n    ggplot2::ggplot(aes(x = intersection_list)) +\n        #Add bar chart\n        ggplot2::geom_bar() +\n        #Add upset visualisation as x axis below bar chart\n        ggupset::scale_x_upset() + \n        #Specify y axis label\n        ggplot2::labs(y=\"Group count\", x=\"Intersections\")\nggplot2::ggsave(filename = \"./example_upset.png\", plot = upset_plot,\n       device = \"png\", dpi = 300, units = \"mm\", height = 75, width = 100)\nIRdisplay::display_png(file=\"./example_upset.png\")\n\nYou may note that we don’t actually need the group column for the plot but I find it good to have so I know what the groups are for the sets. Additionally, it can be used for more complex graphics.\nWe will talk in more depth about upset plots in the Upset plots part but briefly in the below plot you can see:\n\nThere are three different interactions (A+B, A+B+C, and just C).\nThese interactions are found in different numbers of groups (3, 2, and 1).",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/upset_data_format.html#mcqs",
    "href": "upset/upset_data_format.html#mcqs",
    "title": "Upset data format",
    "section": "",
    "text": "Superb! Attempt the following MCQs by choosing the correct word for the blanks.\n\nThe required column for an upset plot is a ____________.\n\n Intersection List Vector\n\n\n\nThe row elements of the required column for an upset plot are each a ____________.\n\n Intersection List Vector\n\n\n\nThe required column for an upset plot contains the ____________ information.\n\n Intersection List Vector",
    "crumbs": [
      "Upset",
      "Data format",
      "Upset data format"
    ]
  },
  {
    "objectID": "upset/simple_bar_chart.html",
    "href": "upset/simple_bar_chart.html",
    "title": "Simple bar chart",
    "section": "",
    "text": "Prior to learning more about upset plots let’s first look at a simple phylum bar chart with our data.\nCreate a new header cell with the 2nd level header of “Phylum bar chart”.\n\n\n\n\n\nPrior to creating the bar chart we will:\n\nConvert the abundance values to relative abundances so it is easier to compare the samples.\nAggregate the taxa to phylum level.\n\nMore info about taxa plots in our R community analysis workbook\n\n#Aggregate taxa to relative abundance phylum level\nphylum_pseq &lt;- pseq |&gt;\n    microbiome::transform(\"compositional\") |&gt;\n    microbiome::aggregate_taxa(\"Phylum\", verbose = FALSE)\n\n\n\n\nCreate a simple bar chart, save it, and display it in jupyter-notebook.\n\n#Simple bar chart\nphylum_bar &lt;- microbiome::plot_composition(phylum_pseq)\n#Save ggplot object as png file\nggplot2::ggsave(filename = \"./phylum_relabund_simple.png\", plot = phylum_bar,\n       device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Display the plot in jupyter notebook\nIRdisplay::display_png(file=\"./phylum_relabund_simple.png\")\n\nThe above code will produce the below plot/figure.",
    "crumbs": [
      "Upset",
      "Setup",
      "Simple bar chart"
    ]
  },
  {
    "objectID": "upset/simple_bar_chart.html#data-transformation",
    "href": "upset/simple_bar_chart.html#data-transformation",
    "title": "Simple bar chart",
    "section": "",
    "text": "Prior to creating the bar chart we will:\n\nConvert the abundance values to relative abundances so it is easier to compare the samples.\nAggregate the taxa to phylum level.\n\nMore info about taxa plots in our R community analysis workbook\n\n#Aggregate taxa to relative abundance phylum level\nphylum_pseq &lt;- pseq |&gt;\n    microbiome::transform(\"compositional\") |&gt;\n    microbiome::aggregate_taxa(\"Phylum\", verbose = FALSE)",
    "crumbs": [
      "Upset",
      "Setup",
      "Simple bar chart"
    ]
  },
  {
    "objectID": "upset/simple_bar_chart.html#bar-chart",
    "href": "upset/simple_bar_chart.html#bar-chart",
    "title": "Simple bar chart",
    "section": "",
    "text": "Create a simple bar chart, save it, and display it in jupyter-notebook.\n\n#Simple bar chart\nphylum_bar &lt;- microbiome::plot_composition(phylum_pseq)\n#Save ggplot object as png file\nggplot2::ggsave(filename = \"./phylum_relabund_simple.png\", plot = phylum_bar,\n       device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Display the plot in jupyter notebook\nIRdisplay::display_png(file=\"./phylum_relabund_simple.png\")\n\nThe above code will produce the below plot/figure.",
    "crumbs": [
      "Upset",
      "Setup",
      "Simple bar chart"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html",
    "href": "upset/rare_upset_plot.html",
    "title": "Rare features upset plot",
    "section": "",
    "text": "You may want to see the intersection of rare features (taxa) to see what samples they are present and absent in. This page will show you how to make an upset of rare families through the following steps:\n\nCarrying out rare aggregation of families to acquire the names of the “non-rare” features.\nCarrying out normal family aggregation on the original phyloseq object.\nRemoving the “non-rare” features from the family aggregated phyloseq object.\nCreating an upset plot.\n\n\n\n\n\n\nIt is always useful to check the total number of groups in a taxa you are interested in.\n\n#Lower taxa levels may have a very high number of members\nmicrobiome::aggregate_taxa(pseq, level = \"Family\")\n\n\n\n\n\n\n\nWe have 112 taxa. Let’s try to extract ~50 of the rarest taxa.\nFirst we will carry out rare aggregation to try ot get a phyloseq object of the top ~60 (112-50=60) most common families.\n\n#Rare aggregate to family to extract vector of \"non-rare\" families\nfamily_rareaggregate_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome::transform(\"compositional\") |&gt;\n    #Use thresholds of at least 1% relative abundance (detection)\n    #In at least 10% of samples (prevalence)\n    microbiome::aggregate_rare(level = \"Family\",\n                        detection = 0.001, prevalence = 1/10) |&gt;\n    #Remove the \"other\" genus which consists of all the rare aggragted taxa\n    #This won't be interesting to include in our upset plot\n    phyloseq::subset_taxa(Family != \"Other\")\n\nWith our rare aggregation thresholds we ended up with 49 non-rare taxa. This means we have classified 63 taxa as rare (112-49=63). This should be ok for our purposes.\n\n\n\n\n\n\nWith our family aggregated phyloseq object we can create a vector containing the names of non-rare families. This is needed for our next step.\n\n#Overview of phyloseq object\nfamily_rareaggregate_pseq\n#Extract names of \"non-rare\" taxa\nnon_rare_families &lt;- tax_table(family_rareaggregate_pseq)[,\"Family\"] |&gt; as.vector()\nnon_rare_families\n\n\n\n\n\n\n\nTo create our rare phyloseq object we need to carry out three steps.\n\nCreate a family aggregated phyloseq object.\nCreate a vector of our “rare” families using the non rare family vector and the family aggregated phyloseq object.\nSubset the family aggregated phyloseq object by retain the “rare” families.\n\n\n\nCarry out family aggregation of our phyloseq object.\n\n#Aggregate to family and remove \"non-rare\" taxa\nfamily_rare_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome::transform(\"compositional\") |&gt;\n    #Aggregate to family\n    microbiome::aggregate_taxa(level = \"Family\")\n\n\n\n\nIn this step we extract all the family names in our family aggregated phyloseq object as a vector.\nThen we compare the vector of all the families against the vector of non-rare families with setdiff() to create a vector of the “rare” families.\n\n#Create vector of rare features\n# i.e. inverse of non-rare asv\nrare_families &lt;- family_rare_pseq |&gt;\n    #Extract tax table as tibble\n    microbiome::tax_tibble() |&gt;\n    #Pull the family column out as a vector\n    dplyr::pull(Family) |&gt;\n    #Extract family names in vector of all families\n    # that are not in the non_rare_families\n    setdiff(non_rare_families)\n#Vector of \"rare\" families\nrare_families\n\n\n\nsetdiff() explanation and examples\n\nThe function setdiff() compares the first vector provided with the second vector provided. It outputs a vector containing the elements that are in vector 1 but not vector 2. The output does not contain elements that are in vector 2 but not vector 1.\nIn other words, setdiff() outputs the elements unique to vector 1.\nPlease see examples below:\n\n#Create vectors\nnum_series &lt;- 0:9\nnum_even &lt;- c(0,2,4,6,8)\nnum_odd &lt;- c(1,3,5,7,9)\nnum_prime &lt;- c(2,3,5,7)\n\nAll our vectors have numbers between 0 and 9 with num_series containing the numbers from 0 to 9. If we use num_series as the first vector we get the inverse of the second vector.\n\nsetdiff(num_series,num_even)\n\n[1] 1 3 5 7 9\n\n\n\nnum_series |&gt; setdiff(num_odd)\n\n[1] 0 2 4 6 8\n\n\n\nsetdiff(num_series,num_prime)\n\n[1] 0 1 4 6 8 9\n\n\nHowever, if we use num_series as the second vector the output is numeric(0). This is because none of the elements/numbers in num_even, num_odd, and num_prime are unique compared to num_series.\n\nnum_even |&gt; setdiff(num_series)\n\nnumeric(0)\n\n\n\nsetdiff(num_odd,num_series)\n\nnumeric(0)\n\n\n\nsetdiff(num_prime,num_series)\n\nnumeric(0)\n\n\n\n\n\n\nWith our vector containing our “rare” families we can subset our family phyloseq object to retain them and remove the “non-rare” families with phyloseq::subset_taxa().\n\n#Remove the \"non-rare\" families\nfamily_rare_pseq &lt;- family_rare_pseq |&gt;\n    phyloseq::subset_taxa(Family %in% rare_families)\n#Display dimensions of rare familiy phyloseq object\nfamily_rare_pseq\n\nWe now have the 63 “rare” families remaining in our phyloseq object.\nYou could also use this method with a manually created vector of families that you what to investigate.\n\n\n\n\n\n\n\nNow you can create the upset plot.\n\n#Upset plot of rare family intersections with sample groupings\nfamily_rare_samples_upset_plot &lt;- family_rare_pseq |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Family\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Family, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Family (sets) column\n    #Results in each row having a unique sample (group)\n    # with a list of the intersections of present families\n    dplyr::summarize(Families = list(Family)) |&gt;\n    #ggplot\n    #Families (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Families)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() +\n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./family_rare__intersection_sample_group_upset.png\",\n                plot = family_rare_samples_upset_plot,\n            device = \"png\", dpi = 300, units = \"mm\", height = 300, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./family_rare__intersection_sample_group_upset.png\")",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html#number-of-families",
    "href": "upset/rare_upset_plot.html#number-of-families",
    "title": "Rare features upset plot",
    "section": "",
    "text": "It is always useful to check the total number of groups in a taxa you are interested in.\n\n#Lower taxa levels may have a very high number of members\nmicrobiome::aggregate_taxa(pseq, level = \"Family\")",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html#rare-aggregation",
    "href": "upset/rare_upset_plot.html#rare-aggregation",
    "title": "Rare features upset plot",
    "section": "",
    "text": "We have 112 taxa. Let’s try to extract ~50 of the rarest taxa.\nFirst we will carry out rare aggregation to try ot get a phyloseq object of the top ~60 (112-50=60) most common families.\n\n#Rare aggregate to family to extract vector of \"non-rare\" families\nfamily_rareaggregate_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome::transform(\"compositional\") |&gt;\n    #Use thresholds of at least 1% relative abundance (detection)\n    #In at least 10% of samples (prevalence)\n    microbiome::aggregate_rare(level = \"Family\",\n                        detection = 0.001, prevalence = 1/10) |&gt;\n    #Remove the \"other\" genus which consists of all the rare aggragted taxa\n    #This won't be interesting to include in our upset plot\n    phyloseq::subset_taxa(Family != \"Other\")\n\nWith our rare aggregation thresholds we ended up with 49 non-rare taxa. This means we have classified 63 taxa as rare (112-49=63). This should be ok for our purposes.",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html#non-rare-families-vector",
    "href": "upset/rare_upset_plot.html#non-rare-families-vector",
    "title": "Rare features upset plot",
    "section": "",
    "text": "With our family aggregated phyloseq object we can create a vector containing the names of non-rare families. This is needed for our next step.\n\n#Overview of phyloseq object\nfamily_rareaggregate_pseq\n#Extract names of \"non-rare\" taxa\nnon_rare_families &lt;- tax_table(family_rareaggregate_pseq)[,\"Family\"] |&gt; as.vector()\nnon_rare_families",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html#rare-phyloseq-creation",
    "href": "upset/rare_upset_plot.html#rare-phyloseq-creation",
    "title": "Rare features upset plot",
    "section": "",
    "text": "To create our rare phyloseq object we need to carry out three steps.\n\nCreate a family aggregated phyloseq object.\nCreate a vector of our “rare” families using the non rare family vector and the family aggregated phyloseq object.\nSubset the family aggregated phyloseq object by retain the “rare” families.\n\n\n\nCarry out family aggregation of our phyloseq object.\n\n#Aggregate to family and remove \"non-rare\" taxa\nfamily_rare_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome::transform(\"compositional\") |&gt;\n    #Aggregate to family\n    microbiome::aggregate_taxa(level = \"Family\")\n\n\n\n\nIn this step we extract all the family names in our family aggregated phyloseq object as a vector.\nThen we compare the vector of all the families against the vector of non-rare families with setdiff() to create a vector of the “rare” families.\n\n#Create vector of rare features\n# i.e. inverse of non-rare asv\nrare_families &lt;- family_rare_pseq |&gt;\n    #Extract tax table as tibble\n    microbiome::tax_tibble() |&gt;\n    #Pull the family column out as a vector\n    dplyr::pull(Family) |&gt;\n    #Extract family names in vector of all families\n    # that are not in the non_rare_families\n    setdiff(non_rare_families)\n#Vector of \"rare\" families\nrare_families\n\n\n\nsetdiff() explanation and examples\n\nThe function setdiff() compares the first vector provided with the second vector provided. It outputs a vector containing the elements that are in vector 1 but not vector 2. The output does not contain elements that are in vector 2 but not vector 1.\nIn other words, setdiff() outputs the elements unique to vector 1.\nPlease see examples below:\n\n#Create vectors\nnum_series &lt;- 0:9\nnum_even &lt;- c(0,2,4,6,8)\nnum_odd &lt;- c(1,3,5,7,9)\nnum_prime &lt;- c(2,3,5,7)\n\nAll our vectors have numbers between 0 and 9 with num_series containing the numbers from 0 to 9. If we use num_series as the first vector we get the inverse of the second vector.\n\nsetdiff(num_series,num_even)\n\n[1] 1 3 5 7 9\n\n\n\nnum_series |&gt; setdiff(num_odd)\n\n[1] 0 2 4 6 8\n\n\n\nsetdiff(num_series,num_prime)\n\n[1] 0 1 4 6 8 9\n\n\nHowever, if we use num_series as the second vector the output is numeric(0). This is because none of the elements/numbers in num_even, num_odd, and num_prime are unique compared to num_series.\n\nnum_even |&gt; setdiff(num_series)\n\nnumeric(0)\n\n\n\nsetdiff(num_odd,num_series)\n\nnumeric(0)\n\n\n\nsetdiff(num_prime,num_series)\n\nnumeric(0)\n\n\n\n\n\n\nWith our vector containing our “rare” families we can subset our family phyloseq object to retain them and remove the “non-rare” families with phyloseq::subset_taxa().\n\n#Remove the \"non-rare\" families\nfamily_rare_pseq &lt;- family_rare_pseq |&gt;\n    phyloseq::subset_taxa(Family %in% rare_families)\n#Display dimensions of rare familiy phyloseq object\nfamily_rare_pseq\n\nWe now have the 63 “rare” families remaining in our phyloseq object.\nYou could also use this method with a manually created vector of families that you what to investigate.",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/rare_upset_plot.html#rare-family-upset-plot",
    "href": "upset/rare_upset_plot.html#rare-family-upset-plot",
    "title": "Rare features upset plot",
    "section": "",
    "text": "Now you can create the upset plot.\n\n#Upset plot of rare family intersections with sample groupings\nfamily_rare_samples_upset_plot &lt;- family_rare_pseq |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Family\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Family, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Family (sets) column\n    #Results in each row having a unique sample (group)\n    # with a list of the intersections of present families\n    dplyr::summarize(Families = list(Family)) |&gt;\n    #ggplot\n    #Families (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Families)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() +\n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./family_rare__intersection_sample_group_upset.png\",\n                plot = family_rare_samples_upset_plot,\n            device = \"png\", dpi = 300, units = \"mm\", height = 300, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./family_rare__intersection_sample_group_upset.png\")",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare features upset plot"
    ]
  },
  {
    "objectID": "upset/phyloseq_to_tibble.html",
    "href": "upset/phyloseq_to_tibble.html",
    "title": "Phyloseq to long presence tibble",
    "section": "",
    "text": "We need to create a long tibble containing data on all the phyla and the samples they are present in. To carry this out we:\n\nExtract the phyloseq object’s abundance table as a tibble.\nLongify the tibble so there is a row for each phylum and sample pair with its corresponding abundance value.\nRemove rows were the abundance is 0. This retains rows where the phylum is present in the sample.\n\nWe use a tibble due to the useage of some specific tidyverse commands in downstream steps.\n\n\n\n\n\nTo extract the otu_table as a tibble we can use the microbiome package with its function otu_tibble().\n\n#Extract abundance table as tibble\nphyla_tibble &lt;- phylum_pseq |&gt;\n    #The row names (taxa in otu_table) become a column in tibble\n    # therefore give the resulting column a name/id of \"Phylum\"\n    microbiome::otu_tibble(column.id = \"Phylum\")\n#Display first 10 rows and columns of resulting tibble\nphyla_df[1:10,1:10]\n\n\n\n\n\n\n  \n\n\nThe next step is to longify the tibble with tidyr::pivot_longer().\nFor our long tibble we want to:\n\nLongify all the columns except the Phylum column (!Phylum).\nMake a column with the sample names, the column names of phyla_tibble, called “Sample” (names_to=\"Sample\").\nMake a column with the abundance values, values in tibble, called “Abundance” (values_to=\"Abundance\").\n\n\n#Longify\nphyla_tibble_long &lt;- phyla_tibble |&gt;\n    tidyr::pivot_longer(!Phylum, names_to=\"Sample\", values_to=\"Abundance\")\n#Display first 10 rows of resulting long tibble\nphyla_tibble_long |&gt; dplyr::slice(1:10)\n\nCurrently all abundance values in the first 10 rows are all zeros. We will remove all 0 abundance rows next.\n\n\n\n\n\n\nThe upset plots we will create will show the intersection of taxa presence. We will therefore remove rows were the abundance is equal to zero as these rows represent absence. If we did not remove these rows they would be included in the upset plot creation.\n\n#Remove rows with 0 values\nphyla_tibble_long &lt;- dplyr::filter(phyla_tibble_long, Abundance &gt; 0)\n#Display first 10 rows of resulting long tibble\nphyla_tibble_long |&gt; dplyr::slice(1:10)",
    "crumbs": [
      "Upset",
      "Data format",
      "Phyloseq to long presence tibble"
    ]
  },
  {
    "objectID": "upset/phyloseq_to_tibble.html#otu_table-to-tibble",
    "href": "upset/phyloseq_to_tibble.html#otu_table-to-tibble",
    "title": "Phyloseq to long presence tibble",
    "section": "",
    "text": "To extract the otu_table as a tibble we can use the microbiome package with its function otu_tibble().\n\n#Extract abundance table as tibble\nphyla_tibble &lt;- phylum_pseq |&gt;\n    #The row names (taxa in otu_table) become a column in tibble\n    # therefore give the resulting column a name/id of \"Phylum\"\n    microbiome::otu_tibble(column.id = \"Phylum\")\n#Display first 10 rows and columns of resulting tibble\nphyla_df[1:10,1:10]",
    "crumbs": [
      "Upset",
      "Data format",
      "Phyloseq to long presence tibble"
    ]
  },
  {
    "objectID": "upset/phyloseq_to_tibble.html#longify",
    "href": "upset/phyloseq_to_tibble.html#longify",
    "title": "Phyloseq to long presence tibble",
    "section": "",
    "text": "The next step is to longify the tibble with tidyr::pivot_longer().\nFor our long tibble we want to:\n\nLongify all the columns except the Phylum column (!Phylum).\nMake a column with the sample names, the column names of phyla_tibble, called “Sample” (names_to=\"Sample\").\nMake a column with the abundance values, values in tibble, called “Abundance” (values_to=\"Abundance\").\n\n\n#Longify\nphyla_tibble_long &lt;- phyla_tibble |&gt;\n    tidyr::pivot_longer(!Phylum, names_to=\"Sample\", values_to=\"Abundance\")\n#Display first 10 rows of resulting long tibble\nphyla_tibble_long |&gt; dplyr::slice(1:10)\n\nCurrently all abundance values in the first 10 rows are all zeros. We will remove all 0 abundance rows next.",
    "crumbs": [
      "Upset",
      "Data format",
      "Phyloseq to long presence tibble"
    ]
  },
  {
    "objectID": "upset/phyloseq_to_tibble.html#remove-absence",
    "href": "upset/phyloseq_to_tibble.html#remove-absence",
    "title": "Phyloseq to long presence tibble",
    "section": "",
    "text": "The upset plots we will create will show the intersection of taxa presence. We will therefore remove rows were the abundance is equal to zero as these rows represent absence. If we did not remove these rows they would be included in the upset plot creation.\n\n#Remove rows with 0 values\nphyla_tibble_long &lt;- dplyr::filter(phyla_tibble_long, Abundance &gt; 0)\n#Display first 10 rows of resulting long tibble\nphyla_tibble_long |&gt; dplyr::slice(1:10)",
    "crumbs": [
      "Upset",
      "Data format",
      "Phyloseq to long presence tibble"
    ]
  },
  {
    "objectID": "upset/metadata_sets.html",
    "href": "upset/metadata_sets.html",
    "title": "Metadata as sets",
    "section": "",
    "text": "In previous parts we have been using the sample names as groups or sets. In this part we will use metadata groupings as sets for intersections. This makes the resulting upset plot less granular but allows us to see the differences between metadata groups easier.\n\n\nCreating an upset tibble with metadata grouping intersections requires a bit more data manipulation including:\n\nCreating a transposed abundance tibble of samples (rows) against taxa (columns).\nConverting the samples to your metadata grouping of interest, site in this case.\nCreating the upset tibble and plot.\n\n\n\n\nAs an example we will create an upset plot of:\n\nRiver sites (UD, MD, and LD) as the sets for intersections.\nGenera as the groups.\n\nNote: When using taxa levels as groups we do not need to remove the rare taxa as the groups are used for the counts of the bar plot. However, if you have a good reason to remove rares, e.g. you might have a lot of rares with incredibly low abundance, then please do remove them.",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata as sets"
    ]
  },
  {
    "objectID": "upset/metadata_sets.html#steps",
    "href": "upset/metadata_sets.html#steps",
    "title": "Metadata as sets",
    "section": "",
    "text": "Creating an upset tibble with metadata grouping intersections requires a bit more data manipulation including:\n\nCreating a transposed abundance tibble of samples (rows) against taxa (columns).\nConverting the samples to your metadata grouping of interest, site in this case.\nCreating the upset tibble and plot.",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata as sets"
    ]
  },
  {
    "objectID": "upset/metadata_sets.html#example-data",
    "href": "upset/metadata_sets.html#example-data",
    "title": "Metadata as sets",
    "section": "",
    "text": "As an example we will create an upset plot of:\n\nRiver sites (UD, MD, and LD) as the sets for intersections.\nGenera as the groups.\n\nNote: When using taxa levels as groups we do not need to remove the rare taxa as the groups are used for the counts of the bar plot. However, if you have a good reason to remove rares, e.g. you might have a lot of rares with incredibly low abundance, then please do remove them.",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata as sets"
    ]
  },
  {
    "objectID": "upset/media_genus_upset.html",
    "href": "upset/media_genus_upset.html",
    "title": "Media upset plot",
    "section": "",
    "text": "Media upset plot\n\n\n\nBelow is an all in one code to create an upset plot of:\n\nMedia sets as the intersections.\ngenus as the groups.\n\n\n#Upset plot displaying number of intersecting media and groups of genera, based on presence\n#Sample (rows) by Genus (columns) abundance tibble\ngenus_tibble &lt;- pseq |&gt;\n    #Aggregate genus\n    microbiome::aggregate_taxa(\"Genus\", verbose = FALSE) |&gt;\n    #extract otu table\n    phyloseq::otu_table() |&gt;\n    #Convert to data.frame then transpose\n    as.data.frame() |&gt; t() |&gt;\n    #Convert to tibble\n    dplyr::as_tibble(rownames = \"Sample\")\n#Vector of media and taxa names, used to filter next tibble\ncols_to_keep &lt;- c(\"media\", colnames(genus_tibble[,-1]))\n#Create media (rows) by Genus (columns) abundance tibble\n#Upset tibble\nmedia_genus_upset_tibble &lt;- pseq |&gt;\n    #Extract metadata tibble\n    microbiome::sample_tibble() |&gt;\n    #Bind by columns with genus_tibble\n    dplyr::bind_cols(genus_tibble) |&gt;\n    #Select al of the columns specified in vector cols_to_keep\n    select(all_of(cols_to_keep)) |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!media, names_to=\"Genus\", values_to=\"Abundance\") |&gt;\n    #Filter to remove rows with an abundance of 0\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Remove duplicate rows to prevent multiple values appearing for each media\n    dplyr::distinct() |&gt;\n    #Group tibble by Genus column\n    dplyr::group_by(Genus) |&gt;\n    #Summarise media column so each row has a unique Genus\n    # with a list of the medias each Genus is found in\n    dplyr::summarize(Medias = list(media))\n#Upset plot\nupset_plot &lt;- media_genus_upset_tibble |&gt;\n    #Upset plot with ggplot2\n    #Use Medias as interactions on x axis\n    ggplot2::ggplot(aes(x = Medias)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale display\n        ggupset::scale_x_upset() +\n        ggplot2::labs(y=\"Genera count\")\nggplot2::ggsave(filename = \"./media_genera_upset.png\", plot = upset_plot,\n    device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./media_genera_upset.png\")",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Media upset plot"
    ]
  },
  {
    "objectID": "upset/challenge_2.html",
    "href": "upset/challenge_2.html",
    "title": "Challenge site and media upset plot",
    "section": "",
    "text": "As a challenge create an upset plot with the following instructions:\n\nUse the data within the pseq object we have used for the previous upset plots.\nAggregate the pseq object to genera level.\nCreate a column called “site_media” with the site info and media info seperated by a “_“, e.g. ”UD_ENV” and “MD_KBC”.\nUse the “site_media” metadata as the sets for the intersections.\nUse the genera as the groups.\n\nYour upset plot should look like the below:\n\n\n\n\n\n\n\n  \n\n\nYou can use the function tidyr::unite() to combine/unite two columns in a tibble.\n\n\nCode solution\n\n\n#Upset plot displaying number of intersecting site_media and groups of genera, based on presence\n#Sample (rows) by Genus (columns) abundance tibble\ngenus_tibble &lt;- pseq |&gt;\n    #Aggregate genus\n    microbiome::aggregate_taxa(\"Genus\", verbose = FALSE) |&gt;\n    #extract otu table\n    phyloseq::otu_table() |&gt;\n    #Convert to data.frame then transpose\n    as.data.frame() |&gt; t() |&gt;\n    #Convert to tibble\n    dplyr::as_tibble(rownames = \"Sample\")\n#Vector of site_media and taxa names, used to filter next tibble\ncols_to_keep &lt;- c(\"site_media\", colnames(genus_tibble[,-1]))\n#Create site_media (rows) by Genus (columns) abundance tibble\n#Upset tibble\nsite_media_genus_upset_tibble &lt;- pseq |&gt;\n    #Extract metadata tibble\n    microbiome::sample_tibble() |&gt;\n    #Combine the site and media columns with \"_\" as the separator\n    tidyr::unite(site_media, c(\"site\",\"media\"), sep = \"_\") |&gt;\n    #Bind by columns with genus_tibble\n    dplyr::bind_cols(genus_tibble) |&gt;\n    #Select al of the columns specified in vector cols_to_keep\n    select(all_of(cols_to_keep)) |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!site_media, names_to=\"Genus\", values_to=\"Abundance\") |&gt;\n    #Filter to remove rows with an abundance of 0\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Remove duplicate rows to prevent multiple values appearing for each media\n    dplyr::distinct() |&gt;\n    #Group tibble by Genus column\n    dplyr::group_by(Genus) |&gt;\n    #Summarise site_media column so each row has a unique Genus\n    # with a list of the site_media combos each Genus is found in\n    dplyr::summarize(site_media = list(site_media))\n#Upset plot\nupset_plot &lt;- site_media_genus_upset_tibble |&gt;\n    #Upset plot with ggplot2\n    #Use site_media as interactions on x axis\n    ggplot2::ggplot(aes(x = site_media)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale display\n        ggupset::scale_x_upset() +\n        ggplot2::labs(y=\"Genera count\", x = \"Site & Media\")\nggplot2::ggsave(filename = \"./site_media_genera_upset.png\", plot = upset_plot,\n    device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./site_media_genera_upset.png\")\n\n\nSpendid! That is the end of this upset section, hopefully you will find it useful in your future analyses.",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Challenge site and media upset plot"
    ]
  },
  {
    "objectID": "upset/challenge_2.html#tip",
    "href": "upset/challenge_2.html#tip",
    "title": "Challenge site and media upset plot",
    "section": "",
    "text": "You can use the function tidyr::unite() to combine/unite two columns in a tibble.\n\n\nCode solution\n\n\n#Upset plot displaying number of intersecting site_media and groups of genera, based on presence\n#Sample (rows) by Genus (columns) abundance tibble\ngenus_tibble &lt;- pseq |&gt;\n    #Aggregate genus\n    microbiome::aggregate_taxa(\"Genus\", verbose = FALSE) |&gt;\n    #extract otu table\n    phyloseq::otu_table() |&gt;\n    #Convert to data.frame then transpose\n    as.data.frame() |&gt; t() |&gt;\n    #Convert to tibble\n    dplyr::as_tibble(rownames = \"Sample\")\n#Vector of site_media and taxa names, used to filter next tibble\ncols_to_keep &lt;- c(\"site_media\", colnames(genus_tibble[,-1]))\n#Create site_media (rows) by Genus (columns) abundance tibble\n#Upset tibble\nsite_media_genus_upset_tibble &lt;- pseq |&gt;\n    #Extract metadata tibble\n    microbiome::sample_tibble() |&gt;\n    #Combine the site and media columns with \"_\" as the separator\n    tidyr::unite(site_media, c(\"site\",\"media\"), sep = \"_\") |&gt;\n    #Bind by columns with genus_tibble\n    dplyr::bind_cols(genus_tibble) |&gt;\n    #Select al of the columns specified in vector cols_to_keep\n    select(all_of(cols_to_keep)) |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!site_media, names_to=\"Genus\", values_to=\"Abundance\") |&gt;\n    #Filter to remove rows with an abundance of 0\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Remove duplicate rows to prevent multiple values appearing for each media\n    dplyr::distinct() |&gt;\n    #Group tibble by Genus column\n    dplyr::group_by(Genus) |&gt;\n    #Summarise site_media column so each row has a unique Genus\n    # with a list of the site_media combos each Genus is found in\n    dplyr::summarize(site_media = list(site_media))\n#Upset plot\nupset_plot &lt;- site_media_genus_upset_tibble |&gt;\n    #Upset plot with ggplot2\n    #Use site_media as interactions on x axis\n    ggplot2::ggplot(aes(x = site_media)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale display\n        ggupset::scale_x_upset() +\n        ggplot2::labs(y=\"Genera count\", x = \"Site & Media\")\nggplot2::ggsave(filename = \"./site_media_genera_upset.png\", plot = upset_plot,\n    device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./site_media_genera_upset.png\")\n\n\nSpendid! That is the end of this upset section, hopefully you will find it useful in your future analyses.",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Challenge site and media upset plot"
    ]
  },
  {
    "objectID": "upset/all_in_one_code.html",
    "href": "upset/all_in_one_code.html",
    "title": "All in one code",
    "section": "",
    "text": "All in one code\n\n\n\nWe’ll create another upset plot with two main differences.\n\nIt will display the intersection of the phyla sets against sample grouping.\nWe’ll create and run one pipeline that goes from the ASV abundance phyloseq object to an upset plot.\n\nRead through, type, and run the code. Ensure you understand how it all works before continuing.\nPlease feel free to copy, paste, and edit previous code to create the below code. This code will then be useful for copy, pasting, and editing to create further plots.\n\n#Upset plot of phyla intersections with sample groupings\nphyla_samples_upset_plot &lt;- pseq |&gt;\n    #Convert abundances to relative/compositional abundances\n    microbiome::transform(\"compositional\") |&gt;\n    #Aggregate ASVs to phylum level\n    microbiome::aggregate_taxa(\"Phylum\", verbose = FALSE) |&gt;\n    #Extract phyla relative abundance table\n    phyloseq::otu_table() |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Phylum\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Phylum, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Phylum (sets) column\n    #Results in each row having a unique sample\n    # with a list of the intersection of present phyla\n    dplyr::summarize(Phyla = list(Phylum)) |&gt;\n    #ggplot\n    #Phyla (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Phyla)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() + \n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./phyla_intersection_sample_group_upset.png\", \n                plot = phyla_samples_upset_plot,\n                device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./phyla_intersection_sample_group_upset.png\")\n\n\n\n\nThe above plots shows the number of samples (groups) with in specific phyla (set) intersections. The total sample count in the bar chart is equal to the total sample count of our data.\n\nMCQs\n\n\n\nGreat! With the upset plot answer the below yes/no MCQs.\n\nIs there at least one sample that contains all the phyla? I.e. is there an intersection of all the phyla in the plot?\n\n Yes No\n\n\n\nAre there any samples that only have one phyla present? I.e. is there an intersection of one phyla (set) displayed on the plot?\n\n Yes No\n\n\n\nIs there a total of 7 samples where Proteobacteria, Firmicutes, and Bacteroidetes are the only phyla present? I.e is the intersection of Proteobacteria + Firmicutes + Bacteroidetes found in 7 samples?\n\n Yes No\n\n\n\nIs there a total of 7 samples where Proteobacteria, Firmicutes, Bacteroidetes, and Actinobacteria are the only phyla present? I.e is the intersection of Proteobacteria + Firmicutes + Bacteroidetes + Actinobacteria found in 7 samples?\n\n Yes No\n\n\n\nIs Firmicutes found in all the samples? I.e. is Firmicutes in all the displayed intersections?\n\n Yes No\n\n\n\nIs Proteobacteria found in all the samples? I.e. is Proteobacteria in all the displayed intersections?\n\n Yes No\n\n\nUsing the fact that there are 36 samples attempt the following MCQs:\n\nHow many samples is Firmicutes present in? I.e. what is the total sample count of all the intersections Firmicutes is found in?\n\n 2 26 34\n\n\n\nHow many samples is Bacteroidetes present in? I.e. what is the total sample count of all the intersections Bacteroidetes is found in?\n\n 2 26 34\n\n\n\nHow many samples is Tenericutes present in? I.e. what is the total sample count of all the intersections Tenericutes is found in?\n\n 2 26 34",
    "crumbs": [
      "Upset",
      "Upset plots",
      "All in one code"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NEOF Advanced R community analysis",
    "section": "",
    "text": "This is the Website for the NEOF Advance R community analysis workshop.",
    "crumbs": [
      "Overview",
      "NEOF Advanced R community analysis"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html",
    "href": "divergence/metadata_addition.html",
    "title": "Metadata addition",
    "section": "",
    "text": "Data needs metadata for us to make sense of it. In this section we’ll add our metadata from our phyloseq object (pseq) to the long tibble we have created.\nWe’ll need to add the metadata twice, once for our left samples and once for our right samples.\n\n\n\n\n\nFor ease we’ll first extract our metadata from the phyloseq object as a data frame. We’re not converting it to a tibble as we will be using the row names of the data frame (a tibble does not have row names).\n\n#Extract metadata from original phyloseq object\nmetadf &lt;- phyloseq::sample_data(pseq)\n#Check head of metadata\nmetadf |&gt; head()\n\n\n\n\n\n\n\nWith our metadata data frame we will first add the metadata for the left samples to our long tibble. We’ll do this for the left samples first so it is on the left side of the final tibble compared to the right sample metadata.\nThis formatting requires a few steps:\n\nCreate the tibble (metadf_L) of the metadata matching the order of the left samples in our long tibble.\n\nUtilise subsetting to match the order of the samples to the left sample column (Sample_L) of the tibble beta_long_tbl.\ntibble::as_tibble(): Converts a data frame to a tibble.\ndplyr::select(): Select columns from a tibble.\n\nRename the columns so they have _L as their suffix e.g. site to site_L\nBind our long tibble of beta diversity values (beta_long_tbl) to our matching left metadata tibble (metadf_L)\n\ndplyr::bind_cols: Binds tibbles by columns (i.e. side by side).\n\n\n\n#Add metadata for the left samples\nmetadf_L &lt;-\n    #Extend metadf to match order of left samples\n    metadf[beta_long_tbl$Sample_L,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_L\" as their suffix\ncolnames(metadf_L) &lt;- paste0(colnames(metadf_L),\"_L\")\n#Add metadata_L to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_L)\n#Check head of our long df\nbeta_long_tbl |&gt; head()\n\n\n\n\n\n\n\nIf you are ever unsure of what a step is doing you can create a new cell and run the specific parts to see what the output is.\nFor example if you are not sure how the initial metadf_L creation is working you could run the following code cells. In the below cells I like to pipe (|&gt;) the final output to head() so only the top 6 rows are printed. Printing the entirety of large data frames or tibbles can be overwhelming.\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt; head()\n\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt;\n#Convert to tibble for tidyverse manipulation\ntibble::as_tibble() |&gt; head()\n\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt;\n#Convert to tibble for tidyverse manipulation\ntibble::as_tibble() |&gt;\n#Remove sample.name row\ndplyr::select(-1) |&gt; head()\n\n\n\n\n\n\n\nNext carry out the same steps used for the left samples’ metadata but for the right samples.\nNote: Copying and pasting your own code is great. However, ensure you change all the parts you need to (i.e changing “_L” to “_R” in multiple locations).\n\n#Add metadata for the right samples\nmetadf_R &lt;-\n    #Extend metadf to match order of right samples\n    metadf[beta_long_tbl$Sample_R,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_R\" as their suffix\ncolnames(metadf_R) &lt;- paste0(colnames(metadf_R),\"_R\")\n#Add metadata_R to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_R)\n#Check head of our long df\nbeta_long_tbl |&gt; head()\n\n\n\n\n\n\n\nBrilliant! before moving onto adding the info from the upper triangle we’ll manage some variables.\nFirst assign the object beta_long_tbl to beta_lower_long_tbl. This will allow us to reuse a lot of previous code for the upper triangle long tibble creation whilst reusing the beta_long_tbl variable.\n\n#Assign to a new variable\nbeta_lower_long_tbl &lt;- beta_long_tbl\n\nTo clear up some space we’ll remove objects we don’t need any more.\n\n#Remove unwanted metadata objects\nrm(metadf_L, metadf_R)",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html#extract-metadata-from-phyloseq",
    "href": "divergence/metadata_addition.html#extract-metadata-from-phyloseq",
    "title": "Metadata addition",
    "section": "",
    "text": "For ease we’ll first extract our metadata from the phyloseq object as a data frame. We’re not converting it to a tibble as we will be using the row names of the data frame (a tibble does not have row names).\n\n#Extract metadata from original phyloseq object\nmetadf &lt;- phyloseq::sample_data(pseq)\n#Check head of metadata\nmetadf |&gt; head()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html#metadata-for-left-samples",
    "href": "divergence/metadata_addition.html#metadata-for-left-samples",
    "title": "Metadata addition",
    "section": "",
    "text": "With our metadata data frame we will first add the metadata for the left samples to our long tibble. We’ll do this for the left samples first so it is on the left side of the final tibble compared to the right sample metadata.\nThis formatting requires a few steps:\n\nCreate the tibble (metadf_L) of the metadata matching the order of the left samples in our long tibble.\n\nUtilise subsetting to match the order of the samples to the left sample column (Sample_L) of the tibble beta_long_tbl.\ntibble::as_tibble(): Converts a data frame to a tibble.\ndplyr::select(): Select columns from a tibble.\n\nRename the columns so they have _L as their suffix e.g. site to site_L\nBind our long tibble of beta diversity values (beta_long_tbl) to our matching left metadata tibble (metadf_L)\n\ndplyr::bind_cols: Binds tibbles by columns (i.e. side by side).\n\n\n\n#Add metadata for the left samples\nmetadf_L &lt;-\n    #Extend metadf to match order of left samples\n    metadf[beta_long_tbl$Sample_L,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_L\" as their suffix\ncolnames(metadf_L) &lt;- paste0(colnames(metadf_L),\"_L\")\n#Add metadata_L to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_L)\n#Check head of our long df\nbeta_long_tbl |&gt; head()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html#testing-code",
    "href": "divergence/metadata_addition.html#testing-code",
    "title": "Metadata addition",
    "section": "",
    "text": "If you are ever unsure of what a step is doing you can create a new cell and run the specific parts to see what the output is.\nFor example if you are not sure how the initial metadf_L creation is working you could run the following code cells. In the below cells I like to pipe (|&gt;) the final output to head() so only the top 6 rows are printed. Printing the entirety of large data frames or tibbles can be overwhelming.\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt; head()\n\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt;\n#Convert to tibble for tidyverse manipulation\ntibble::as_tibble() |&gt; head()\n\n\n#Extend metadf to match order of left samples\nmetadf[beta_long_tbl$Sample_L,] |&gt;\n#Convert to tibble for tidyverse manipulation\ntibble::as_tibble() |&gt;\n#Remove sample.name row\ndplyr::select(-1) |&gt; head()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html#metadata-for-right-samples",
    "href": "divergence/metadata_addition.html#metadata-for-right-samples",
    "title": "Metadata addition",
    "section": "",
    "text": "Next carry out the same steps used for the left samples’ metadata but for the right samples.\nNote: Copying and pasting your own code is great. However, ensure you change all the parts you need to (i.e changing “_L” to “_R” in multiple locations).\n\n#Add metadata for the right samples\nmetadf_R &lt;-\n    #Extend metadf to match order of right samples\n    metadf[beta_long_tbl$Sample_R,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_R\" as their suffix\ncolnames(metadf_R) &lt;- paste0(colnames(metadf_R),\"_R\")\n#Add metadata_R to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_R)\n#Check head of our long df\nbeta_long_tbl |&gt; head()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/metadata_addition.html#variable-management",
    "href": "divergence/metadata_addition.html#variable-management",
    "title": "Metadata addition",
    "section": "",
    "text": "Brilliant! before moving onto adding the info from the upper triangle we’ll manage some variables.\nFirst assign the object beta_long_tbl to beta_lower_long_tbl. This will allow us to reuse a lot of previous code for the upper triangle long tibble creation whilst reusing the beta_long_tbl variable.\n\n#Assign to a new variable\nbeta_lower_long_tbl &lt;- beta_long_tbl\n\nTo clear up some space we’ll remove objects we don’t need any more.\n\n#Remove unwanted metadata objects\nrm(metadf_L, metadf_R)",
    "crumbs": [
      "Divergence",
      "Data format",
      "Metadata addition"
    ]
  },
  {
    "objectID": "divergence/intra_site_divergence.html",
    "href": "divergence/intra_site_divergence.html",
    "title": "Intra-site divergence",
    "section": "",
    "text": "For our first intra-group analysis we’ll examine the dissimilarity within the three sites. The sites are different parts of the Durance river:\n\nUpper Durance (UD)\nMiddle Durance (MD)\nLower Durance (LD)\n\nTo analyse the Intra-site divergence we will:\n\nSubset our long tibble of distances and metadata to only contain one set of intra-group distances.\nCreate a violin plot of the intra-site distances\nCarry out a pairwise wilcox test to statistically compare the inter-site divergences between sites.\n\nAs a reminder we are using weighted UniFrac distances.\n\n\n\n\n\nOur first step is to subset our tibble so we only have the intra-site distances.\nFor this step we pipe (|&gt;) our weighted UniFrac long tibble to 2 different ‘dplyr::filter()’ commands.\nFirst the lower triangle values are kept to remove the upper triangle values. The lower triangle values and upper triangle values are duplicated the difference being which sample is set as the left and right sample. We only want one value from each pair for intra-group divergence as each value will only be used in one divergence grouping.\nThe next filter step is to only retain samples where the left site grouping (site_L) is the same as the right site grouping (site_R). This means we only retain the intra-site distances. Two important notes:\n\nIn you own analyses and the exercise ensure you use the columns for the intra-grouping you are interested in.\n\nE.g. you would use media_L == media_R when analysing intra-media divergence of this dataset.\n\nWe removed the intra-sample distances (e.g. sample 1 to sample 1 distance) in our data formatting step as we would never want them for divergence analysis.\n\n\n#Subset long tibble so only rows where site_L and site_R are identical of the lower triangle\n#I.e. the long tibble only contains one set of paired distances within sites (Intra-site) \nintra_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        #Filter to keep lower triangle rows\n        dplyr::filter(triangle == \"lower\") |&gt;\n        #Filter to keep rows where site_L is the same as site_R (intra site)\n        dplyr::filter(site_L == site_R)\n#Check head of long tbl\nintra_site_wunifrac_long_tbl |&gt; head()\n\n\n\n\n\n\n\nA box plot is a good method to visualise divergence. However, we’ll make it even nicer by making a violin plot.\nIn the below plot we separate the values by site using site_L, we could use site_R and their would be no difference as the values in site_L and `site_R are identical.\nFor a reminder on violin plots please see the R community analysis workbook.\n\n#Intra-site divergence violin plot\nintra_site_violin_plot &lt;-\n    intra_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Intra-site divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_site_divergence_violinplot.png\",\n        plot = intra_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_site_divergence_violinplot.png\")\n\n\n\n\n\n\n\nAs with other box/violin plots we can compare the different intra-site distance groupings with a pairwise wilcox test. For more information please see the R community analysis workbook.\nThe below analysis carries our P-value adjustment via the holm method.\n\npairwise.wilcox.test(intra_site_wunifrac_long_tbl$value,\n                        intra_site_wunifrac_long_tbl$site_L)\n\n\n\n\n\n\n\nWith our results we can see the violin plots of the three sites have significant overlap. Additionally, there is no significant difference between the groupings of intra-site distances.\nIn this case we can’t see any definitive difference in divergence within the different sites. Therefore we’ll carry out some more analysis.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_site_divergence.html#intra-site-tibble",
    "href": "divergence/intra_site_divergence.html#intra-site-tibble",
    "title": "Intra-site divergence",
    "section": "",
    "text": "Our first step is to subset our tibble so we only have the intra-site distances.\nFor this step we pipe (|&gt;) our weighted UniFrac long tibble to 2 different ‘dplyr::filter()’ commands.\nFirst the lower triangle values are kept to remove the upper triangle values. The lower triangle values and upper triangle values are duplicated the difference being which sample is set as the left and right sample. We only want one value from each pair for intra-group divergence as each value will only be used in one divergence grouping.\nThe next filter step is to only retain samples where the left site grouping (site_L) is the same as the right site grouping (site_R). This means we only retain the intra-site distances. Two important notes:\n\nIn you own analyses and the exercise ensure you use the columns for the intra-grouping you are interested in.\n\nE.g. you would use media_L == media_R when analysing intra-media divergence of this dataset.\n\nWe removed the intra-sample distances (e.g. sample 1 to sample 1 distance) in our data formatting step as we would never want them for divergence analysis.\n\n\n#Subset long tibble so only rows where site_L and site_R are identical of the lower triangle\n#I.e. the long tibble only contains one set of paired distances within sites (Intra-site) \nintra_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        #Filter to keep lower triangle rows\n        dplyr::filter(triangle == \"lower\") |&gt;\n        #Filter to keep rows where site_L is the same as site_R (intra site)\n        dplyr::filter(site_L == site_R)\n#Check head of long tbl\nintra_site_wunifrac_long_tbl |&gt; head()",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_site_divergence.html#violin-plot",
    "href": "divergence/intra_site_divergence.html#violin-plot",
    "title": "Intra-site divergence",
    "section": "",
    "text": "A box plot is a good method to visualise divergence. However, we’ll make it even nicer by making a violin plot.\nIn the below plot we separate the values by site using site_L, we could use site_R and their would be no difference as the values in site_L and `site_R are identical.\nFor a reminder on violin plots please see the R community analysis workbook.\n\n#Intra-site divergence violin plot\nintra_site_violin_plot &lt;-\n    intra_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Intra-site divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_site_divergence_violinplot.png\",\n        plot = intra_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_site_divergence_violinplot.png\")",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_site_divergence.html#stats",
    "href": "divergence/intra_site_divergence.html#stats",
    "title": "Intra-site divergence",
    "section": "",
    "text": "As with other box/violin plots we can compare the different intra-site distance groupings with a pairwise wilcox test. For more information please see the R community analysis workbook.\nThe below analysis carries our P-value adjustment via the holm method.\n\npairwise.wilcox.test(intra_site_wunifrac_long_tbl$value,\n                        intra_site_wunifrac_long_tbl$site_L)",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_site_divergence.html#interpretation",
    "href": "divergence/intra_site_divergence.html#interpretation",
    "title": "Intra-site divergence",
    "section": "",
    "text": "With our results we can see the violin plots of the three sites have significant overlap. Additionally, there is no significant difference between the groupings of intra-site distances.\nIn this case we can’t see any definitive difference in divergence within the different sites. Therefore we’ll carry out some more analysis.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_divergence.html",
    "href": "divergence/intra_divergence.html",
    "title": "Intra-group overview",
    "section": "",
    "text": "With our data formatted we will first carry out intra-group divergence analysis. This is analysing the distances within groups (e.g. intranet is a network within an organisation).\nIn this section we will:\n\nAnalyse the Intra-site divergence (River locations: LD, MD, & UD)\nExercise: Repeat the previous steps for Intra-media divergence (CVP, ENV, KBC, & TSA)\n\n\n\n\n\n\nWhen carrying out intra-group divergence we are trying to determine which groups have lower dissimilarity distances between their samples.\nIf a group has low intra-group distances this indicates the communities of the samples are quite similar. Whereas, if a group has high intra-group distances this indicates the communities of the samples are quite dissimilar.\nFor example, if you were comparing the gut microbiome of farmed fish compared to wild fish you may find:\n\nLow intra-group distances in the gut microbiome of farmed fish.\n\nThis could be caused by their consistent diet and treatment with antibiotics leading to similar gut microbiome profiles.\n\nHigh intra-group distances in the gut microbiome of wild fish.\n\nThis could be due to the variety in their diets and their ability to move through various environments.\n\n\nYou are able to see intra-group divergence of this in ordination plots (PCoA, NMDS etc.) where group clusters being tighter than others indicates lower dissimilarity values. For example the below (fictional) ordination shows tighter clustering in the gut microbiome of farmed fish compared to wild fish.\n\n\n\n\n\n\n\n\n\nSo why carry out divergence analysis? Divergence analysis directly uses the dissimilarity matrix values rather than ordination values that are calculated from the matrix. Therefore, if you are interested in and making statements about intra-group dissimilarity it is best to carry out visual and statistical intra-group divergence analysis.\n\n\n\n\n\n\nWith intra-group divergence we look at the dissimilarity distances between all pairs within the same group.\n\n\nLet’s say we have 3 groups (G1, G2, & G3) each with 3 samples. With this example data we acquire the below ordination plot (e.g. PCoA or NMDS).\n\n\n\n\n\n\n\n\n\n\n\n\nIn this example data we would have 3 pairs in each group, this can be seen in the below plot. A 4 sample group would have 6 pairs, and a 5 sample group would have 10 pairs. To calculate the number of pairs in a set you can use n(n-1)/2.\nThe below plot shows a line between each sample and its intra-group pairs. We will only use the distances of these pairs for our intra-group divergence analysis.\nNote: We use the beta diversity distance (e.g. UniFrac) not the ordination distance (e.g. PCoA) for divergence analysis.\n\n\n\n\n\n\n\n\n\nBelow is a further example where we have added one more sample to each group.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-group overview"
    ]
  },
  {
    "objectID": "divergence/intra_divergence.html#intra-group-divergence-purpose",
    "href": "divergence/intra_divergence.html#intra-group-divergence-purpose",
    "title": "Intra-group overview",
    "section": "",
    "text": "When carrying out intra-group divergence we are trying to determine which groups have lower dissimilarity distances between their samples.\nIf a group has low intra-group distances this indicates the communities of the samples are quite similar. Whereas, if a group has high intra-group distances this indicates the communities of the samples are quite dissimilar.\nFor example, if you were comparing the gut microbiome of farmed fish compared to wild fish you may find:\n\nLow intra-group distances in the gut microbiome of farmed fish.\n\nThis could be caused by their consistent diet and treatment with antibiotics leading to similar gut microbiome profiles.\n\nHigh intra-group distances in the gut microbiome of wild fish.\n\nThis could be due to the variety in their diets and their ability to move through various environments.\n\n\nYou are able to see intra-group divergence of this in ordination plots (PCoA, NMDS etc.) where group clusters being tighter than others indicates lower dissimilarity values. For example the below (fictional) ordination shows tighter clustering in the gut microbiome of farmed fish compared to wild fish.\n\n\n\n\n\n\n\n\n\nSo why carry out divergence analysis? Divergence analysis directly uses the dissimilarity matrix values rather than ordination values that are calculated from the matrix. Therefore, if you are interested in and making statements about intra-group dissimilarity it is best to carry out visual and statistical intra-group divergence analysis.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-group overview"
    ]
  },
  {
    "objectID": "divergence/intra_divergence.html#groupings-and-pairs",
    "href": "divergence/intra_divergence.html#groupings-and-pairs",
    "title": "Intra-group overview",
    "section": "",
    "text": "With intra-group divergence we look at the dissimilarity distances between all pairs within the same group.\n\n\nLet’s say we have 3 groups (G1, G2, & G3) each with 3 samples. With this example data we acquire the below ordination plot (e.g. PCoA or NMDS).\n\n\n\n\n\n\n\n\n\n\n\n\nIn this example data we would have 3 pairs in each group, this can be seen in the below plot. A 4 sample group would have 6 pairs, and a 5 sample group would have 10 pairs. To calculate the number of pairs in a set you can use n(n-1)/2.\nThe below plot shows a line between each sample and its intra-group pairs. We will only use the distances of these pairs for our intra-group divergence analysis.\nNote: We use the beta diversity distance (e.g. UniFrac) not the ordination distance (e.g. PCoA) for divergence analysis.\n\n\n\n\n\n\n\n\n\nBelow is a further example where we have added one more sample to each group.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-group overview"
    ]
  },
  {
    "objectID": "divergence/inter_media_exercise.html",
    "href": "divergence/inter_media_exercise.html",
    "title": "Inter-media exercise",
    "section": "",
    "text": "Now to carry out inter-media divergence analysis.\nFor this exercise you will create your own code. Solutions are available in the solution boxes below but please make a strong attempt before looking at them.\nI would recommend copying, pasting, and editing your code from the inter-site analysis. Ensure you change all the variable names you need to, it is very easy to miss variables and column/row names you need to change.\n\n\n\n\n\nThe steps to carry out this exercise are below along with the solution expandable boxes.\n\n\nThe first step is to create a tibble containing only observations/rows of intra-media distances from the beta_long_tbl tibble. Call this variable: inter_media_wunifrac_long_tbl\nTip: You will need to use the columns media_L and media_R.\n\n\nInter-media tibble creation\n\n\n#Subset long tibble so only rows where media_R and media_L are not identical\n#I.e. the long tibble only contains paired distances between samples of \n# different media (inter-media distances)\ninter_media_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        dplyr::filter(media_L != media_R)\n#Check head of long df\ninter_media_wunifrac_long_tbl |&gt; head()\n\n\n\n\n\nWith the formatted tibble the next step is to create a violin plot. Ensure the x axis is separated by the four media groupings (CVP, ENV, KBC, and TSA). Additionally, colour the points by the paired/right media.\nYou are aiming for the below plot :\nNote: the points are randomly distributed on the x-axis every time you run the command. Therefore yours will most likely look slightly different.\n\n\n\n\n\nInter-media violin plot code solution\n\n\n#Inter-media divergence violin plot\ninter_media_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(aes(colour = media_R), alpha=0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                    title=\"Inter-media divergence with Weighted UniFrac dissimilarity\",\n                    subtitle=\"Points coloured by media of paired distance sample\",\n                    colour = \"Media\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_media_divergence_violinplot.png\",\n        plot = inter_media_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_media_divergence_violinplot.png\")\n\n\nIn the plot we can see:\n\nThe ENV samples are highly dissimilar to the CVP, KBC, and TSA samples (&gt;0.5 Weighted UniFrac) with similar distances between these three pairings.\nThe media samples (CVP, KBC, and TSA) are more similar to each other (&lt;05 Weighted UniFrac) compared to the ENV samples.\nCVP and KBC are the two most similar media groupings (i.e. smallest dissimilarity distances).\n\n\n\n\nFinally, carry out the pairwise wilcox tests to determine if there are significant difference between the inter-media distances. Carry this out to compare distances between the four media and to compare the media pairwise distances.\n\n\nInter-media pairwise wilcox\n\n\npairwise.wilcox.test(inter_media_wunifrac_long_tbl$value,\n                        inter_media_wunifrac_long_tbl$media_L)\n\n\n#Create new tibble for media pair statistics\ninter_media_pairs_wunifrac_long_tbl &lt;-\n        inter_media_wunifrac_long_tbl |&gt;\n                #Retain lower triangle rows\n                dplyr::filter(triangle == \"lower\") |&gt;\n                #Convert media_L and media_R to character columns\n                #These are originally factors which cannot be ordered alphabetically\n                dplyr::mutate(dplyr::across(c(media_L,media_R), as.character)) |&gt;\n                #Create new media_L_R column\n                #Ensure the first alphabetical media (pmin) is the prefix\n                #and the second/last alphabetical media (pmax) is the suffix\n                dplyr::mutate(media_L_R = \n                        paste0(pmin(media_L,site_R),\"_\",pmax(media_L,site_R)))\n\n#Wilcox\npairwise.wilcox.test(inter_media_pairs_wunifrac_long_tbl$value,\n                        inter_media_pairs_wunifrac_long_tbl$site_L_R)\n\n\nIn this case you’lld see there is a significant difference between the intra-group distances of all the different media types except for CVP compared to KBC and CVP compared to TSA. From the plot we may expect to see no significant difference between the intra-group divergences of KBC and TSA but this is not the case seemingly.\nThe media pair inter-group divergence stats shows each pairing is significantly different to every other pairing. Some finer points:\n\nThe three pairings of ENV to the media seem very similar to each other but still have significant p-values values (&lt;0.05) even if CVP_ENV and ENV_KBC barely reach the threshold (0.047).\nThe media media pairings have very strong evidence of being different to each other (p-value = &lt; 2e-16).\n\nThe KBC and CVP samples are the most similar\nThe KBC and TSA samples are the second most similar\nThe CVP and TSA samples are the least dissimilar in terms of the media pairs",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-media exercise"
    ]
  },
  {
    "objectID": "divergence/inter_media_exercise.html#steps",
    "href": "divergence/inter_media_exercise.html#steps",
    "title": "Inter-media exercise",
    "section": "",
    "text": "The steps to carry out this exercise are below along with the solution expandable boxes.\n\n\nThe first step is to create a tibble containing only observations/rows of intra-media distances from the beta_long_tbl tibble. Call this variable: inter_media_wunifrac_long_tbl\nTip: You will need to use the columns media_L and media_R.\n\n\nInter-media tibble creation\n\n\n#Subset long tibble so only rows where media_R and media_L are not identical\n#I.e. the long tibble only contains paired distances between samples of \n# different media (inter-media distances)\ninter_media_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        dplyr::filter(media_L != media_R)\n#Check head of long df\ninter_media_wunifrac_long_tbl |&gt; head()\n\n\n\n\n\nWith the formatted tibble the next step is to create a violin plot. Ensure the x axis is separated by the four media groupings (CVP, ENV, KBC, and TSA). Additionally, colour the points by the paired/right media.\nYou are aiming for the below plot :\nNote: the points are randomly distributed on the x-axis every time you run the command. Therefore yours will most likely look slightly different.\n\n\n\n\n\nInter-media violin plot code solution\n\n\n#Inter-media divergence violin plot\ninter_media_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(aes(colour = media_R), alpha=0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                    title=\"Inter-media divergence with Weighted UniFrac dissimilarity\",\n                    subtitle=\"Points coloured by media of paired distance sample\",\n                    colour = \"Media\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_media_divergence_violinplot.png\",\n        plot = inter_media_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_media_divergence_violinplot.png\")\n\n\nIn the plot we can see:\n\nThe ENV samples are highly dissimilar to the CVP, KBC, and TSA samples (&gt;0.5 Weighted UniFrac) with similar distances between these three pairings.\nThe media samples (CVP, KBC, and TSA) are more similar to each other (&lt;05 Weighted UniFrac) compared to the ENV samples.\nCVP and KBC are the two most similar media groupings (i.e. smallest dissimilarity distances).\n\n\n\n\nFinally, carry out the pairwise wilcox tests to determine if there are significant difference between the inter-media distances. Carry this out to compare distances between the four media and to compare the media pairwise distances.\n\n\nInter-media pairwise wilcox\n\n\npairwise.wilcox.test(inter_media_wunifrac_long_tbl$value,\n                        inter_media_wunifrac_long_tbl$media_L)\n\n\n#Create new tibble for media pair statistics\ninter_media_pairs_wunifrac_long_tbl &lt;-\n        inter_media_wunifrac_long_tbl |&gt;\n                #Retain lower triangle rows\n                dplyr::filter(triangle == \"lower\") |&gt;\n                #Convert media_L and media_R to character columns\n                #These are originally factors which cannot be ordered alphabetically\n                dplyr::mutate(dplyr::across(c(media_L,media_R), as.character)) |&gt;\n                #Create new media_L_R column\n                #Ensure the first alphabetical media (pmin) is the prefix\n                #and the second/last alphabetical media (pmax) is the suffix\n                dplyr::mutate(media_L_R = \n                        paste0(pmin(media_L,site_R),\"_\",pmax(media_L,site_R)))\n\n#Wilcox\npairwise.wilcox.test(inter_media_pairs_wunifrac_long_tbl$value,\n                        inter_media_pairs_wunifrac_long_tbl$site_L_R)\n\n\nIn this case you’lld see there is a significant difference between the intra-group distances of all the different media types except for CVP compared to KBC and CVP compared to TSA. From the plot we may expect to see no significant difference between the intra-group divergences of KBC and TSA but this is not the case seemingly.\nThe media pair inter-group divergence stats shows each pairing is significantly different to every other pairing. Some finer points:\n\nThe three pairings of ENV to the media seem very similar to each other but still have significant p-values values (&lt;0.05) even if CVP_ENV and ENV_KBC barely reach the threshold (0.047).\nThe media media pairings have very strong evidence of being different to each other (p-value = &lt; 2e-16).\n\nThe KBC and CVP samples are the most similar\nThe KBC and TSA samples are the second most similar\nThe CVP and TSA samples are the least dissimilar in terms of the media pairs",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-media exercise"
    ]
  },
  {
    "objectID": "divergence/divergence_data_format.html",
    "href": "divergence/divergence_data_format.html",
    "title": "Divergence data format",
    "section": "",
    "text": "We will create violin plots with ggplot2 similar to the plots we created in the Alpha diversity chapter of our R community analysis workshop.\nFor this we need to create a long tibble. To carry this out we will:\n\nLoad in the distance matrix\nCreate a long tibble from the lower triangle\nCreate a long tibble from the upper triangle\nBind the tibble\n\nHowever, before that let’s see an example square distance matrix and long data frame for divergence analysis.\n\n\nWhat’s a tibble?\n\nA tibble is a reimagining of the data.frame object. It is part of the tidyverse suite of packages these materials extensively use. For more information please see: Tidyverse Tibble guide\n\n\n\n\n\n\nOur initial dissimilarity distance data is in a square distance matrix. An example is below:\n\n\n   S1 S2 S3\nS1  0  2  3\nS2  2  0  5\nS3  3  5  0\n\n\nThere are three main sections to this distance matrix.\n\n\n\n\n\nThe lower triangle is the bottom left triangle of unique values.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1 NA NA NA\nS2  2 NA NA\nS3  3  5 NA\n\n\n\n\n\n\n\n\nThe upper triangle is the top right triangle of unique values.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1 NA  2  3\nS2 NA NA  5\nS3 NA NA NA\n\n\n\n\n\n\n\n\nThe diagonal represents the distances of each sample to itself. These are always zero.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1  0 NA NA\nS2 NA  0 NA\nS3 NA NA  0\n\n\n\n\n\n\n\n\n\nWhen the above example distance matrix is converted into a long tibble for divergence analysis it will then look like:\n\n\n# A tibble: 6 × 3\n  Sample_L Sample_R Value\n  &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;\n1 S1       S2           2\n2 S1       S3           3\n3 S2       S1           2\n4 S2       S3           5\n5 S3       S1           3\n6 S3       S2           5\n\n\nSome of the features of this long tibble are:\n\nThe “Value” column is the distance between the two samples\nEach observation/row has a “Sample_L” and “Sample_R” column to represent the 2 samples the distance is between\n\nThe “L” and “R” represent Left and Right. Left/Right has no significant meaning and instead was chosen as the Right samples are right to the Left samples in the tibble.\n\nWe do not include the 0 values from the diagonal.\nEach value is represented twice, i.e. the lower and upper triangle values are included.\n\nThe 2 rows containing the duplicated values are different in which sample is the Left sample and which is the right sample.\nThis is required for creating inter-group divergence (explained later)\n\n\nAs an example of duplicated values the below data frame shows the distance between S1 and S2 twice. Notice that S1 is the Left sample in the first row but it is the Right sample in the other row.\n\n\n# A tibble: 2 × 3\n  Sample_L Sample_R Value\n  &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;\n1 S1       S2           2\n2 S2       S1           2\n\n\nWith theory covered let’s move onto practice.",
    "crumbs": [
      "Divergence",
      "Data format",
      "Divergence data format"
    ]
  },
  {
    "objectID": "divergence/divergence_data_format.html#square-distance-matrix",
    "href": "divergence/divergence_data_format.html#square-distance-matrix",
    "title": "Divergence data format",
    "section": "",
    "text": "Our initial dissimilarity distance data is in a square distance matrix. An example is below:\n\n\n   S1 S2 S3\nS1  0  2  3\nS2  2  0  5\nS3  3  5  0\n\n\nThere are three main sections to this distance matrix.\n\n\n\n\n\nThe lower triangle is the bottom left triangle of unique values.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1 NA NA NA\nS2  2 NA NA\nS3  3  5 NA\n\n\n\n\n\n\n\n\nThe upper triangle is the top right triangle of unique values.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1 NA  2  3\nS2 NA NA  5\nS3 NA NA NA\n\n\n\n\n\n\n\n\nThe diagonal represents the distances of each sample to itself. These are always zero.\nFor example (ignore the NAs):\n\n\n   S1 S2 S3\nS1  0 NA NA\nS2 NA  0 NA\nS3 NA NA  0",
    "crumbs": [
      "Divergence",
      "Data format",
      "Divergence data format"
    ]
  },
  {
    "objectID": "divergence/divergence_data_format.html#long-distance-tibble",
    "href": "divergence/divergence_data_format.html#long-distance-tibble",
    "title": "Divergence data format",
    "section": "",
    "text": "When the above example distance matrix is converted into a long tibble for divergence analysis it will then look like:\n\n\n# A tibble: 6 × 3\n  Sample_L Sample_R Value\n  &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;\n1 S1       S2           2\n2 S1       S3           3\n3 S2       S1           2\n4 S2       S3           5\n5 S3       S1           3\n6 S3       S2           5\n\n\nSome of the features of this long tibble are:\n\nThe “Value” column is the distance between the two samples\nEach observation/row has a “Sample_L” and “Sample_R” column to represent the 2 samples the distance is between\n\nThe “L” and “R” represent Left and Right. Left/Right has no significant meaning and instead was chosen as the Right samples are right to the Left samples in the tibble.\n\nWe do not include the 0 values from the diagonal.\nEach value is represented twice, i.e. the lower and upper triangle values are included.\n\nThe 2 rows containing the duplicated values are different in which sample is the Left sample and which is the right sample.\nThis is required for creating inter-group divergence (explained later)\n\n\nAs an example of duplicated values the below data frame shows the distance between S1 and S2 twice. Notice that S1 is the Left sample in the first row but it is the Right sample in the other row.\n\n\n# A tibble: 2 × 3\n  Sample_L Sample_R Value\n  &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;\n1 S1       S2           2\n2 S2       S1           2\n\n\nWith theory covered let’s move onto practice.",
    "crumbs": [
      "Divergence",
      "Data format",
      "Divergence data format"
    ]
  },
  {
    "objectID": "divergence/divergence.html",
    "href": "divergence/divergence.html",
    "title": "Divergence",
    "section": "",
    "text": "Divergence analysis is comparing the dissimilarity distances between (inter-) and within (intra-) groupings. This allows us to more closely examine beta diversity.\nOrdination analysis (PCoA, NMDS, etc.) allows us to determine if groups cluster separately by dissimilarity/biodiversity measures. Divergence analysis allows us to determine:\n\nIntra-group divergence/homogeneity: Comparison of distances within a group compared to distances within other groups.\nInter-group divergence/heterogeneity: Comparison of dissimilarity distances between a group’s samples and all other group’s samples (inter-group distances) compared to other groups’ inter-group distances.\n\nTo remember the difference between intra- and inter- I remember the intranet (network within an organisation) and the internet (network between organisation). More information about intra- and inter-divergence are in their specific sections.\n\n\n\n\n\nThe sections are:\n\nSetup: Setting up your environment, jupyter-notebook, libraries, and data for the divergence tutorial\nData format: Formatting data for divergence analysis\n\nInvolves information about the original dissimilarity matrix and its parts (lower triangle, upper triangle, and diagonal)\n\nIntra-group divergence\n\nOverview of intra-group divergence\nPractice with intra-site divergence\nExercise with intra-media divergence\n\nInter-group divergence\n\nOverview of inter-group divergence\nPractice with inter-site divergence\nExercise with inter-media divergence\n\nAdvanced/extra\n\nCombining plots into one png\nDivergence analysis when splitting by another group (intra-media by intra-site & inter-media by intra-site)",
    "crumbs": [
      "Divergence"
    ]
  },
  {
    "objectID": "divergence/divergence.html#sections",
    "href": "divergence/divergence.html#sections",
    "title": "Divergence",
    "section": "",
    "text": "The sections are:\n\nSetup: Setting up your environment, jupyter-notebook, libraries, and data for the divergence tutorial\nData format: Formatting data for divergence analysis\n\nInvolves information about the original dissimilarity matrix and its parts (lower triangle, upper triangle, and diagonal)\n\nIntra-group divergence\n\nOverview of intra-group divergence\nPractice with intra-site divergence\nExercise with intra-media divergence\n\nInter-group divergence\n\nOverview of inter-group divergence\nPractice with inter-site divergence\nExercise with inter-media divergence\n\nAdvanced/extra\n\nCombining plots into one png\nDivergence analysis when splitting by another group (intra-media by intra-site & inter-media by intra-site)",
    "crumbs": [
      "Divergence"
    ]
  },
  {
    "objectID": "divergence/combined_plot.html",
    "href": "divergence/combined_plot.html",
    "title": "Combined plot",
    "section": "",
    "text": "Combined plot\n\n\n  \n\n\nThe below code combines our plots into one image/png file with the patchwork package.\n\nwunifrac_divergence_plot &lt;- \n    (intra_site_violin_plot | inter_site_violin_plot) /\n    (intra_media_violin_plot | inter_media_violin_plot)\n\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_divergence_violinplots.png\",\n        plot = wunifrac_divergence_plot,\n        device = \"png\", dpi=300, units = \"mm\", height = 200, width = 300)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_divergence_violinplots.png\")\n\nFor more information on patchwork please see our Tidyverse guide.",
    "crumbs": [
      "Divergence",
      "Advanced",
      "Combined plot"
    ]
  },
  {
    "objectID": "divergence/bind_long_tibbles.html",
    "href": "divergence/bind_long_tibbles.html",
    "title": "Bind long tibbles",
    "section": "",
    "text": "Bind long tibbles\n\n\n  \n\n\nOur final step is to combine the lower and upper long tibbles with dplyr::bind_rows(). This function binds 2 tibbles by rows (i.e. one on top of the other).\nAdditionally, we’ll use the dplyr::glimpse() function to get a preview of the final tibble.\n\nbeta_long_tbl &lt;-\n    dplyr::bind_rows(beta_lower_long_tbl, beta_upper_long_tbl)\nbeta_long_tbl |&gt; dplyr::glimpse()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Bind long tibbles"
    ]
  },
  {
    "objectID": "divergence/data_and_setup.html",
    "href": "divergence/data_and_setup.html",
    "title": "Data & Setup",
    "section": "",
    "text": "Before you carry out any practice you will need to setup your environment with the instructions in this page. The steps are:\n\nEnsuring you have setup your directory, environment, and jupyter-notebook as shown in the overall setup.\nCreating a jupyter-notebook in a new work directory.\nLoading in the required libraries.\nLoading in the data.\n\n\n\n\n\n\nIn the jupyter-notebook file explorer create and move into a new directory called divergence, ensure this is a subdiretcory of the main workshop directory (adv_R_comm). We’ll keep each section in its own subdirectory so it is easier to keep the output files separate and tidy.\nCreate a new R based jupyter-notebook called “divergence.ipynb”. At the top of the jupyter-notebook add the following headers:\n\nA first level header of “Divergence”.\nA second level header of “Libraries & data”.\n\n\n\n\n\n\n\nLoad the required libraries/packages in a new code cell.\n\n#Libraries\nlibrary(\"phyloseq\")\nlibrary(\"microbiome\")\nlibrary(\"IRdisplay\")\nlibrary(\"tidyverse\")\nlibrary(\"ggforce\")\nlibrary(\"patchwork\")\n\n\n\n\n\n\n\nWe have a phyloseq object containing ASV abundance data through DADA2 denoising in QIIME2 (theory & code). For our divergence analysis we will be utilising the Durance river data used in our R community analysis workshop. This is a 16S dataset with two main metadata groupings:\n\nSites: Upper, Middle, and Lower Durance sampling site (UD, MD, & LD).\nCulture media: Environmental sample (ENV), TSA, KBC, and CVP.\n\nMore info in the R community analysis workbook\nLoad in the phyloseq object.\n\n#Original phyloseq object\nload(\"/pub14/tea/nsc206/NEOF/R_community/data/phyloseq.RData\")\n\nAdditionally, we will load a dissimilarity matrix of weighted unifrac values created through iterative rarefaction:\n\n#Iterative rarefied weighted unifrac data frame\nload(\"/pub14/tea/nsc206/NEOF/R_community_advanced/wunifrac_df_mean.RData\")",
    "crumbs": [
      "Divergence",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "divergence/data_and_setup.html#jupyter-notebook",
    "href": "divergence/data_and_setup.html#jupyter-notebook",
    "title": "Data & Setup",
    "section": "",
    "text": "In the jupyter-notebook file explorer create and move into a new directory called divergence, ensure this is a subdiretcory of the main workshop directory (adv_R_comm). We’ll keep each section in its own subdirectory so it is easier to keep the output files separate and tidy.\nCreate a new R based jupyter-notebook called “divergence.ipynb”. At the top of the jupyter-notebook add the following headers:\n\nA first level header of “Divergence”.\nA second level header of “Libraries & data”.",
    "crumbs": [
      "Divergence",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "divergence/data_and_setup.html#libraries",
    "href": "divergence/data_and_setup.html#libraries",
    "title": "Data & Setup",
    "section": "",
    "text": "Load the required libraries/packages in a new code cell.\n\n#Libraries\nlibrary(\"phyloseq\")\nlibrary(\"microbiome\")\nlibrary(\"IRdisplay\")\nlibrary(\"tidyverse\")\nlibrary(\"ggforce\")\nlibrary(\"patchwork\")",
    "crumbs": [
      "Divergence",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "divergence/data_and_setup.html#data",
    "href": "divergence/data_and_setup.html#data",
    "title": "Data & Setup",
    "section": "",
    "text": "We have a phyloseq object containing ASV abundance data through DADA2 denoising in QIIME2 (theory & code). For our divergence analysis we will be utilising the Durance river data used in our R community analysis workshop. This is a 16S dataset with two main metadata groupings:\n\nSites: Upper, Middle, and Lower Durance sampling site (UD, MD, & LD).\nCulture media: Environmental sample (ENV), TSA, KBC, and CVP.\n\nMore info in the R community analysis workbook\nLoad in the phyloseq object.\n\n#Original phyloseq object\nload(\"/pub14/tea/nsc206/NEOF/R_community/data/phyloseq.RData\")\n\nAdditionally, we will load a dissimilarity matrix of weighted unifrac values created through iterative rarefaction:\n\n#Iterative rarefied weighted unifrac data frame\nload(\"/pub14/tea/nsc206/NEOF/R_community_advanced/wunifrac_df_mean.RData\")",
    "crumbs": [
      "Divergence",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "divergence/divergences_split_by_a_group.html",
    "href": "divergence/divergences_split_by_a_group.html",
    "title": "Divergences split by another group",
    "section": "",
    "text": "There are times when you may want to analyse divergences of a grouping within a different grouping.\nThis page will quickly show you how to examine the inter- and intra-divergences of media within the sites. In other words, we want to examine the media inter-/intra-distances of the intra-site distances.\nIf you were to perform this with your own data you would preferably have more data points than the amount in this dataset.\n\n\nWe are starting with the beta_long_tbl object created in the Data format section.\n\nbeta_long_tbl |&gt; head()\n\n\n\n\nThe code sections below carries out the intra-media divergences split by site.\n\n\nFirst we create a new tibble formatted for our analysis.\n\n#Tibble creation\nintra_media_intra_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n    #Filter to only keep intra-site values\n    dplyr::filter(site_L == site_R)\n    #Filter to only keep intra-media values\n    dplyr::filter(media_L == media_R) |&gt;\n    #Filter to remove upper triangle values (i.e. duplicates)\n    dplyr::filter(triangle == \"lower\") |&gt;\nintra_media_intra_site_wunifrac_long_tbl |&gt; head()\n\n\n\n\nWith our tibble we can create a violin plot. We’ll set the x-axis to our media and the colours to our site grouping. You could swap these but I normally find it better to have groupings with more categories split by the x-axis rather than by colour (media = 4 categories, site = 3 categories).\n\n#Violin intra-media divergence plot by site\nintra_media_by_site_violin_plot &lt;-\n    intra_media_intra_site_wunifrac_long_tbl |&gt;\n    #Plot\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin(aes(colour=site_L)) +\n    ggforce::geom_sina(aes(colour=site_L), alpha = 0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                title = \"Intra-media divergence split by site with Weighted UniFrac dissimilarity\",\n                colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_media_divergence_split_by_site_violinplot.png\",\n        plot = intra_media_by_site_violin_plot,\n        device = png, dpi = 300, units = \"mm\", height = 100, width = 170)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_media_divergence_split_by_site_violinplot.png\")\n\n\n\n\nFinally we can carry out statistics to determine if the grouping are statistically different with a pairwise Wilcox test.\n\npairwise.wilcox.test(intra_media_intra_site_wunifrac_long_tbl$value,\n                        intra_media_intra_site_wunifrac_long_tbl$site.media_L)\n\n\n\n\nUnfortunately we have few data points (3 per violin) as we are are only using paired distances where the site and media are identical (intra-site and intra-media). This means low statistical power and has most likely led to all our p-values equalling 1.\nIn our case the paired points are within a set of replicates and can be thought of as intra-replicate distances (the real world samples were split into three). More replicates will give more paired distance points; 3 replicates gives 3 pairs, 4 gives 6, 5 gives 10 (n(n-1)/2).\nIn this case we can see:\n\nThe CVP media produces the lowest intra-site distances\nKBC and TSA produce higher ranges of intra-site distances\nThe intra-distances for the ENV LD samples are much lower compared to the ENV MD and ENV UD samples.\n\nAlthough these are intra-replicate distances this might not be the case for your own data. If you have groupings based on more than 2 primary groupings (e.g. site, media, and date) you should not discuss these types of findings in terms of replicates.\n\n\n\n\nThe code sections below carries out the inter-media divergences split by site.\n\n\nCreate our formatted tibble. This involves first filtering otu all inter-site values to retain the intra-site values. Next, we retain only inter-media values. Note in this case we do not remove the upper triangle values.\n\n#Tibble creation\ninter_media_intra_site_wunifrac_long_tbl &lt;-\n    intra_site_wunifrac_long_tbl |&gt;\n    #Filter to only keep intra-site values\n    dplyr::filter(site_L == site_R) |&gt;\n    #Filter to only keep inter-media values\n    dplyr::filter(media_L != media_R) |&gt;\ninter_media_intra_site_wunifrac_long_tbl |&gt; head()\n\n\n\n\nCreate the inter-media by intra-site violin plot.\n\n#Inter-media by site\n#Violin inter-media divergence plot by site\ninter_media_by_site_violin_plot &lt;-\n    inter_media_intra_site_wunifrac_long_tbl |&gt;\n    #Plot\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin(aes(colour=site_L)) +\n    ggforce::geom_sina(aes(colour=site_L), alpha = 0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                title = \"Inter-media divergence split by site with Weighted UniFrac dissimilarity\",\n                colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_media_divergence_split_by_site_violinplot.png\",\n        plot = intra_site_wunifrac_long_tbl,\n        device = png, dpi = 300, units = \"mm\", height = 100, width = 170)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_media_divergence_split_by_site_violinplot.png\")\n\n\n\n\nRun a pairwise Wilcox test.\n\npairwise.wilcox.test(inter_media_intra_site_wunifrac_long_tbl$value,\n                        inter_media_intra_site_wunifrac_long_tbl$site.media_L)\n\nImmediately noticeable is that a warning message about exact p-value with ties shows up. This can be ignored and you could suppress the message by including the option exact=FALSE.\n\n\n\nAs we are working with intra-media values we have a lot more values/points and therefore more power. The main points from our analysis are:\n\nThere are no meaningful differences between the different media based groups (LD_CVP, LD_KBC, LD_TSA, MD_CVP, MD_KBC, etc.). Additionally, their dissimilarity values have very large ranges.\nLD_ENV has the highest dissimilarity values with a low range and are significantly different to al other groupings except LD_KBC\nMD_ENV & UD_ENV are quite similar with generally larger values than the CVP, KBC, and TSA groupings.\n\nThey are significantly different to the following groupings:\n\nMD_ENV to: LD_ENV, MD_CVP, MD_TSA, UD_CVP, UD_KBC, & UD_TSA\nUD_ENV to: LD_ENV, MD_TSA, UD_CVP, UD-KBC, & UD_TSA",
    "crumbs": [
      "Divergence",
      "Advanced",
      "Divergences split by another group"
    ]
  },
  {
    "objectID": "divergence/divergences_split_by_a_group.html#data",
    "href": "divergence/divergences_split_by_a_group.html#data",
    "title": "Divergences split by another group",
    "section": "",
    "text": "We are starting with the beta_long_tbl object created in the Data format section.\n\nbeta_long_tbl |&gt; head()",
    "crumbs": [
      "Divergence",
      "Advanced",
      "Divergences split by another group"
    ]
  },
  {
    "objectID": "divergence/divergences_split_by_a_group.html#intra-media-by-intra-site",
    "href": "divergence/divergences_split_by_a_group.html#intra-media-by-intra-site",
    "title": "Divergences split by another group",
    "section": "",
    "text": "The code sections below carries out the intra-media divergences split by site.\n\n\nFirst we create a new tibble formatted for our analysis.\n\n#Tibble creation\nintra_media_intra_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n    #Filter to only keep intra-site values\n    dplyr::filter(site_L == site_R)\n    #Filter to only keep intra-media values\n    dplyr::filter(media_L == media_R) |&gt;\n    #Filter to remove upper triangle values (i.e. duplicates)\n    dplyr::filter(triangle == \"lower\") |&gt;\nintra_media_intra_site_wunifrac_long_tbl |&gt; head()\n\n\n\n\nWith our tibble we can create a violin plot. We’ll set the x-axis to our media and the colours to our site grouping. You could swap these but I normally find it better to have groupings with more categories split by the x-axis rather than by colour (media = 4 categories, site = 3 categories).\n\n#Violin intra-media divergence plot by site\nintra_media_by_site_violin_plot &lt;-\n    intra_media_intra_site_wunifrac_long_tbl |&gt;\n    #Plot\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin(aes(colour=site_L)) +\n    ggforce::geom_sina(aes(colour=site_L), alpha = 0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                title = \"Intra-media divergence split by site with Weighted UniFrac dissimilarity\",\n                colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_media_divergence_split_by_site_violinplot.png\",\n        plot = intra_media_by_site_violin_plot,\n        device = png, dpi = 300, units = \"mm\", height = 100, width = 170)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_media_divergence_split_by_site_violinplot.png\")\n\n\n\n\nFinally we can carry out statistics to determine if the grouping are statistically different with a pairwise Wilcox test.\n\npairwise.wilcox.test(intra_media_intra_site_wunifrac_long_tbl$value,\n                        intra_media_intra_site_wunifrac_long_tbl$site.media_L)\n\n\n\n\nUnfortunately we have few data points (3 per violin) as we are are only using paired distances where the site and media are identical (intra-site and intra-media). This means low statistical power and has most likely led to all our p-values equalling 1.\nIn our case the paired points are within a set of replicates and can be thought of as intra-replicate distances (the real world samples were split into three). More replicates will give more paired distance points; 3 replicates gives 3 pairs, 4 gives 6, 5 gives 10 (n(n-1)/2).\nIn this case we can see:\n\nThe CVP media produces the lowest intra-site distances\nKBC and TSA produce higher ranges of intra-site distances\nThe intra-distances for the ENV LD samples are much lower compared to the ENV MD and ENV UD samples.\n\nAlthough these are intra-replicate distances this might not be the case for your own data. If you have groupings based on more than 2 primary groupings (e.g. site, media, and date) you should not discuss these types of findings in terms of replicates.",
    "crumbs": [
      "Divergence",
      "Advanced",
      "Divergences split by another group"
    ]
  },
  {
    "objectID": "divergence/divergences_split_by_a_group.html#inter-media-by-intra-site",
    "href": "divergence/divergences_split_by_a_group.html#inter-media-by-intra-site",
    "title": "Divergences split by another group",
    "section": "",
    "text": "The code sections below carries out the inter-media divergences split by site.\n\n\nCreate our formatted tibble. This involves first filtering otu all inter-site values to retain the intra-site values. Next, we retain only inter-media values. Note in this case we do not remove the upper triangle values.\n\n#Tibble creation\ninter_media_intra_site_wunifrac_long_tbl &lt;-\n    intra_site_wunifrac_long_tbl |&gt;\n    #Filter to only keep intra-site values\n    dplyr::filter(site_L == site_R) |&gt;\n    #Filter to only keep inter-media values\n    dplyr::filter(media_L != media_R) |&gt;\ninter_media_intra_site_wunifrac_long_tbl |&gt; head()\n\n\n\n\nCreate the inter-media by intra-site violin plot.\n\n#Inter-media by site\n#Violin inter-media divergence plot by site\ninter_media_by_site_violin_plot &lt;-\n    inter_media_intra_site_wunifrac_long_tbl |&gt;\n    #Plot\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin(aes(colour=site_L)) +\n    ggforce::geom_sina(aes(colour=site_L), alpha = 0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                title = \"Inter-media divergence split by site with Weighted UniFrac dissimilarity\",\n                colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_media_divergence_split_by_site_violinplot.png\",\n        plot = intra_site_wunifrac_long_tbl,\n        device = png, dpi = 300, units = \"mm\", height = 100, width = 170)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_media_divergence_split_by_site_violinplot.png\")\n\n\n\n\nRun a pairwise Wilcox test.\n\npairwise.wilcox.test(inter_media_intra_site_wunifrac_long_tbl$value,\n                        inter_media_intra_site_wunifrac_long_tbl$site.media_L)\n\nImmediately noticeable is that a warning message about exact p-value with ties shows up. This can be ignored and you could suppress the message by including the option exact=FALSE.\n\n\n\nAs we are working with intra-media values we have a lot more values/points and therefore more power. The main points from our analysis are:\n\nThere are no meaningful differences between the different media based groups (LD_CVP, LD_KBC, LD_TSA, MD_CVP, MD_KBC, etc.). Additionally, their dissimilarity values have very large ranges.\nLD_ENV has the highest dissimilarity values with a low range and are significantly different to al other groupings except LD_KBC\nMD_ENV & UD_ENV are quite similar with generally larger values than the CVP, KBC, and TSA groupings.\n\nThey are significantly different to the following groupings:\n\nMD_ENV to: LD_ENV, MD_CVP, MD_TSA, UD_CVP, UD_KBC, & UD_TSA\nUD_ENV to: LD_ENV, MD_TSA, UD_CVP, UD-KBC, & UD_TSA",
    "crumbs": [
      "Divergence",
      "Advanced",
      "Divergences split by another group"
    ]
  },
  {
    "objectID": "divergence/inter_divergence.html",
    "href": "divergence/inter_divergence.html",
    "title": "Inter-group overview",
    "section": "",
    "text": "With our formatted data we can also carry out inter-group divergence analysis. This is analysing the distances between groups (e.g. internet is a network between different networks).\nIn this section we will:\n\nAnalyse the Inter-site divergence (River locations: LD, MD, & UD)\nExercise: Repeat the previous steps for Inter-media divergence (CVP, ENV, KBC, & TSA)\n\n\n\n\n\n\nWith inter-group divergence analysis we are trying to determine which groups have lower and higher dissimilarity between each other.\nThis can be especially useful when comparing three or more sample groups as it let’s us more confidently determine which sample groups are more similar to each other.\nFor example, let’s say we had a study of salmon gut microbiomes. The three sample groups are:\n\nWild salmon\nFarmed salmon fed on a non-vegetarian diet\nFarmed salmon fed on a vegetarian diet\n\nIn this case it is likely the dissimilarity distance between the farmed salmon with non-vegetarian and vegetarian diets is more similar than either groups distances to the wild fish. However, does one of the farmed fish groups have lower dissimilarity scores to the wild fish compared to the other farmed group? If so, is this a significant difference? These results could then lead into other types of analysis such as biomarker detection.\n\n\n\n\n\n\nWith inter-group divergence we look at the dissimilarity distances between all pairs between different sample groups.\n\n\nAs with the intra-group intro we’ll use 3 groups (G1, G2, & G3) each with 3 samples. These can be seen in the ordination plot (e.g. PCoA or NMDS).\n\n\n\n\n\n\n\n\n\n\n\n\nIt is more difficult to work with inter-group distances than intra-group distances. When we do this we need each inter group distance twice as we need it for the first/left group and for the second/right group.\nThe below plot displays each inter-group pairwise distance for the G1 samples:\n\n\n\n\n\n\n\n\n\nNext is all the inter-group pairwise distances for the G2 samples:\n\n\n\n\n\n\n\n\n\nAll the inter-group pairwise distances for the G3 samples:\n\n\n\n\n\n\n\n\n\nFinally, all the inter-group distances displayed at once:\n\n\n\n\n\n\n\n\n\nIn this example with 3 groups, each with 3 samples, we have a total of 54 inter group distances. There are 18 inter-group distances per group (18 * 3 = 54). Or another way to think about it is that each sample has 6 inter group distances and there are 9 samples (6 * 9 = 54).\nIf we had 4 groups with 10 samples each we would have:\n\n45 intra-group distances (10*(10-1)/2 = 45)\n1,200 inter-group distances (30*40=1200)\n\nBecause there is more data for inter-group analysis we may be able to carry it out even when there are too few data points for intra-group analysis.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-group overview"
    ]
  },
  {
    "objectID": "divergence/inter_divergence.html#inter-group-divergence-purpose",
    "href": "divergence/inter_divergence.html#inter-group-divergence-purpose",
    "title": "Inter-group overview",
    "section": "",
    "text": "With inter-group divergence analysis we are trying to determine which groups have lower and higher dissimilarity between each other.\nThis can be especially useful when comparing three or more sample groups as it let’s us more confidently determine which sample groups are more similar to each other.\nFor example, let’s say we had a study of salmon gut microbiomes. The three sample groups are:\n\nWild salmon\nFarmed salmon fed on a non-vegetarian diet\nFarmed salmon fed on a vegetarian diet\n\nIn this case it is likely the dissimilarity distance between the farmed salmon with non-vegetarian and vegetarian diets is more similar than either groups distances to the wild fish. However, does one of the farmed fish groups have lower dissimilarity scores to the wild fish compared to the other farmed group? If so, is this a significant difference? These results could then lead into other types of analysis such as biomarker detection.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-group overview"
    ]
  },
  {
    "objectID": "divergence/inter_divergence.html#groupings-and-pairs",
    "href": "divergence/inter_divergence.html#groupings-and-pairs",
    "title": "Inter-group overview",
    "section": "",
    "text": "With inter-group divergence we look at the dissimilarity distances between all pairs between different sample groups.\n\n\nAs with the intra-group intro we’ll use 3 groups (G1, G2, & G3) each with 3 samples. These can be seen in the ordination plot (e.g. PCoA or NMDS).\n\n\n\n\n\n\n\n\n\n\n\n\nIt is more difficult to work with inter-group distances than intra-group distances. When we do this we need each inter group distance twice as we need it for the first/left group and for the second/right group.\nThe below plot displays each inter-group pairwise distance for the G1 samples:\n\n\n\n\n\n\n\n\n\nNext is all the inter-group pairwise distances for the G2 samples:\n\n\n\n\n\n\n\n\n\nAll the inter-group pairwise distances for the G3 samples:\n\n\n\n\n\n\n\n\n\nFinally, all the inter-group distances displayed at once:\n\n\n\n\n\n\n\n\n\nIn this example with 3 groups, each with 3 samples, we have a total of 54 inter group distances. There are 18 inter-group distances per group (18 * 3 = 54). Or another way to think about it is that each sample has 6 inter group distances and there are 9 samples (6 * 9 = 54).\nIf we had 4 groups with 10 samples each we would have:\n\n45 intra-group distances (10*(10-1)/2 = 45)\n1,200 inter-group distances (30*40=1200)\n\nBecause there is more data for inter-group analysis we may be able to carry it out even when there are too few data points for intra-group analysis.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-group overview"
    ]
  },
  {
    "objectID": "divergence/inter_site_divergence.html",
    "href": "divergence/inter_site_divergence.html",
    "title": "Inter-site divergence",
    "section": "",
    "text": "On this page we’ll examine the dissimilarity of samples between the sites, i.e. inter-site divergence. As a reminder, the sites are different parts of the Durance river:\n\nUpper Durance (UD)\nMiddle Durance (MD)\nLower Durance (LD)\n\nTo analyse the Inter-site divergence we will:\n\nSubset our long tibble of distances and metadata to contain both sets (lower and upper triangle) of inter-group distances.\nCreate a violin plot of the inter-site distances\nCarry out a pairwise wilcox test to statistically compare the different inter-site divergences (UD to MD, UD to LD, and MD to LD).\n\nAs a reminder we are using weighted UniFrac distances.\n\n\n\n\n\nWe need to subset our tibble to only have the inter-site distances.\nIn this case we filter our rows with ‘dplyr::filter()’ to retain observations where site_L and site_R are different/not identical (site_L != site_R). This removes the intra-site rows to only keep the inter-site rows.\nWe’ll pipe (|&gt;) our weighted UniFrac long tibble to different ‘dplyr::filter()’ commands.\n\nIn you own analyses and the exercise ensure you use the columns for the intra-grouping you are interested in.\n\nE.g. you would use media_L != media_R when analysing inter-media divergence of this dataset.\n\n\n\n#Subset long tibble so only rows where site_R and site_L are not identical\n#I.e. the long tibble only contains paired distances between samples of \n# different sites (inter-site distances)\ninter_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        dplyr::filter(site_L != site_R)\n#Check head of long df\ninter_site_wunifrac_long_tbl |&gt; head()\n\nUnlike our intra-site divergence we keep both the lower and upper triangle values as the duplicate values are needed. These duplicate values will be split by the x-axis in our upcoming violin plots, more info further down.\n\n\n\n\n\n\nWe’re going to make violin plots to view the inter-group distances for each site. This means we’ll have a violin for UD, MD, and LD in our plots.\n\n\nFirst we’ll create a violin plot as we did for the intra-distances.\n\n#Inter-site divergence violin plot\ninter_site_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Inter-site divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_site_divergence_violinplot.png\",\n        plot = inter_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_site_divergence_violinplot.png\")\n\nThe produced plot shows the inter-site distances for each site. It is useful but we can’t tell what specific inter-site distances each point represents.\n\n\n\nLet’s edit our above violin plot by adding colours to the points. These will be coloured by the matching paired site grouping (i.e. left media on x axis and right media to colour points).\n\n#Inter-site divergence violin plot points coloured by right site\ninter_site_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(aes(colour = site_R), alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Inter-site divergence with Weighted UniFrac dissimilarity\",\n                    subtitle=\"Points coloured by site of paired distance sample\",\n                    colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_site_divergence_violinplot.png\",\n        plot = inter_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_site_divergence_violinplot.png\")\n\nAs you can see the points are separated in each violin by the assigned right Site information. In the LD violin the left green points are the LD-MD distances and the right blue points are the LD-UD distances. This means that we can examine:\n\nThe inter-site divergences between sites (comparing the violins)\nThe inter-site divergences within a site (compairng the points in a violin)\n\nIn the plot you will notice that the green (MD) points of the LD violin are the same as the red (LD) points in the MD violin. These are the same values except the left and right samples are swapped around (i.e. LD-MD, and MD-LD). This is why we keep the lower and upper triangle values so we can see all the values in each violin.\n\n\nInter-media without upper triangle\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor our statistical analysis we’ll carry out pairwise wilcox tests. We’ll compare the inter-site dissimilarity distances in 2 groupings:\n\nBetween sites: Comparing the inter-site divergence between the three sites (UD, MD, and LD).\nBetween pairs: Comparing the inter-site divergence between the pairs of sites (UD-MD, UD-LD, and MD-LD).\n\n\n\nWe will compare the inter-site divergences per group using the site_L column with a wilcox test (using site_R would produce the same results). In relation to our violin plot, this will determine if there are significant differences between the profiles of the three violins.\n\npairwise.wilcox.test(inter_site_wunifrac_long_tbl$value,\n                        inter_site_wunifrac_long_tbl$site_L)\n\nNone of our p-values are significant, i.e. there is no statistical difference between the inter-site divergences. This coincides with our violin plot where does is a lot of overlap between the violins.\n\n\n\nWe can also compare all the site pairwise divergences. To carry this out we’ll create a column called site_L_R which contains the site pairing (e.g. LD_MD). We’ll use this column as our grouping for the wilcox test.\nThe main concern for our dat is that we want unique distance values within each site pair grouping. To create the paired site column, site_L_R, we’e use a tidyverse based pipeline. The steps are below:\n\nFilter to remove the upper triangle rows with dplyr::filter() - This is to remove duplicated values which we do not want for these statistics.\nConvert the site_L amd site_R columns to characters with dplyr::mutate() and dplyr::across(). - These columns are originally factors which can’t be ordered alphabetically unlike characters. - This is required for the next step.\nCreate a new column with left and right sample info, site_L_R, with dplyr::mutate(). - We ensure the first site (alphabetically) is the prefix by specifying both columns within the pmin() function. - The suffix is set as the last (alphabetically), i.e. second of the two, site with pmax(). - This ensures all the pairings are in the same orientation (i.e. we won’t have some values under LD-MD and some under MD-LD).\n\n\n#Create new tibble for site pair statistics\ninter_site_pairs_wunifrac_long_tbl &lt;-\n        inter_site_wunifrac_long_tbl |&gt;\n                #Retain lower triangle rows\n                dplyr::filter(triangle == \"lower\") |&gt;\n                #Convert site_L and site_R to character columns\n                #These are originally factors which cannot be ordered alphabetically\n                dplyr::mutate(dplyr::across(c(site_L,site_R), as.character)) |&gt;\n                #Create new site_L_R column\n                #Ensure the first alphabetical site (pmin) is the prefix\n                #and the second/last alphabetical site (pmax) is the suffix\n                dplyr::mutate(site_L_R = \n                        paste0(pmin(site_L,site_R),\"_\",pmax(site_L,site_R)))\n\n#Wilcox\npairwise.wilcox.test(inter_site_pairs_wunifrac_long_tbl$value,\n                        inter_site_pairs_wunifrac_long_tbl$site_L_R)\n\nThis allows us to see if there are any differences between the distances between pairings. None, of the p-values are significant though the p-value between LD_MD and LD_UD is the highest. This lines up with the violin plot where the profiles of the two sets of points for the LD violin (LD_MD and LD_UD) are incredibly similar\n\n\n\n\n\n\n\nThis analysis shows little to no difference between the inter-site divergences. This could indicate the three sites are equally dissimilar to each other. In other words the community difference between LD and MD is the same as between MD and UD which is again the same as the difference between LD and UD.\nSaying that, there is slight evidence (nothing statistically significant) that the MD and UD groups are a bit more similar to each other than they are to the LD.\nOf course it could be that another grouping is more important and obscuring and differences caused by site.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-site divergence"
    ]
  },
  {
    "objectID": "divergence/inter_site_divergence.html#inter-site-tibble",
    "href": "divergence/inter_site_divergence.html#inter-site-tibble",
    "title": "Inter-site divergence",
    "section": "",
    "text": "We need to subset our tibble to only have the inter-site distances.\nIn this case we filter our rows with ‘dplyr::filter()’ to retain observations where site_L and site_R are different/not identical (site_L != site_R). This removes the intra-site rows to only keep the inter-site rows.\nWe’ll pipe (|&gt;) our weighted UniFrac long tibble to different ‘dplyr::filter()’ commands.\n\nIn you own analyses and the exercise ensure you use the columns for the intra-grouping you are interested in.\n\nE.g. you would use media_L != media_R when analysing inter-media divergence of this dataset.\n\n\n\n#Subset long tibble so only rows where site_R and site_L are not identical\n#I.e. the long tibble only contains paired distances between samples of \n# different sites (inter-site distances)\ninter_site_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        dplyr::filter(site_L != site_R)\n#Check head of long df\ninter_site_wunifrac_long_tbl |&gt; head()\n\nUnlike our intra-site divergence we keep both the lower and upper triangle values as the duplicate values are needed. These duplicate values will be split by the x-axis in our upcoming violin plots, more info further down.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-site divergence"
    ]
  },
  {
    "objectID": "divergence/inter_site_divergence.html#violin-plot",
    "href": "divergence/inter_site_divergence.html#violin-plot",
    "title": "Inter-site divergence",
    "section": "",
    "text": "We’re going to make violin plots to view the inter-group distances for each site. This means we’ll have a violin for UD, MD, and LD in our plots.\n\n\nFirst we’ll create a violin plot as we did for the intra-distances.\n\n#Inter-site divergence violin plot\ninter_site_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Inter-site divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_site_divergence_violinplot.png\",\n        plot = inter_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_site_divergence_violinplot.png\")\n\nThe produced plot shows the inter-site distances for each site. It is useful but we can’t tell what specific inter-site distances each point represents.\n\n\n\nLet’s edit our above violin plot by adding colours to the points. These will be coloured by the matching paired site grouping (i.e. left media on x axis and right media to colour points).\n\n#Inter-site divergence violin plot points coloured by right site\ninter_site_violin_plot &lt;-\n    inter_site_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = site_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(aes(colour = site_R), alpha=0.5) +\n    ggplot2::labs(x = \"Site\", y = \"Weighted UniFrac\",\n                    title=\"Inter-site divergence with Weighted UniFrac dissimilarity\",\n                    subtitle=\"Points coloured by site of paired distance sample\",\n                    colour = \"Site\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_inter_site_divergence_violinplot.png\",\n        plot = inter_site_violin_plot,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_inter_site_divergence_violinplot.png\")\n\nAs you can see the points are separated in each violin by the assigned right Site information. In the LD violin the left green points are the LD-MD distances and the right blue points are the LD-UD distances. This means that we can examine:\n\nThe inter-site divergences between sites (comparing the violins)\nThe inter-site divergences within a site (compairng the points in a violin)\n\nIn the plot you will notice that the green (MD) points of the LD violin are the same as the red (LD) points in the MD violin. These are the same values except the left and right samples are swapped around (i.e. LD-MD, and MD-LD). This is why we keep the lower and upper triangle values so we can see all the values in each violin.\n\n\nInter-media without upper triangle",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-site divergence"
    ]
  },
  {
    "objectID": "divergence/inter_site_divergence.html#stats",
    "href": "divergence/inter_site_divergence.html#stats",
    "title": "Inter-site divergence",
    "section": "",
    "text": "For our statistical analysis we’ll carry out pairwise wilcox tests. We’ll compare the inter-site dissimilarity distances in 2 groupings:\n\nBetween sites: Comparing the inter-site divergence between the three sites (UD, MD, and LD).\nBetween pairs: Comparing the inter-site divergence between the pairs of sites (UD-MD, UD-LD, and MD-LD).\n\n\n\nWe will compare the inter-site divergences per group using the site_L column with a wilcox test (using site_R would produce the same results). In relation to our violin plot, this will determine if there are significant differences between the profiles of the three violins.\n\npairwise.wilcox.test(inter_site_wunifrac_long_tbl$value,\n                        inter_site_wunifrac_long_tbl$site_L)\n\nNone of our p-values are significant, i.e. there is no statistical difference between the inter-site divergences. This coincides with our violin plot where does is a lot of overlap between the violins.\n\n\n\nWe can also compare all the site pairwise divergences. To carry this out we’ll create a column called site_L_R which contains the site pairing (e.g. LD_MD). We’ll use this column as our grouping for the wilcox test.\nThe main concern for our dat is that we want unique distance values within each site pair grouping. To create the paired site column, site_L_R, we’e use a tidyverse based pipeline. The steps are below:\n\nFilter to remove the upper triangle rows with dplyr::filter() - This is to remove duplicated values which we do not want for these statistics.\nConvert the site_L amd site_R columns to characters with dplyr::mutate() and dplyr::across(). - These columns are originally factors which can’t be ordered alphabetically unlike characters. - This is required for the next step.\nCreate a new column with left and right sample info, site_L_R, with dplyr::mutate(). - We ensure the first site (alphabetically) is the prefix by specifying both columns within the pmin() function. - The suffix is set as the last (alphabetically), i.e. second of the two, site with pmax(). - This ensures all the pairings are in the same orientation (i.e. we won’t have some values under LD-MD and some under MD-LD).\n\n\n#Create new tibble for site pair statistics\ninter_site_pairs_wunifrac_long_tbl &lt;-\n        inter_site_wunifrac_long_tbl |&gt;\n                #Retain lower triangle rows\n                dplyr::filter(triangle == \"lower\") |&gt;\n                #Convert site_L and site_R to character columns\n                #These are originally factors which cannot be ordered alphabetically\n                dplyr::mutate(dplyr::across(c(site_L,site_R), as.character)) |&gt;\n                #Create new site_L_R column\n                #Ensure the first alphabetical site (pmin) is the prefix\n                #and the second/last alphabetical site (pmax) is the suffix\n                dplyr::mutate(site_L_R = \n                        paste0(pmin(site_L,site_R),\"_\",pmax(site_L,site_R)))\n\n#Wilcox\npairwise.wilcox.test(inter_site_pairs_wunifrac_long_tbl$value,\n                        inter_site_pairs_wunifrac_long_tbl$site_L_R)\n\nThis allows us to see if there are any differences between the distances between pairings. None, of the p-values are significant though the p-value between LD_MD and LD_UD is the highest. This lines up with the violin plot where the profiles of the two sets of points for the LD violin (LD_MD and LD_UD) are incredibly similar",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-site divergence"
    ]
  },
  {
    "objectID": "divergence/inter_site_divergence.html#interpretation",
    "href": "divergence/inter_site_divergence.html#interpretation",
    "title": "Inter-site divergence",
    "section": "",
    "text": "This analysis shows little to no difference between the inter-site divergences. This could indicate the three sites are equally dissimilar to each other. In other words the community difference between LD and MD is the same as between MD and UD which is again the same as the difference between LD and UD.\nSaying that, there is slight evidence (nothing statistically significant) that the MD and UD groups are a bit more similar to each other than they are to the LD.\nOf course it could be that another grouping is more important and obscuring and differences caused by site.",
    "crumbs": [
      "Divergence",
      "Inter-group divergence",
      "Inter-site divergence"
    ]
  },
  {
    "objectID": "divergence/intra_media_exercise.html",
    "href": "divergence/intra_media_exercise.html",
    "title": "Intra-media exercise",
    "section": "",
    "text": "Now that you have worked through carrying out an intra-group analysis with site you will do the same with media.\nFor this exercise you will create your own code. Solutions are available in the solution boxes below but please make a strong attempt before looking at them.\nI would recommend copying, pasting, and editing your code from the intra-site analysis. Ensure you change all the variable names you need to, it is very easy to miss variables and column/row names you need to change.\n\n\n\n\n\nThe steps to carry out this exercise are below along with the solution expandable boxes.\n\n\nThe first step is to create a tibble containing only observations/rows of intra-media distances from the beta_long_tbl tibble. Call this variable: intra_media_wunifrac_long_tbl\nTip: You will need to use the columns media_L and media_R.\n\n\nInter-media tibble creation\n\n\n#Subset long tibble so only rows where media_L and media_R are identical of the lower triangle\n#I.e. the long tibble only contains one set of paired distances within media (Intra-media) \nintra_media_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        #Filter to keep lower triangle rows\n        dplyr::filter(triangle == \"lower\") |&gt;\n        #Filter to keep rows where media_L is the same as media_R (Intra-media)\n        dplyr::filter(site_L == site_R)\n#Check head of long tbl\nintra_media_wunifrac_long_tbl |&gt; head()\n\n\n\n\n\nWith the formatted tibble the next step is to create a violin plot. Ensure the x axis is separated by the four media groupings (CVP, ENV, KBC, and TSA).\nYou are aiming for the below plot :\nNote: the points are randomly distributed on the x-axis every time you run the command. Therefore yours will most likely look slightly different.\n\n\n\n\n\nInter-media violin plot code solution\n\n\n#Intra-media divergence violin plot\nintra_media_violin_plot &lt;-\n    intra_media_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                    title=\"Intra-media divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_media_divergence_violinplot.png\",\n        plot = intra_media_wunifrac_long_tbl,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_media_divergence_violinplot.png\")\n\n\nIn the plot we can see:\n\nThe ENV group has the highest range of distances and also has the highest dissimilarity distances.\nThe CVP group has the lowest range and lowest dissimilarity distances.\nThe KBC and TSA groups have quite similar values to each other with most of their dissimilarity distances being between 0.05 and 0.25.\n\n\n\n\nFinally, carry out the pairwise wilcox test to determine if there are significant difference between the inter-media distances.\n\n\nInter-media pairwise wilcox\n\n\npairwise.wilcox.test(intra_media_wunifrac_long_tbl$value,\n                        intra_media_wunifrac_long_tbl$media_L)\n\n\nIn this case you should see there is a significant difference between the intra-group distances of all the different media types except for KBC against TSA.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-media exercise"
    ]
  },
  {
    "objectID": "divergence/intra_media_exercise.html#steps",
    "href": "divergence/intra_media_exercise.html#steps",
    "title": "Intra-media exercise",
    "section": "",
    "text": "The steps to carry out this exercise are below along with the solution expandable boxes.\n\n\nThe first step is to create a tibble containing only observations/rows of intra-media distances from the beta_long_tbl tibble. Call this variable: intra_media_wunifrac_long_tbl\nTip: You will need to use the columns media_L and media_R.\n\n\nInter-media tibble creation\n\n\n#Subset long tibble so only rows where media_L and media_R are identical of the lower triangle\n#I.e. the long tibble only contains one set of paired distances within media (Intra-media) \nintra_media_wunifrac_long_tbl &lt;-\n    beta_long_tbl |&gt;\n        #Filter to keep lower triangle rows\n        dplyr::filter(triangle == \"lower\") |&gt;\n        #Filter to keep rows where media_L is the same as media_R (Intra-media)\n        dplyr::filter(site_L == site_R)\n#Check head of long tbl\nintra_media_wunifrac_long_tbl |&gt; head()\n\n\n\n\n\nWith the formatted tibble the next step is to create a violin plot. Ensure the x axis is separated by the four media groupings (CVP, ENV, KBC, and TSA).\nYou are aiming for the below plot :\nNote: the points are randomly distributed on the x-axis every time you run the command. Therefore yours will most likely look slightly different.\n\n\n\n\n\nInter-media violin plot code solution\n\n\n#Intra-media divergence violin plot\nintra_media_violin_plot &lt;-\n    intra_media_wunifrac_long_tbl |&gt;\n    ggplot2::ggplot(aes(x = media_L, y = value)) +\n    ggplot2::geom_violin() +\n    ggforce::geom_sina(alpha=0.5) +\n    ggplot2::labs(x = \"Media\", y = \"Weighted UniFrac\",\n                    title=\"Intra-media divergence with Weighted UniFrac dissimilarity\")\n#Save ggplot2 object with ggsave\nggsave(filename = \"./wunifrac_intra_media_divergence_violinplot.png\",\n        plot = intra_media_wunifrac_long_tbl,\n        device = \"png\", dpi = 300, units = \"mm\", height = 100, width = 150)\n#Display plot\nIRdisplay::display_png(file = \"./wunifrac_intra_media_divergence_violinplot.png\")\n\n\nIn the plot we can see:\n\nThe ENV group has the highest range of distances and also has the highest dissimilarity distances.\nThe CVP group has the lowest range and lowest dissimilarity distances.\nThe KBC and TSA groups have quite similar values to each other with most of their dissimilarity distances being between 0.05 and 0.25.\n\n\n\n\nFinally, carry out the pairwise wilcox test to determine if there are significant difference between the inter-media distances.\n\n\nInter-media pairwise wilcox\n\n\npairwise.wilcox.test(intra_media_wunifrac_long_tbl$value,\n                        intra_media_wunifrac_long_tbl$media_L)\n\n\nIn this case you should see there is a significant difference between the intra-group distances of all the different media types except for KBC against TSA.",
    "crumbs": [
      "Divergence",
      "Intra-group divergence",
      "Intra-media exercise"
    ]
  },
  {
    "objectID": "divergence/lower_triangle.html",
    "href": "divergence/lower_triangle.html",
    "title": "Lower triangle",
    "section": "",
    "text": "Our first formatting step is to create a long tibble of the dissimilarity values in the lower triangle of the dissimilarity matrix.\n\n\n\n\n\nBefore we start, ensure you have loaded the phyloseq object and dissimilarity matrix as shown in data and setup page.\nOnce it is loaded we can view the top 10 rows and columns of the matrix.\n\n#Check first 10 rows and columns of beta dissimilarity matrix\nbeta_df_mean[1:10,1:10]\n\n\n\n\n\n\n\nThe next step is to convert the matrix so all but the lower triangle values are NAs.\n\n\nWe’ll first carry this out with a demonstration.\nCreate a small version of our distance matrix so it is easy to view.\n\n#Create demo distance matrix\ndemo_mat &lt;- beta_df_mean[1:6,1:6]\ndemo_mat\n\nWe will use the upper.tri() function for our conversion. It creates a logical matrix from a matrix where the upper triangle values are TRUE and the lower triangle values are FALSE.\nThe diagonal values are set with the option diag=. We will set them to TRUE with diag=TRUE.\n\n#Demonstration of upper.tri\nupper.tri(demo_mat, diag=TRUE)\n\nWe can then subset our matrix with this function to assign the upper triangle and diagonal values as NA.\n\n#Convert upper triangle and diaganol to NA\ndemo_mat[upper.tri(demo_mat, diag=TRUE)] &lt;- NA\ndemo_mat\n\n\n\n\nWith the above demonstrated we’ll create our lower triangle matrix. For this we will create a new object for the lower triangle matrix so our edits won’t change the initial beta_df_mean object which we will need later.\n\n#Create new lower triangle matrix\nlower_tri_mat &lt;- beta_df_mean\n#Convert upper triangle and the diagonal to NAs\nlower_tri_mat[upper.tri(lower_tri_mat, diag = TRUE)] &lt;- NA\n#Check first 10 rows and columns\nlower_tri_mat[1:10,1:10]\n\n\n\n\n\n\n\n\nWith our lower triangle matrix we can create a long tibble for future ggplot2 plot production.\nFor this code we utilising piping (|&gt;) with the below steps:\n\nConvert the matrix lower_tri_mat to a data frame with as.data.frame()\n\nAlthough we will ultimately end up with a tibble we need to carry this out for the next steps to run successfully\nIf we converted the matrix to a tibble with tibble::as_tibble() it would remove the row names which are required for the next command\n\nMove the row names to a column called “Sample_L” with tibble::rownames_to_column\nLongify all the columns except the “Sample_L” column with tidyr::pivot_longer()\n\nThis also serves to convert our data frame to a tibble\n\nRemove rows with NAs (i.e. the upper triangle and diagonal values) with tidyr::drop_na()\nCreate a column called triangle with each value being “lower” with dplyr::mutate(), this is required later\n\n\n#Convert to long data frame of paired distance values\n#We will refer to the different samples in a pair as the left and right pair\nbeta_long_tbl &lt;- \n    lower_tri_mat |&gt;\n        #Convert to data frame\n        as.data.frame() |&gt;\n        #Create column from row names (Sample_L, L = left)\n        tibble::rownames_to_column(\"Sample_L\") |&gt;\n        #Longify\n        #Set names to \"Sample_R\" column (R = right)\n        tidyr::pivot_longer(!Sample_L, names_to=\"Sample_R\", values_to=\"value\") |&gt;\n        #Remove rows with an NA\n        tidyr::drop_na() |&gt;\n        #Create triangle column containing value \"lower\" for each row\n        dplyr::mutate(triangle=\"lower\")\n#Check head of long tibble\nbeta_long_tbl |&gt; head()\n\nGreat! Next we’ll add our metadata to this long data frame.",
    "crumbs": [
      "Divergence",
      "Data format",
      "Lower triangle"
    ]
  },
  {
    "objectID": "divergence/lower_triangle.html#dissimilarity-matrix",
    "href": "divergence/lower_triangle.html#dissimilarity-matrix",
    "title": "Lower triangle",
    "section": "",
    "text": "Before we start, ensure you have loaded the phyloseq object and dissimilarity matrix as shown in data and setup page.\nOnce it is loaded we can view the top 10 rows and columns of the matrix.\n\n#Check first 10 rows and columns of beta dissimilarity matrix\nbeta_df_mean[1:10,1:10]",
    "crumbs": [
      "Divergence",
      "Data format",
      "Lower triangle"
    ]
  },
  {
    "objectID": "divergence/lower_triangle.html#lower-triangle-matrix",
    "href": "divergence/lower_triangle.html#lower-triangle-matrix",
    "title": "Lower triangle",
    "section": "",
    "text": "The next step is to convert the matrix so all but the lower triangle values are NAs.\n\n\nWe’ll first carry this out with a demonstration.\nCreate a small version of our distance matrix so it is easy to view.\n\n#Create demo distance matrix\ndemo_mat &lt;- beta_df_mean[1:6,1:6]\ndemo_mat\n\nWe will use the upper.tri() function for our conversion. It creates a logical matrix from a matrix where the upper triangle values are TRUE and the lower triangle values are FALSE.\nThe diagonal values are set with the option diag=. We will set them to TRUE with diag=TRUE.\n\n#Demonstration of upper.tri\nupper.tri(demo_mat, diag=TRUE)\n\nWe can then subset our matrix with this function to assign the upper triangle and diagonal values as NA.\n\n#Convert upper triangle and diaganol to NA\ndemo_mat[upper.tri(demo_mat, diag=TRUE)] &lt;- NA\ndemo_mat\n\n\n\n\nWith the above demonstrated we’ll create our lower triangle matrix. For this we will create a new object for the lower triangle matrix so our edits won’t change the initial beta_df_mean object which we will need later.\n\n#Create new lower triangle matrix\nlower_tri_mat &lt;- beta_df_mean\n#Convert upper triangle and the diagonal to NAs\nlower_tri_mat[upper.tri(lower_tri_mat, diag = TRUE)] &lt;- NA\n#Check first 10 rows and columns\nlower_tri_mat[1:10,1:10]",
    "crumbs": [
      "Divergence",
      "Data format",
      "Lower triangle"
    ]
  },
  {
    "objectID": "divergence/lower_triangle.html#long-data-frame-of-lower-triangle-values",
    "href": "divergence/lower_triangle.html#long-data-frame-of-lower-triangle-values",
    "title": "Lower triangle",
    "section": "",
    "text": "With our lower triangle matrix we can create a long tibble for future ggplot2 plot production.\nFor this code we utilising piping (|&gt;) with the below steps:\n\nConvert the matrix lower_tri_mat to a data frame with as.data.frame()\n\nAlthough we will ultimately end up with a tibble we need to carry this out for the next steps to run successfully\nIf we converted the matrix to a tibble with tibble::as_tibble() it would remove the row names which are required for the next command\n\nMove the row names to a column called “Sample_L” with tibble::rownames_to_column\nLongify all the columns except the “Sample_L” column with tidyr::pivot_longer()\n\nThis also serves to convert our data frame to a tibble\n\nRemove rows with NAs (i.e. the upper triangle and diagonal values) with tidyr::drop_na()\nCreate a column called triangle with each value being “lower” with dplyr::mutate(), this is required later\n\n\n#Convert to long data frame of paired distance values\n#We will refer to the different samples in a pair as the left and right pair\nbeta_long_tbl &lt;- \n    lower_tri_mat |&gt;\n        #Convert to data frame\n        as.data.frame() |&gt;\n        #Create column from row names (Sample_L, L = left)\n        tibble::rownames_to_column(\"Sample_L\") |&gt;\n        #Longify\n        #Set names to \"Sample_R\" column (R = right)\n        tidyr::pivot_longer(!Sample_L, names_to=\"Sample_R\", values_to=\"value\") |&gt;\n        #Remove rows with an NA\n        tidyr::drop_na() |&gt;\n        #Create triangle column containing value \"lower\" for each row\n        dplyr::mutate(triangle=\"lower\")\n#Check head of long tibble\nbeta_long_tbl |&gt; head()\n\nGreat! Next we’ll add our metadata to this long data frame.",
    "crumbs": [
      "Divergence",
      "Data format",
      "Lower triangle"
    ]
  },
  {
    "objectID": "divergence/upper_triangle.html",
    "href": "divergence/upper_triangle.html",
    "title": "Upper triangle",
    "section": "",
    "text": "Upper triangle\n\n\n\nBelow is all the code needed to create the long tibble from the upper triangle.\nNote: You can copy, paste, and edit your code for the lower triangle section. Ensure you change all the relevant variable names, strings, annotation, and other code that is different.\n\n#One code cell for the upper triangle long tibble\n\n#Create new upper triangle matrix\nupper_tri_mat &lt;- beta_df_mean\n\n#Convert lower triangle and the diagonal to NAs\nupper_tri_mat[lower.tri(upper_tri_mat, diag = TRUE)] &lt;- NA\n\n#Convert to long data frame of paired distance values\n#We will refer to the different samples in a pair as the left an right pair\nbeta_long_tbl &lt;- \n    upper_tri_mat |&gt;\n        #Convert to data frame\n        as.data.frame() |&gt;\n        #Create column from row names (Sample_l, l = left)\n        tibble::rownames_to_column(\"Sample_L\") |&gt;\n        #Longify\n        #Set names to \"Sample_r\" column (r = right)\n        tidyr::pivot_longer(!Sample_L, names_to=\"Sample_R\", values_to=\"value\") |&gt;\n        #Remove rows with an NA\n        tidyr::drop_na() |&gt;\n        #Create triangle column containing value \"lower\" for each row\n        #REMEMBER To CHANGE THIS VALUE TO \"upper\" IF COPYING AND PASTING\n        dplyr::mutate(triangle=\"upper\")\n#Check head of long tibble\nbeta_long_tbl |&gt; head()\n\n#Extract metadata from original phyloseq object\nmetadf &lt;- phyloseq::sample_data(pseq)\n\n#Add metadata for the left samples\nmetadf_L &lt;-\n    #Extend metadf to match order of left samples\n    metadf[beta_long_tbl$Sample_L,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_L\" as their suffix\ncolnames(metadf_L) &lt;- paste0(colnames(metadf_L),\"_L\")\n#Add metadata_L to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_L)\n\n#Add metadata for the right samples\nmetadf_R &lt;-\n    #Extend metadf to match order of right samples\n    metadf[beta_long_tbl$Sample_R,] |&gt;\n    #Convert to tibble for tidyverse manipulation\n    tibble::as_tibble() |&gt;\n    #Remove sample.name row\n    dplyr::select(-1)\n#Rename columns so they have \"_R\" as their suffix\ncolnames(metadf_R) &lt;- paste0(colnames(metadf_R),\"_R\")\n#Add metadata_R to beta_long_tbl\nbeta_long_tbl &lt;-\n    dplyr::bind_cols(beta_long_tbl, metadf_R)\n#Check head of our long df\nbeta_long_tbl |&gt; head()\n\n#Assign to a new variable\nbeta_upper_long_tbl &lt;- beta_long_tbl\n\n#Remove unwanted metadata objects\nrm(metadf_L, metadf_R)\n\n#Check head of our long tibble\nbeta_upper_long_tbl |&gt; head()",
    "crumbs": [
      "Divergence",
      "Data format",
      "Upper triangle"
    ]
  },
  {
    "objectID": "setup/setup.html",
    "href": "setup/setup.html",
    "title": "Setup",
    "section": "",
    "text": "Below are the instructions to setup you environment in the workshop webVNC and environment.\n\n\n\n\n\nCreate and move into a new directory in your home directory called “adv_R_comm”.\n\nmkdir ~/adv_R_comm\ncd ~/adv_R_comm\n\n\n\n\n\n\n\nLoad the cond env r_community with the following use command:\n\n. usercommunity\n\nNow load jupyter-notebook:\n\njupyter-notebook\n\nIf you need a tutorial on using jupyter-notebook with R please see the following webpage:\nNEOF R community analysis workbook jupyter chapter",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup/setup.html#workshop-directory",
    "href": "setup/setup.html#workshop-directory",
    "title": "Setup",
    "section": "",
    "text": "Create and move into a new directory in your home directory called “adv_R_comm”.\n\nmkdir ~/adv_R_comm\ncd ~/adv_R_comm",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup/setup.html#conda-jupyter-notebook",
    "href": "setup/setup.html#conda-jupyter-notebook",
    "title": "Setup",
    "section": "",
    "text": "Load the cond env r_community with the following use command:\n\n. usercommunity\n\nNow load jupyter-notebook:\n\njupyter-notebook\n\nIf you need a tutorial on using jupyter-notebook with R please see the following webpage:\nNEOF R community analysis workbook jupyter chapter",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "upset/challenge_1.html",
    "href": "upset/challenge_1.html",
    "title": "Challenge class upset plot",
    "section": "",
    "text": "As a challenge create an upset plot with the following instructions:\n\nUse the data within the pseq object we have used for the previous upset plots.\nAggregate the pseq object to class level.\nUse the classes as the sets for the intersections.\nUse the sample names as the groups.\n\nYour upset plot should look like the below:\n\n\n\n\n\nCode solution\n\n\n#Upset plot of class intersections with sample groupings\nclass_samples_upset_plot &lt;- pseq |&gt;\n    #Convert abundances to relative/compositional abundances\n    microbiome::transform(\"compositional\") |&gt;\n    #Aggregate ASVs to class level\n    microbiome::aggregate_taxa(\"Class\", verbose = FALSE) |&gt;\n    #Extract phyla relative abundance table\n    phyloseq::otu_table() |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Class\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Class, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Phylum (sets) column\n    #Results in each row having a unique sample\n    # with a list of the intersection of present phyla\n    dplyr::summarize(Classes = list(Class)) |&gt;\n    #ggplot\n    #Classes (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Classes)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() + \n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./class_intersection_sample_group_upset.png\", \n                plot = class_samples_upset_plot,\n                device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./class_intersection_sample_group_upset.png\")\n\n\n\n\nFantastic! Great effort and I hope you are comfortable with creating upset plots now.\nThis is a good point to stop this upset section and move onto one of the other sections.\nOptionally, you can continue with this section and move onto the next two parts:\n\nLower taxa levels: Creating upset plots of lower taxa levels as the sets of interactions. Involves rare aggregation to reduce the number of taxa for the plot.\nMetadata intersections: Creating upset plots of metadata groupings as the sets of interactions. This allows the comparison of sites and media compared to samples.",
    "crumbs": [
      "Upset",
      "Upset plots",
      "Challenge class upset plot"
    ]
  },
  {
    "objectID": "upset/challenge_1.html#conclusion",
    "href": "upset/challenge_1.html#conclusion",
    "title": "Challenge class upset plot",
    "section": "",
    "text": "Fantastic! Great effort and I hope you are comfortable with creating upset plots now.\nThis is a good point to stop this upset section and move onto one of the other sections.\nOptionally, you can continue with this section and move onto the next two parts:\n\nLower taxa levels: Creating upset plots of lower taxa levels as the sets of interactions. Involves rare aggregation to reduce the number of taxa for the plot.\nMetadata intersections: Creating upset plots of metadata groupings as the sets of interactions. This allows the comparison of sites and media compared to samples.",
    "crumbs": [
      "Upset",
      "Upset plots",
      "Challenge class upset plot"
    ]
  },
  {
    "objectID": "upset/data_and_setup.html",
    "href": "upset/data_and_setup.html",
    "title": "Data & Setup",
    "section": "",
    "text": "Before you carry out any practice you will need to setup your environment by:\n\nEnsuring you have setup your directory, environment, and jupyter-notebook as shown in the overall setup.\nCreating a jupyter-notebook in a new work directory.\nLoading in the required libraries.\nLoading in the data.\n\n\n\n\n\n\nIn the jupyter-notebook file explorer create and move into a new directory called upset, ensure this is a subdiretcory of the main workshop directory (adv_R_comm). We’ll keep each section in its own subdirectory so it is easier to keep the output files separate and tidy.\nCreate a new R based jupyter-notebook called “upset.ipynb”. At the top of the jupyter-notebook add the following headers:\n\nA first level header of “Upset plots”.\nA second level header of “Libraries & data”.\n\n\n\n\n\n\n\nLoad the required libraries/packages in a new code cell.\n\n#Libraries\nlibrary(\"phyloseq\")\nlibrary(\"microbiome\")\nlibrary(\"IRdisplay\")\nlibrary(\"tidyverse\")\nlibrary(\"ggupset\")\n\n\n\n\n\n\n\nWe have a phyloseq object containing ASV abundance data through DADA2 denoising in QIIME2 (theory & code). For our upset plots we will be utilising the Durance river data used in our R community analysis workshop. This is a 16S dataset with two main metadata groupings:\n\nSites: Upper, Middle, and Lower Durance sampling site.\nCulture media: Environmental sample (ENV), TSA, KBC, and CVP.\n\nMore info in the R community analysis workbook\nLoad in the phyloseq object.\n\n#Data\nload(\"/pub14/tea/nsc206/NEOF/R_community/data/phyloseq.RData\")",
    "crumbs": [
      "Upset",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "upset/data_and_setup.html#jupyter-notebook",
    "href": "upset/data_and_setup.html#jupyter-notebook",
    "title": "Data & Setup",
    "section": "",
    "text": "In the jupyter-notebook file explorer create and move into a new directory called upset, ensure this is a subdiretcory of the main workshop directory (adv_R_comm). We’ll keep each section in its own subdirectory so it is easier to keep the output files separate and tidy.\nCreate a new R based jupyter-notebook called “upset.ipynb”. At the top of the jupyter-notebook add the following headers:\n\nA first level header of “Upset plots”.\nA second level header of “Libraries & data”.",
    "crumbs": [
      "Upset",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "upset/data_and_setup.html#libraries",
    "href": "upset/data_and_setup.html#libraries",
    "title": "Data & Setup",
    "section": "",
    "text": "Load the required libraries/packages in a new code cell.\n\n#Libraries\nlibrary(\"phyloseq\")\nlibrary(\"microbiome\")\nlibrary(\"IRdisplay\")\nlibrary(\"tidyverse\")\nlibrary(\"ggupset\")",
    "crumbs": [
      "Upset",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "upset/data_and_setup.html#data",
    "href": "upset/data_and_setup.html#data",
    "title": "Data & Setup",
    "section": "",
    "text": "We have a phyloseq object containing ASV abundance data through DADA2 denoising in QIIME2 (theory & code). For our upset plots we will be utilising the Durance river data used in our R community analysis workshop. This is a 16S dataset with two main metadata groupings:\n\nSites: Upper, Middle, and Lower Durance sampling site.\nCulture media: Environmental sample (ENV), TSA, KBC, and CVP.\n\nMore info in the R community analysis workbook\nLoad in the phyloseq object.\n\n#Data\nload(\"/pub14/tea/nsc206/NEOF/R_community/data/phyloseq.RData\")",
    "crumbs": [
      "Upset",
      "Setup",
      "Data & Setup"
    ]
  },
  {
    "objectID": "upset/metadata_and_taxa.html",
    "href": "upset/metadata_and_taxa.html",
    "title": "Metadata and taxa tibble",
    "section": "",
    "text": "Now we’ll create a total abundance tibble of our metadata categories (rows) against the genera (columns).\n\n\n\n\n\nThe first step is to extract our metadata as a tibble with microbiome::sample_tibble().\n\n#Metadata tibble\nmetadata_tibble &lt;- microbiome::sample_tibble(pseq)\nhead(metadata_tibble)\n\n\n\n\n\n\n  \n\n\nWe will bind our metadata and taxa abundance tables but first lets ensure they have the same order of samples.\n\n#Ensure metadata and otu tibble have same order of samples\nmetadata_tibble$SampleID == genus_tibble$Sample\n\nAll the values are TRUE so the order is the same allowing us to bind the tibbles with dplyr::bind_cols.\n\n#bind metadata and genus tibbles\ngenus_metadata_tibble &lt;- dplyr::bind_cols(metadata_tibble, genus_tibble)\nhead(genus_metadata_tibble)\n\n\n\n\n\n\n  \n\n\nFinally to tidy up the tibble we will remove all the non taxa columns except for the “site” column. We are going to use the sites as the sets for our upset plot.\nCarry this out with dplyr::select()\n\n#Create tibble with site and taxa columns\n#Create vector of \"site\" and the genus names\n#The -1 is to remove the \"Sample\" column name\ncols_to_keep &lt;- c(\"site\", colnames(genus_tibble[,-1]))\n#Subset tibble to our desired columns\nsite_genus_tibble &lt;- genus_metadata_tibble |&gt;\n    #Select all of the columns specified in vector cols_to_keep\n    select(all_of(cols_to_keep))\nhead(site_genus_tibble)",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata and taxa tibble"
    ]
  },
  {
    "objectID": "upset/metadata_and_taxa.html#extract-metadata",
    "href": "upset/metadata_and_taxa.html#extract-metadata",
    "title": "Metadata and taxa tibble",
    "section": "",
    "text": "The first step is to extract our metadata as a tibble with microbiome::sample_tibble().\n\n#Metadata tibble\nmetadata_tibble &lt;- microbiome::sample_tibble(pseq)\nhead(metadata_tibble)",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata and taxa tibble"
    ]
  },
  {
    "objectID": "upset/metadata_and_taxa.html#bind-metadata-and-abundance-tibble",
    "href": "upset/metadata_and_taxa.html#bind-metadata-and-abundance-tibble",
    "title": "Metadata and taxa tibble",
    "section": "",
    "text": "We will bind our metadata and taxa abundance tables but first lets ensure they have the same order of samples.\n\n#Ensure metadata and otu tibble have same order of samples\nmetadata_tibble$SampleID == genus_tibble$Sample\n\nAll the values are TRUE so the order is the same allowing us to bind the tibbles with dplyr::bind_cols.\n\n#bind metadata and genus tibbles\ngenus_metadata_tibble &lt;- dplyr::bind_cols(metadata_tibble, genus_tibble)\nhead(genus_metadata_tibble)",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata and taxa tibble"
    ]
  },
  {
    "objectID": "upset/metadata_and_taxa.html#remove-unwanted-columns",
    "href": "upset/metadata_and_taxa.html#remove-unwanted-columns",
    "title": "Metadata and taxa tibble",
    "section": "",
    "text": "Finally to tidy up the tibble we will remove all the non taxa columns except for the “site” column. We are going to use the sites as the sets for our upset plot.\nCarry this out with dplyr::select()\n\n#Create tibble with site and taxa columns\n#Create vector of \"site\" and the genus names\n#The -1 is to remove the \"Sample\" column name\ncols_to_keep &lt;- c(\"site\", colnames(genus_tibble[,-1]))\n#Subset tibble to our desired columns\nsite_genus_tibble &lt;- genus_metadata_tibble |&gt;\n    #Select all of the columns specified in vector cols_to_keep\n    select(all_of(cols_to_keep))\nhead(site_genus_tibble)",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata and taxa tibble"
    ]
  },
  {
    "objectID": "upset/metadata_upset_plot.html",
    "href": "upset/metadata_upset_plot.html",
    "title": "Metadata upset plot",
    "section": "",
    "text": "Our lasts steps are to format the data into an upset tibble and then create the upset plot.\n\n\n\n\n\nCreating the upset tibble is almost the same as our previous upset plots. However, after longifying, remove absence and removing the “Abundance” column we then use the dplyr::distinct() function. This removes duplicate columns, keeping only one of them.\nThis is important as since multiple samples belong to one metadata group we have multiple duplicated rows. E.g. we could have 3 columns for the Achromobacter and LD pairing.\nCarrying it out this way ensures that if a genus is present in at least one of the samples of a metadata group, it will be included in the interaction.\nCreate the upset tibble.\n\n#Create upset tibble where each row is a unique genus (group) and\n# there is a site column where each row contains a list\n# of the sites the genus is present in (intersection)\nsite_genus_upset_tibble  &lt;- site_genus_tibble |&gt;\n    #Longify tibble    \n    tidyr::pivot_longer(!site, names_to=\"Genus\", values_to=\"Abundance\") |&gt;\n    #Filter out rows with 0 as their abundance level\n    #I.e. remove absence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Remove the Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Remove duplicate rows to prevent multiple values appearing for each site\n    #Carry out with dplyr:distinct() it seems\n    dplyr::distinct() |&gt;\n    #Group by the Genus column to....\n    dplyr::group_by(Genus) |&gt;\n    #Summarise site column so each row has a unique Genus\n    # with a list of the sites each Genus is found in\n    dplyr::summarize(Sites = list(site))\n#Check structure of the first 10 rows of resulting upset tibble\nsite_genus_upset_tibble |&gt; dplyr::slice(1:10) |&gt; str()\n\n\n\n\n\n\n\nWith the upset tibble create the upset plot.\n\n#Upset plot displaying number of intersecting sites with genera as the groups\nupset_plot &lt;- site_genus_upset_tibble |&gt;\nggplot2::ggplot(aes(x = Sites)) +\n    ggplot2::geom_bar() +\n    ggupset::scale_x_upset() +\n    ggplot2::labs(y=\"Genera count\")\nggplot2::ggsave(filename = \"./site_genera_upset.png\", plot = upset_plot,\n    device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./site_genera_upset.png\")",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata upset plot"
    ]
  },
  {
    "objectID": "upset/metadata_upset_plot.html#upset-tibble",
    "href": "upset/metadata_upset_plot.html#upset-tibble",
    "title": "Metadata upset plot",
    "section": "",
    "text": "Creating the upset tibble is almost the same as our previous upset plots. However, after longifying, remove absence and removing the “Abundance” column we then use the dplyr::distinct() function. This removes duplicate columns, keeping only one of them.\nThis is important as since multiple samples belong to one metadata group we have multiple duplicated rows. E.g. we could have 3 columns for the Achromobacter and LD pairing.\nCarrying it out this way ensures that if a genus is present in at least one of the samples of a metadata group, it will be included in the interaction.\nCreate the upset tibble.\n\n#Create upset tibble where each row is a unique genus (group) and\n# there is a site column where each row contains a list\n# of the sites the genus is present in (intersection)\nsite_genus_upset_tibble  &lt;- site_genus_tibble |&gt;\n    #Longify tibble    \n    tidyr::pivot_longer(!site, names_to=\"Genus\", values_to=\"Abundance\") |&gt;\n    #Filter out rows with 0 as their abundance level\n    #I.e. remove absence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Remove the Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Remove duplicate rows to prevent multiple values appearing for each site\n    #Carry out with dplyr:distinct() it seems\n    dplyr::distinct() |&gt;\n    #Group by the Genus column to....\n    dplyr::group_by(Genus) |&gt;\n    #Summarise site column so each row has a unique Genus\n    # with a list of the sites each Genus is found in\n    dplyr::summarize(Sites = list(site))\n#Check structure of the first 10 rows of resulting upset tibble\nsite_genus_upset_tibble |&gt; dplyr::slice(1:10) |&gt; str()",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata upset plot"
    ]
  },
  {
    "objectID": "upset/metadata_upset_plot.html#upset-plot",
    "href": "upset/metadata_upset_plot.html#upset-plot",
    "title": "Metadata upset plot",
    "section": "",
    "text": "With the upset tibble create the upset plot.\n\n#Upset plot displaying number of intersecting sites with genera as the groups\nupset_plot &lt;- site_genus_upset_tibble |&gt;\nggplot2::ggplot(aes(x = Sites)) +\n    ggplot2::geom_bar() +\n    ggupset::scale_x_upset() +\n    ggplot2::labs(y=\"Genera count\")\nggplot2::ggsave(filename = \"./site_genera_upset.png\", plot = upset_plot,\n    device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./site_genera_upset.png\")",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Metadata upset plot"
    ]
  },
  {
    "objectID": "upset/rare_removal_plot.html",
    "href": "upset/rare_removal_plot.html",
    "title": "Rare removal",
    "section": "",
    "text": "In this page we will quickly discuss and show how to use lower taxa levels with rare removal. This involves:\n\nDetermining the number of different taxa at a certain level.\nRemoving rare features (taxa) through rare aggregation.\nFormatting the data and producing an upset plot.\n\nThis upset plot will display the intersection of genera (sets) against the samples (groups).\nWe remove rare features for a few reasons:\n\nTo many sets will make it hard to make a clear plot.\nRare features (taxa) will most likely only add noise when looking at the prominent features (taxa).\n\n\n\n\n\n\nThe easiest method to determine the number of taxa groups at a certain taxonomic level is by aggregating the phyloseq object and display the dimension data of the objects within the aggregated phyloseq object.\nCarry this out for Genus level.\n\n#Aggregate taxa to genus\n#This will also display the dimensions of the tables and data within the phyloseq object\nmicrobiome::aggregate_taxa(pseq, level = \"Genus\")\n\nThis shows we have 172 taxa (i.e. 172 unique genera). This would be to much to visualise in an upset plot so lets reduce that number by removing rare genera (i.e. genera with low abundances across the data).\n\n\n\n\n\n\nTo remove the rare genera we will aggregate the taxa whilst carrying out rare aggregation. This combines rare genera into one taxa group called “Other”. We will then remove this “Other” group as it won’t be interesting to include in our upset plot.\nFor more information on rare aggregation please see our R community analysis workbook.\nCarry out rare aggregation and removal.\n\n#Aggregate to genus and remove rare genera\ngenus_rareaggregate_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome:::transform(\"compositional\") |&gt;\n    #Use thresholds of at least 0.5% relative abundance (detection)\n    # in at least 10% of samples (prevalence)\n    #Thresholds chosen as they lead to a manageable amount of taxa\n    microbiome::aggregate_rare(level = \"Genus\",\n                                detection = 0.005, prevalence = 1/10) |&gt;\n    #Remove the \"Other\" genus which consists of all the rare aggregated taxa\n    phyloseq::subset_taxa(Genus != \"Other\")\n#Overview of phyloseq object\ngenus_rareaggregate_pseq\n\nThis lead to a phyloseq object with 29 taxa which seems like a good number of sets to create an upset plot with.\n\n\n\n\n\n\nWith our rare removed genus phyloseq object we can create an upset plot with:\n\nIntersection of genera sets.\nSamples as the groups.\n\n\n#Upset plot code\ngenus_rare_removed_samples_upset_plot &lt;- genus_rareaggregate_pseq |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Genus\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Phylum, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Genus (sets) column\n    #Results in each row having a unique sample (group)\n    # with a list of the intersection of present genera\n    dplyr::summarize(Genera = list(Genus)) |&gt;\n    #ggplot\n    #Genera (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Genera)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() + \n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./genus_rare_removed_intersection_sample_group_upset.png\", \n                plot = genus_rare_removed_samples_upset_plot,\n                device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./genus_rare_removed_intersection_sample_group_upset.png\")\n\nGreat, you know how to create an upset plot based on a specific taxa level with rare taxa removed. What if you want to see the intersection of rare features?",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare removal"
    ]
  },
  {
    "objectID": "upset/rare_removal_plot.html#number-of-taxa",
    "href": "upset/rare_removal_plot.html#number-of-taxa",
    "title": "Rare removal",
    "section": "",
    "text": "The easiest method to determine the number of taxa groups at a certain taxonomic level is by aggregating the phyloseq object and display the dimension data of the objects within the aggregated phyloseq object.\nCarry this out for Genus level.\n\n#Aggregate taxa to genus\n#This will also display the dimensions of the tables and data within the phyloseq object\nmicrobiome::aggregate_taxa(pseq, level = \"Genus\")\n\nThis shows we have 172 taxa (i.e. 172 unique genera). This would be to much to visualise in an upset plot so lets reduce that number by removing rare genera (i.e. genera with low abundances across the data).",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare removal"
    ]
  },
  {
    "objectID": "upset/rare_removal_plot.html#rare-aggregation-and-removal",
    "href": "upset/rare_removal_plot.html#rare-aggregation-and-removal",
    "title": "Rare removal",
    "section": "",
    "text": "To remove the rare genera we will aggregate the taxa whilst carrying out rare aggregation. This combines rare genera into one taxa group called “Other”. We will then remove this “Other” group as it won’t be interesting to include in our upset plot.\nFor more information on rare aggregation please see our R community analysis workbook.\nCarry out rare aggregation and removal.\n\n#Aggregate to genus and remove rare genera\ngenus_rareaggregate_pseq &lt;- pseq |&gt;\n    #Convert to compositional values\n    microbiome:::transform(\"compositional\") |&gt;\n    #Use thresholds of at least 0.5% relative abundance (detection)\n    # in at least 10% of samples (prevalence)\n    #Thresholds chosen as they lead to a manageable amount of taxa\n    microbiome::aggregate_rare(level = \"Genus\",\n                                detection = 0.005, prevalence = 1/10) |&gt;\n    #Remove the \"Other\" genus which consists of all the rare aggregated taxa\n    phyloseq::subset_taxa(Genus != \"Other\")\n#Overview of phyloseq object\ngenus_rareaggregate_pseq\n\nThis lead to a phyloseq object with 29 taxa which seems like a good number of sets to create an upset plot with.",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare removal"
    ]
  },
  {
    "objectID": "upset/rare_removal_plot.html#upset-plot-creation",
    "href": "upset/rare_removal_plot.html#upset-plot-creation",
    "title": "Rare removal",
    "section": "",
    "text": "With our rare removed genus phyloseq object we can create an upset plot with:\n\nIntersection of genera sets.\nSamples as the groups.\n\n\n#Upset plot code\ngenus_rare_removed_samples_upset_plot &lt;- genus_rareaggregate_pseq |&gt;\n    #Extract otu_table as a tibble\n    microbiome::otu_tibble(column.id = \"Genus\") |&gt;\n    #Longify tibble\n    tidyr::pivot_longer(!Phylum, names_to=\"Sample\", values_to=\"Abundance\") |&gt;\n    #Filter out rows were relative abundance is 0\n    #i.e. retain rows showing presence\n    dplyr::filter(Abundance &gt; 0) |&gt;\n    #Select to remove unwanted Abundance column\n    dplyr::select(-Abundance) |&gt;\n    #Group tibble by the Sample (grouping) column\n    dplyr::group_by(Sample) |&gt;\n    #Summarise the Genus (sets) column\n    #Results in each row having a unique sample (group)\n    # with a list of the intersection of present genera\n    dplyr::summarize(Genera = list(Genus)) |&gt;\n    #ggplot\n    #Genera (intersection) column as the x aesthetic\n    ggplot2::ggplot(aes(x = Genera)) +\n        #Bar chart\n        ggplot2::geom_bar() +\n        #Upset scale on x axis\n        ggupset::scale_x_upset() + \n        #Y label\n        ggplot2::labs(y=\"Sample count\")\n#Save plot to png file\nggplot2::ggsave(filename = \"./genus_rare_removed_intersection_sample_group_upset.png\", \n                plot = genus_rare_removed_samples_upset_plot,\n                device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\n#Dsplay plot in jupyter notebook\nIRdisplay::display_png(file=\"./genus_rare_removed_intersection_sample_group_upset.png\")\n\nGreat, you know how to create an upset plot based on a specific taxa level with rare taxa removed. What if you want to see the intersection of rare features?",
    "crumbs": [
      "Upset",
      "Lower taxa levels",
      "Rare removal"
    ]
  },
  {
    "objectID": "upset/sample_and_taxa.html",
    "href": "upset/sample_and_taxa.html",
    "title": "Sample and taxa tibble",
    "section": "",
    "text": "The first step is to extract the genus abundance table and then transpose it.\nTransposing is vital for the next step as it means that:\n\nEach column is a taxa (except the Sample column)\nEach row is a sample\n\n\n\n\n\n\nCarry out aggregation and transposing.\n\n#Abundance tibble of samples (rows) against egenra (columns)\ngenus_tibble  &lt;- pseq |&gt;\n    #Aggregate to genus\n    microbiome::aggregate_taxa(\"Genus\", verbose = FALSE) |&gt;\n    #Extract otu_table\n    phyloseq::otu_table() |&gt;\n    #Convert to data.frame and transpose\n    as.data.frame() |&gt; t() |&gt;\n    #Convert to tibble\n    dplyr::as_tibble(rownames = \"Sample\")\n#Display top 6 rows of tibble\nhead(genus_tibble)\n\n\n\n\nYou may notice that we do not use the function microbiome::tax_tibble() in the above code. This is because transposing a tibble will create a matrix in a format we do not want. If you want to see this in action you can type and run the below demonstrative code.\n\n#Demonstration on why we don't use microbiome::otu_tibble\n#Can't easily use microbiome::otu_tibble with transpose\n#t() converts the tibble to a matrix\nmicrobiome::otu_tibble(genus_pseq, column.id = \"Sample\") |&gt;\n    t() |&gt;\n    head()",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Sample and taxa tibble"
    ]
  },
  {
    "objectID": "upset/sample_and_taxa.html#transposed-genus-abundance",
    "href": "upset/sample_and_taxa.html#transposed-genus-abundance",
    "title": "Sample and taxa tibble",
    "section": "",
    "text": "Carry out aggregation and transposing.\n\n#Abundance tibble of samples (rows) against egenra (columns)\ngenus_tibble  &lt;- pseq |&gt;\n    #Aggregate to genus\n    microbiome::aggregate_taxa(\"Genus\", verbose = FALSE) |&gt;\n    #Extract otu_table\n    phyloseq::otu_table() |&gt;\n    #Convert to data.frame and transpose\n    as.data.frame() |&gt; t() |&gt;\n    #Convert to tibble\n    dplyr::as_tibble(rownames = \"Sample\")\n#Display top 6 rows of tibble\nhead(genus_tibble)",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Sample and taxa tibble"
    ]
  },
  {
    "objectID": "upset/sample_and_taxa.html#tibbles-and-transposing",
    "href": "upset/sample_and_taxa.html#tibbles-and-transposing",
    "title": "Sample and taxa tibble",
    "section": "",
    "text": "You may notice that we do not use the function microbiome::tax_tibble() in the above code. This is because transposing a tibble will create a matrix in a format we do not want. If you want to see this in action you can type and run the below demonstrative code.\n\n#Demonstration on why we don't use microbiome::otu_tibble\n#Can't easily use microbiome::otu_tibble with transpose\n#t() converts the tibble to a matrix\nmicrobiome::otu_tibble(genus_pseq, column.id = \"Sample\") |&gt;\n    t() |&gt;\n    head()",
    "crumbs": [
      "Upset",
      "Metadata intersections",
      "Sample and taxa tibble"
    ]
  },
  {
    "objectID": "upset/upset.html",
    "href": "upset/upset.html",
    "title": "Upset",
    "section": "",
    "text": "Upset plots are a visualisation method to display intersections between sets. They can be seen as a different form of a venn diagram but are able to effectively display many intersecting sets.\nIn this section we will:",
    "crumbs": [
      "Upset"
    ]
  },
  {
    "objectID": "upset/upset.html#intersecting-sets",
    "href": "upset/upset.html#intersecting-sets",
    "title": "Upset",
    "section": "Intersecting sets",
    "text": "Intersecting sets\n\n\n\nIntersection plots for community analysis can be used to display the number of intersecting features (e.g. taxa) between samples or sample groups. In other words you can display the shared presence of features between groups.\nAdditionally, you can flip it around to display the number of intersecting groups between taxa. This allows you to determine which taxa are common and uncommon across the groups. We will see this later on.",
    "crumbs": [
      "Upset"
    ]
  },
  {
    "objectID": "upset/upset.html#venn-versus-upset",
    "href": "upset/upset.html#venn-versus-upset",
    "title": "Upset",
    "section": "Venn versus Upset",
    "text": "Venn versus Upset\nVenn diagrams and upset plots display the intersections between sets. To demonstrate the concept of intersecting sets this section includes a few examples of these plots. These plots will display:\n\nSets of samples (e.g. S1, S2, & S3).\nThe intersection of phyla.\n\n\n3 way venn diagram\nThree way venn digrams are a classic for visualising intersecting sets. Below is an example showing the number of intersecting phyla across three sets of samples (S1, S2, & S3).\n\n\n\n This above plot shows:\n\n6 phyla are found in all samples.\n3 phyla are present in S1 and S3 but not S2.\n1 phylum is found in S2 that are not present in S1 or S3.\nThere are a total of 25 phyla (4+2+1+3+6+3+6=10)\n\n\nMCQs\n\n\n\nPlease attempt the below MCQs based on the above venn diagram.\n\nHow many phyla are present in S2 & S3 but not S1?\n\n 3 18 6\n\n\n\nHow many phyla are present in S3 but not S1 or S2?\n\n 3 18 6\n\n\n\nHow many total phyla are present in S3?\n\n 3 18 6\n\n\n\n\n\n4 way venn digram\nAlthough venn diagrams can be nice, they become more difficult to parse as more sets are included. Below is a 4 way venn diagram to demonstrate this. It includes the same samples as the above venn diagram but with S4 added in.\n\n\n\n\n\nUpset plot\nInstead of venn diagrams we can use upset plots. Below is an upset plots made from the same data as the above 4 way venn diagram. It consists of 2 parts:\n\nA bar chart of the number of phyla found in the intersections of samples.\nThe intersections of samples displayed with dots and lines.\n\nBy default the order of the x-axis is ordered from frequency within the intersections. I.e. from intersection with highest phyla count to lowest phyla count.\n\n\n\n The first three bars/columns of the above plot shows:\n\nS3 has 5 unique phyla.\nThere are 4 phyla found in all the samples.\nS1 & S4 share four phyla not present in S2 or S3.\n\nOn important note is that intersections with values of 0 are not displayed in upset plots.\n\nMCQs\n\n\n\nPlease attempt the below MCQs based on the above upset plot.\n\nHow many phyla are present in S1, S3, and S2 but not S4?\n\n 12 0 2\n\n\n\nHow many phyla are only present in S4?\n\n 12 0 2\n\n\n\nHow many total phyla are present in S2?\n\n 12 0 2",
    "crumbs": [
      "Upset"
    ]
  },
  {
    "objectID": "upset/upset_plot.html",
    "href": "upset/upset_plot.html",
    "title": "Upset plot",
    "section": "",
    "text": "Upset plot\n\n\n\nNow that we have our upset tibble we can create out upset plot.\nWe’ll carry this out with the ggplot2 package and a variety of its functions.\n\nggplot(aes(x=Samples)): This creates the initial ggplot2 object setting the x aesthetic as our “Sample” column (the intersection list column).\ngeom_bar(): This turns the plot into a bar chart. This will show the number of groups each unique interaction is found in.\nlabs(y=\"Phyla count\"): Let’s us customise the plot labels. In this case we are specifying the y label.\n\nThe main function for creating our upset plot is scale_x_upset() from the package ggupset. This converts the x axis of our bar chart to an intersection scale display (the lines and connected dots). The function is required to make a plot with our upset formatted tibble.\nCreate the upset plot with the below code.\n\n#Upset plot with bar chart\nsamples_phyla_upset_plot &lt;- phyla_upset_tibble |&gt;\n    ggplot2::ggplot(aes(x = Sample)) +\n        #Add bar chart\n        ggplot2::geom_bar() +\n        #Add upset display scale as x axis below bar chart\n        ggupset::scale_x_upset() + \n        #Specify y axis label\n        ggplot2::labs(y=\"Phyla count\")\n#ggsave and display in jupyter\nggplot2::ggsave(filename = \"./sample_intersection_phylum_group_upset.png\", \n                plot = samples_phyla_upset_plot,\n                device = \"png\", dpi = 300, units = \"mm\", height = 200, width = 300)\nIRdisplay::display_png(file=\"./sample_intersection_phylum_group_upset.png\")\n\nThe code will produce the below plot.\n\n\n\nThe above plots shows the number of phyla (groups) found in specific sample (set) intersections. The total phyla count in the bar chart is equal to the total phyla count of our data.\n\nMCQs\n\n\n\nSuper! With the upset plot answer the below MCQs.\nNote: An intersection of one is still an intersection. I.e. Some of the intersections in the plot only contain one sample.\nTip: Right click on image and then select “Open image in new tab” to get a larger image you can zoom in on.\n\nWhich intersection has the highest Phyla count? I.e. which intersection of samples has the highest number of phyla that are only present in it?\n\n MD_ENV_rep2 MD_ENV_rep_1 + MD_ENV_rep2 + UD_ENV_rep3 UD_ENV_rep3 + UD_ENV_rep1 + UD_TSA_rep2\n\n\n\nWhich intersection is on the far right of the plot?\n\n MD_ENV_rep2 MD_ENV_rep_1 + MD_ENV_rep2 + UD_ENV_rep3 UD_ENV_rep3 + UD_ENV_rep1 + UD_TSA_rep2\n\n\n\nWhich of the three intersections is not present in the plot? I.e. which intersection has no phyla unique to it?\n\n MD_ENV_rep2 MD_ENV_rep_1 + MD_ENV_rep2 + UD_ENV_rep3 UD_ENV_rep3 + UD_ENV_rep1 + UD_TSA_rep2",
    "crumbs": [
      "Upset",
      "Upset plots",
      "Upset plot"
    ]
  }
]